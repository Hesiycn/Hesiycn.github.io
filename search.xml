<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【对线程的初认识和初步理解】Youngter-drive</title>
      <link href="/2024/07/15/%E3%80%90%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9D%E8%AE%A4%E8%AF%86%E5%92%8C%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E3%80%91Youngter-drive/"/>
      <url>/2024/07/15/%E3%80%90%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9D%E8%AE%A4%E8%AF%86%E5%92%8C%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E3%80%91Youngter-drive/</url>
      
        <content type="html"><![CDATA[<h1 id="【对线程的初认识和初步理解】Youngter-drive"><a href="#【对线程的初认识和初步理解】Youngter-drive" class="headerlink" title="【对线程的初认识和初步理解】Youngter-drive"></a>【对线程的初认识和初步理解】Youngter-drive</h1><p>查壳有壳脱壳ida</p><p>进入到函数main_0</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/youngter-drive01.png" alt="youngter-drive01"></p><p>第一个函数已经被我改过名称，里面是一个输入函数</p><hr><p><strong>CreateMutexW</strong>是一个Windows API函数，用于<strong>创建命名或未命名的互斥体</strong>（Mutex）对象。<strong>互斥体</strong>是一种同步对象，<strong>允许多个线程&#x3D;&#x3D;同步&#x3D;&#x3D;访问共享资源</strong>，确保<strong>一次只有一个线程</strong>可以<strong>访问该资源</strong>。</p><p><strong>CreateThread</strong>是一个 Windows API 函数，用于<strong>创建一个新的线程</strong>。它允许你<strong>在&#x3D;&#x3D;一个进程中并发执行多个线程&#x3D;&#x3D;<strong>，</strong>每个线程可以&#x3D;&#x3D;独立&#x3D;&#x3D;运行不同的代码</strong>。</p><p><strong>CloseHandle</strong>是一个 Windows API 函数，<strong>用于关闭一个内核对象的句柄。</strong></p><hr><p>跟进<strong>StartAddress</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/startaddress.png" alt="startaddress"></p><p>这里执行完encp函数会暂停100秒</p><p>跟进<strong>sub_9E119F</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/sub_9E119F.png" alt="sub_9E119F"></p><hr><p>当<strong>StartAddress</strong>运行完暂停后运行<strong>sub_9E119F</strong></p><p><strong>sub_9E119F</strong>它只有一个减减的功能，然后暂停给100s</p><p><strong>sub_9E119F</strong>暂停时，此刻<strong>StartAddress</strong>开始进行操作</p><p>即为当<strong>TABLE是奇数</strong>时运行加密；当<strong>TABLE时偶数</strong>时<strong>不进行加密</strong>保留原来状态</p><p>进入<strong>encp</strong>（已经改过名称）</p><hr><p>![encp]<a href="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/encp.png">https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/encp.png</a>)</p><p>这就是加密，大小字符转换和在预定的字符串寻址</p><p>结合上面的线程操作可得出脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&#x27;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#x27;</span></span><br><span class="line">enc = <span class="string">&#x27;TOiZiZtOrYaToUwPnToBsOaOapsyS&#x27;</span></span><br><span class="line">flag = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        flag += enc[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> enc[i].isupper():</span><br><span class="line">            flag += <span class="built_in">chr</span>(txt.find(enc[i]) + <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(txt.find(enc[i]) + <span class="number">38</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>但是会少一个字节，因为TABLE是29，在循环的时候是处理了30个字符</p><p>而密文只有29位所以要猜</p><p>最后猜的出的是要在脚本得出的flag后加上个E</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RVA与FOA的转换 和 空白区域添加代码</title>
      <link href="/2024/07/12/RVA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E6%8D%A2%20%E5%92%8C%20%E7%A9%BA%E7%99%BD%E5%8C%BA%E5%9F%9F%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/07/12/RVA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E6%8D%A2%20%E5%92%8C%20%E7%A9%BA%E7%99%BD%E5%8C%BA%E5%9F%9F%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="RVA与FOA的转换-和-空白区域添加代码"><a href="#RVA与FOA的转换-和-空白区域添加代码" class="headerlink" title="RVA与FOA的转换 和 空白区域添加代码"></a>RVA与FOA的转换 和 空白区域添加代码</h1><h2 id="RVA与FOA的转换"><a href="#RVA与FOA的转换" class="headerlink" title="RVA与FOA的转换"></a>RVA与FOA的转换</h2><p>RVA（相对虚拟地址）：内存地址 - Imagebase</p><p>FOA（文件偏移地址）：</p><p>​1、判断RVA是否在头部</p><p>​（1）如果在头部：FOV &#x3D; RVA</p><p>​2、判断RVA位于哪个节：</p><p>​RVA &gt;&#x3D;节.VirtualAddress</p><p>​RVA&lt;&#x3D;节.VirtualAddress + 当前节<strong>内存对齐后的大小</strong></p><p>​差值 &#x3D; RVA - 节.VirtualAddress</p><p>​3、FOA &#x3D;节 .PointerToRawData + 差值</p><h2 id="空白区域添加代码"><a href="#空白区域添加代码" class="headerlink" title="空白区域添加代码"></a>空白区域添加代码</h2><p>外链帮助：<br>【PE文件入门，一篇就够了】<a href="https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11">https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11</a></p><p>我们要插入这样一个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_4VT9QNAKK83KRDC.webp" alt="img"></p><p>功能呢就是弹出一个这样的错误窗口。这个程序的核心就是调用了一个messagebox函数弹出了一个窗口。由于我们是要对pe文件进行操作，所以肯定不是将代码写入，而是要将机器码插入。就是利于栈传第四个参数0，然后call。 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_KT75GA72HJ2S6H9.webp" alt="img"></p><ol><li><p>构造要写入的代码 6A 00 6A 00 6A 00 6A 00 E8（call）xx xx，我们看到的FF是(near jump)要使用一个什么导入表（后面会学），而我们插入的时候E8利用相对偏移量调用函数。E8后面跟四个字节的相对偏移量offset，怎么计算？还好了解过汇编，offset&#x3D;要跳转的地方的地址-call指令下面一条指令的地址。 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_CXY5HK8P5TZBG2P.webp" alt="img"></p><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_SBJX8WRWC3RF2WS.webp" alt="img"></p><p>将图一标记位置改为call 1c1023 得到图二，后面的0A&#x3D;1c1023-1c1019.我们的目标指示让他弹出窗口，不能破坏程序运行，所以弹出之后我们还要跳回到初始位置，让程序正常运行，我们使用JMP（E9）指令来实现该操作，E9后面也是跟偏移量，用法与E8相同。找到messagebox的地址75858A70。根据call指令的位置来计算。 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_SN5DERUWVXB5EHM.webp" alt="img"></p><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_2WSAU8BCZBMW85C.webp" alt="img"></p><p>E8所在的位置是3A8，这是文件中的位置，我们要考虑的是运行时的位置，所以要把这个地址加上Image Base &#x3D;01000000,所以最后得到的 offset&#x3D;75858A70-010003A8-5&#x3D;7485 86C3.最后跳转到程序的入口处，查看可选头的成员入口值为739D加上Image Base得到0100739D. offset&#x3D;0100739D-010003AD-5&#x3D;6FEB <img src="https://bbs.kanxue.com/upload/attach/202405/984774_JTHAXGTNETD5DTR.webp" alt="img"></p></li><li><p>将程序入口点指向我们插入的代码，</p><p>也就是修改扩展pe头里的入口值</p><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_HWVWN8AGXW9PECU.webp" alt="img"></p></li></ol><p>在108处占4个字节，我们插入的程序起始位置是000003A0.然后，然后就没然后了，程序运行不起，ida和od看到的东西都很奇怪，延误了两天，这里我直接说一下踩的坑，我随意找了一个空白处填充机器码，但后来发现不是所有的位置都能发生跳转，然后就将指令插入在了text段的末尾，然后发现跳转的有些差异，不会跳转在我设置的地方，后知后觉的发现，视频里的老哥演示的的时候拿的是一个文件对齐和内存对齐相同大小的程序，我用的程序是一个不同的，所以就要计算一下 用我们前面学习到的知识。下面理一下步骤</p><ol><li>首先在文件中确定一段空间，然后运行程序的时候查看 是否为空</li><li>插入，根据内存中的位置计算</li><li>改入口，内存中代码的起始位置 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_F2XDXYHGUTVBS3R.webp" alt="img"></li></ol><p>第一次尝试的时候成功弹出了窗口，但是关闭之后没有出现记事本，由此我们可以判断执行完我们的代码后，没有成功的返回原入口。此时才想起来补码写错了，插入的位置是87b0，入口点是739d，739d-83b0-5&#x3D; <img src="https://bbs.kanxue.com/upload/attach/202405/984774_D7HRYQ8HEYMY6CM.webp" alt="img"></p><p>然后我就在e9后面填充了E8 EF 00 00,意识到返回出现问题后，想到了有符号数的符号扩展，应该扩展其符号位即1，所以正确的补码形式是FF FF EF E8,填充进去就是E8 EF FF FF.</p><p>外链帮助：<br>【PE文件入门，一篇就够了】<a href="https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11">https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TEA，XTEA与XXTEA及其例题</title>
      <link href="/2024/07/12/TEA%EF%BC%8CXTEA%E4%B8%8EXXTEA%E5%8F%8A%E5%85%B6%E4%BE%8B%E9%A2%98/"/>
      <url>/2024/07/12/TEA%EF%BC%8CXTEA%E4%B8%8EXXTEA%E5%8F%8A%E5%85%B6%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="TEA，XTEA-与-XXTEA-及其例题"><a href="#TEA，XTEA-与-XXTEA-及其例题" class="headerlink" title="TEA，XTEA 与 XXTEA 及其例题"></a>TEA，XTEA 与 XXTEA 及其例题</h1><p>不介绍背景了，直接上算法</p><h2 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h2><p>TEA 算法是一种对称加密算法，全称为 Tiny Encryption Algorithm。它使用一个 128 位的密钥和 64 位的明文块，通过多轮迭代加密来实现加密过程。TEA 算法的加密和解密过程是相同的，只是密钥的使用顺序不同。其拥有一个叫做 Feistel 结构的密码学结构。这种密码学结构通俗的来讲就是会将加密的 plaintext 分成 L、R 两部分，并且满足 L*{i+1} &#x3D; R_i, R*{i+1} &#x3D; F(K_i,R_i) \oplus L_i 这种交换式的加密方式的一种结构。tea 算法最关键的是要找到 DELTA 值和 128 位的 key。其中 DELTA 常常是存在 0x9e3779b9，但是也存在 DELTA 的值被改变的代码。除了初等 tea 算法，tea 算法还有很多魔改版本。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/tea.png" alt="tea"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, i;     <span class="comment">//v0,v1分别为字符串的低字节高字节</span></span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;               <span class="comment">//加密32轮</span></span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;<span class="comment">//加密后再重新赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0xC6EF3720</span>, i;</span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;                        <span class="comment">//解密时将加密算法的顺序倒过来，还有+=变为-=</span></span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;<span class="comment">//解密后再重新赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,k[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">encrypt</span>(v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">decrypt</span>(v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xTEA"><a href="#xTEA" class="headerlink" title="xTEA"></a>xTEA</h2><p>XTEA 是 TEA 的升级版：</p><p>XTEA 算法的加密和解密过程都是由多轮迭代完成的。每轮迭代都包括四个步骤：轮密钥加、代换、置换和轮密钥加。其中，代换和置换步骤是 XTEA 算法的核心部分。XTEA 算法是 TEA 算法的魔改算法。XTEA 算法四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/xtea.png" alt="xtea"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, delta=<span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], delta=<span class="number">0x9E3779B9</span>, sum=delta*num_rounds;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r=<span class="number">32</span>;<span class="comment">//num_rounds建议取值为32</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">encipher</span>(r, v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">decipher</span>(r, v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xxTEA"><a href="#xxTEA" class="headerlink" title="xxTEA"></a>xxTEA</h2><p>XXtea 算法的基本原理是将明文分成若干个固定长度的块，然后对每个块进行加密。加密过程中，使用一个密钥对每个块进行加密，然后将加密后的块拼接在一起形成密文。<br>解密过程与加密过程相反。使用相同的密钥对密文进行解密，然后将解密后的块拼接在一起形成明文。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/xxtea.png" alt="xxtea"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">2</span>; <span class="comment">//n的绝对值表示v的长度，取正表示加密，取负表示解密</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">btea</span>(v, n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="【xxtea】happytime-elf（同时也练一下监听调试）"><a href="#【xxtea】happytime-elf（同时也练一下监听调试）" class="headerlink" title="【xxtea】happytime.elf（同时也练一下监听调试）"></a>【xxtea】happytime.elf（同时也练一下监听调试）</h2><p>监听前置工作：</p><p>将 ida 中的 linux_server64 拖入到 linux 中</p><p>拖入后 chmod + x linux_server64 chmod +x 你的待调试文件名给予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig 查询ip</span><br><span class="line">./linux_server64进行监听</span><br></pre></td></tr></table></figure><p>查克无壳 ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/happytime01.png" alt="happytime01"></p><p>跟进 cry</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/happytime-cry.png" alt="happytime-cry"></p><p>发现是 xxtea，找了一个 xxtea 的算法模板进行相关修改</p><p>那么第一个图的 v5 就是 key，v6 就是密文</p><p>这里直接用轮数会出问题所以用了下动调直接将加密后轮数得出</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/%E5%81%B7%E6%87%92%E5%8A%A8%E8%B0%83.jpg" alt="偷懒动调"></p><p>exp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x61C88647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX ( ( (z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4) ) ^ ( (sum^y) + (key[(p&amp;3)^e] ^ z) ) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">415</span> / n + <span class="number">114</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">415</span> / n + <span class="number">114</span>;</span><br><span class="line">        sum =  <span class="number">0x52b8cc1f</span>;<span class="comment">//rounds*DELTA;</span></span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">11</span>]= &#123;<span class="number">0x480AC20C</span>,<span class="number">0xCE9037F2</span>,<span class="number">0x8C212018</span>,<span class="number">0xE92A18D</span>,<span class="number">0xA4035274</span>,<span class="number">0x2473AAB1</span>,<span class="number">0xA9EFDB58</span>,<span class="number">0xA52CC5C8</span>,<span class="number">0xE432CB51</span>,<span class="number">0xD04E9223</span>,<span class="number">0x6FD07093</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">0x79696755</span>,<span class="number">0x67346F6C</span>,<span class="number">0x69231231</span>,<span class="number">0x5F674231</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">11</span>;</span><br><span class="line">   <span class="comment">// btea(v, n, k);</span></span><br><span class="line">   <span class="comment">//printf(&quot;0x%0x&quot;,k[3]);</span></span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【xxtea】-NewStarCTF-公开赛赛道-EzTea"><a href="#【xxtea】-NewStarCTF-公开赛赛道-EzTea" class="headerlink" title="【xxtea】[NewStarCTF 公开赛赛道]EzTea"></a>【xxtea】[NewStarCTF 公开赛赛道]EzTea</h2><p>可以看看这位师傅的 blog：<a href="https://www.cnblogs.com/Only-xiaoxiao/p/16759891.html">https://www.cnblogs.com/Only-xiaoxiao/p/16759891.html</a></p><p>查克无壳 ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/newstarCtf01.png" alt="newstarCtf01"></p><p>这是将输入的字符串进行加密后与预定密文比对，</p><p>跟进查看 sub_140011c0</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/newstarCtf02.png" alt="newstarCtf02"></p><p>发现还是 xxtea</p><p>回到前面跟进查看 unk_140004038 获得 key</p><p>查看 dword_140004038 获得密文</p><p>exp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x11451400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z ^ (key[(e ^ p) &amp; 3])) + (y ^ sum)) ^ (((32 * z) ^ (y &gt;&gt; 3)) + ((4 * y) ^ (z &gt;&gt; 4))))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span> / n ;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;A</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">     n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span> / n ;</span><br><span class="line">        sum =  rounds*DELTA;<span class="comment">/*0xbdf7dc00*/</span>;</span><br><span class="line">        <span class="comment">//这次可以用round*常数，也可以动调</span></span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">9</span>]= &#123;<span class="number">0x38FA8A82</span>, <span class="number">0x0D7501380</span>, <span class="number">0x0E40969D</span>, <span class="number">0x4E169120</span>, <span class="number">0x713A29AB</span>, <span class="number">0x6CE5393D</span>, <span class="number">0x0B69D752E</span>, <span class="number">0x841A88E6</span>, <span class="number">0x6F31B459</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">0x19</span>,<span class="number">0x19</span>,<span class="number">0x08</span>,<span class="number">0x10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">9</span>;</span><br><span class="line">   <span class="comment">// btea(v, n, k); //鍔犲瘑</span></span><br><span class="line">   <span class="comment">//printf(&quot;0x%0x&quot;,k[3]);</span></span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大佬们文章与视频，去看看有助于理解"><a href="#大佬们文章与视频，去看看有助于理解" class="headerlink" title="大佬们文章与视频，去看看有助于理解"></a>大佬们文章与视频，去看看有助于理解</h1><p>csdn：（这两我建议配着看）</p><p>1.<a href="https://blog.csdn.net/m0_73393932/article/details/130094306?ops_request_misc=&request_id=&biz_id=102&utm_term=tea%E7%AE%97%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-130094306.142">https://blog.csdn.net/m0_73393932/article/details/130094306?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=tea%E7%AE%97%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-130094306.142</a></p><p>2.<a href="https://blog.csdn.net/xiao__1bai/article/details/123307059">https://blog.csdn.net/xiao__1bai/article/details/123307059</a></p><p>b 站：(第一个视频没有更新到 xxtea 的动画演示理解，第二个 up 麦比较炸)<br>【【动画密码学】TEA(Tiny Encryption Algorithm)|分组加密】 <a href="https://www.bilibili.com/video/BV1Nu411E7wX/?share_source=copy_web&vd_source=86d6e63e560e68bb720088caa831e036">https://www.bilibili.com/video/BV1Nu411E7wX/?share_source=copy_web&amp;vd_source=86d6e63e560e68bb720088caa831e036</a></p><p>【VTuber 深入浅出应用密码学 7-2-1 XTEA 算法 C++代码 对称密码 块密码 分组密码 信息安全】 <a href="https://www.bilibili.com/video/BV1zF411U7ap/?share_source=copy_web&vd_source=86d6e63e560e68bb720088caa831e036">https://www.bilibili.com/video/BV1zF411U7ap/?share_source=copy_web&amp;vd_source=86d6e63e560e68bb720088caa831e036</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DOS头-PE头-节表属性说明</title>
      <link href="/2024/07/11/dos-pe-%E8%8A%82%E8%A1%A8%E5%B1%9E%E6%80%A7/"/>
      <url>/2024/07/11/dos-pe-%E8%8A%82%E8%A1%A8%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="DOS头-PE头-节表属性说明"><a href="#DOS头-PE头-节表属性说明" class="headerlink" title="DOS头-PE头-节表属性说明"></a>DOS头-PE头-节表属性说明</h1><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>dos头由DOS-MZ文件头和DOS块组成</p><h4 id="DOS-MZ文件头"><a href="#DOS-MZ文件头" class="headerlink" title="DOS-MZ文件头"></a>DOS-MZ文件头</h4><p>（下图是16位程序的表，现在已经不用这个结构体）</p><p>&#x3D;&#x3D;<strong>！！！红色结构体成员仍在使用！！！</strong>&#x3D;&#x3D;</p><p><strong>中间黑色成员部分可以随意改动不影响程序的运行</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/DOS-MZ%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="DOS-MZ结构体"></p><p><strong>最后的结构体是计算机查找pe头所在的地址因此也不能随意更改</strong></p><h4 id="DOS块"><a href="#DOS块" class="headerlink" title="DOS块"></a>DOS块</h4><p>处于DOS-MZ头与标准PE头的中间，一般由连接器填充，可以干些猥琐事情</p><p><strong>这块数据可以随意更改不影响程序运行</strong></p><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h2><p>下图是pe结构体</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/pe%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="pe头结构体"></p><p>一个程序的主要重要数据全在标准PE头和扩展PE头中</p><h4 id="PE标识"><a href="#PE标识" class="headerlink" title="PE标识"></a>PE标识</h4><p>占用4字节</p><p>PE标识<strong>不能更改</strong>，程序会检测PE标识是否是正确的值</p><h4 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h4><p>占用20个字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%A0%87%E5%87%86PE%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="标准PE头结构体"></p><p><strong>Machine</strong>标识当前这个程序运行在什么样的cpu型号上</p><p><strong>NumberOfSections</strong>记录当前的PE文件有多少个节</p><p><strong>TImeDataStamp</strong>是从1970年0时0分0秒开始到编译器编译当前程序的时候</p><p>PointerToSymbolTable，NumberOfSymbols与调试相关</p><p><strong>SizeOfOptionalHeader</strong>扩展PE头的大小，默认情况32位是0xE0，64位是0xf0</p><p><strong>Characteristics</strong>表示文件属性，要把该位的16进制转换成2进制，转换成的二进制每一位都有其含义</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/characteristics%E5%90%AB%E4%B9%89%E8%A1%A8.png" alt="characteristics含义表"></p><p>哪位为1，哪位就有相应含义，</p><p><strong>位数是从零开始。从右向左位数递增</strong></p><p>例如0x0026转换成二进制是0000 0000 0010 0110</p><p>其含义是文件是可执行的；不存在行信息；应用程序可处理大于2GB的地址</p><h4 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h4><p>占用224个字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%89%A9%E5%B1%95PE%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93-32-02.png" alt="扩展pe头结构体"></p><p>32位和64位的结构体中最后一个子结构体会不同，</p><p>64位会比32位少几个成员，还有部分成员变成85字节</p><p>先以32位结构体位基准</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%89%A9%E5%B1%95PE%E5%A4%B4-32%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="扩展PE头-32结构体"></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%89%A9%E5%B1%95PE%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93-32-02.png" alt="扩展PE头结构体-32-02"></p><p>主要研究红色的部分</p><p><strong>Magic</strong>是用来标识当前程序是32&#x2F;64位，转换成两字节后 <strong>10B是标识32位，20B是标识64位</strong></p><p>BYTE MajorLinkerVersion,BYTE MinorLinkerVersion，存储链接器的版本，由链接器填写，不影响程序运行</p><p>DWORD SizeOfCode，DWORDSizeOfnitializedData，DWORDSizeO fUninitialize dData由编译器填写，不影响程序运行</p><p>&#x3D;&#x3D;<strong>Addre ssOEntrvPoint</strong>&#x3D;&#x3D;是程序入口，是**&#x3D;&#x3D;当前这个程序在哪里开始执行的&#x3D;&#x3D;**，要配合lmageBase（内存镜像基址）来看</p><p>&#x3D;&#x3D;<strong>lmageBase</strong>&#x3D;&#x3D;是内存镜像基址，由它决定&#x3D;&#x3D;<strong>程序在内存执行的时候在哪个地址展开</strong>&#x3D;&#x3D;</p><p><strong>&#x3D;&#x3D;（！！！展开不是执行！！！）&#x3D;&#x3D;</strong></p><p>实际的程序在内存的入口是&#x3D;&#x3D;<strong>lmageBase</strong>&#x3D;&#x3D; <strong>+</strong> &#x3D;&#x3D;<strong>Addre ssOEntrvPoint</strong>&#x3D;&#x3D;</p><p><strong>SectionAlignment. 内存对齐（看上个笔记把）</strong><br><strong>FileAlignment文件对齐（看上个笔记把）</strong></p><p>MajorOperatingSystemVersion:标识损作系统版本号 主版本号</p><p>MinorOperatingSyste mVersion;标识损作系统版本号 次版本号</p><p>MajorlmageVersion.PE文件自身的版本号</p><p>MinorlmageVersionPE文件自身的质本号</p><p>MajorSubsystemVersion运行所需子系统版本号</p><p>MinorSubsystemVersion:运行所需子系统版本号</p><p>Win32VersionValue;子系统质本的值，必须为0</p><p><strong>SizeOfimage.<strong>内存中整个PE文件展开的尺寸，可比实际的值大，必须是</strong>SectionAlignment整数倍</strong><br><strong>SizeOfHeaders</strong>所有头+节表按照文件对齐后的大小，否则加载会出错必须是<strong>FileAlignment整数倍</strong><br><strong>CheckSum（校验盒）</strong>校验和一些系统文件有要求,用来 判断文件是否被修改，两个字节两个字节相加，溢出不用在意，最后加上文件长度</p><p>Subsystem子系统驱动程序(1) 图形界面(2) 控制台、DLL(3)<br>DllCharacteristics文件特性 不是针对DLL文件的，是<strong>描述文件属性</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/DilCharacteristics.png" alt="DilCharacteristics"></p><p>查找方式与上面标准PE头的一样将16进制转换成2进制，2进制的每一位都有各自的含义</p><p>SizeOfStackReserve初始化时保留的栈大小<br>SizeOfStackCommit初始化时实际提交的大小<br>SizeOHeapReserve 始化时保留的雄大小<br>SizeOfHeapCommit初始化时实践提交的大小<br>LoaderFlags  调试相关<br>NumberOfRvaAndSizes  目录项数目</p><p>IMAGE DATA DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTERIES]</p><p>这是个结构体数组，长度是16个字节，有4个DWORD的成员</p><h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>每个节有40个字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E8%8A%82%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E.png" alt="节表结构说明"></p><p>BYTE NamelIMAGE SIZEOF SHORT_NAME]8字节，当前节的名字，可更改，不影响程序的运行</p><p> <strong>VrtualSize</strong>当前这个节中<strong>没有对齐</strong>后的值，也可以说是当前节<strong>真实的值</strong>是多少</p><p> <strong>VirtualAddress</strong><strong>在内存中的偏移地址,加上ImageBase才是在内存中的真正地址</strong><br><strong>SizeOfRawData</strong>节在<strong>文件中</strong>对齐后的尺寸<br><strong>PointerToRawData</strong>节区在<strong>文件</strong>中的偏移</p><p>当有很大一部分<strong>初始化了的全局变量</strong>， &#x3D;&#x3D;<strong>VrtualSize</strong>值一定小于<strong>SizeOfRawData</strong>&#x3D;&#x3D;</p><p>当有很大一部分<strong>未初始化的全局变量</strong>，在<strong>文件中不给变量分配空间</strong>，但是展开到内存中时要给未初始化的变量初始化，&#x3D;&#x3D;<strong>VrtualSize</strong>会比<strong>SizeOfRawData</strong>大&#x3D;&#x3D;</p><p>这样会让内存很难办，于是内存想**&#x3D;&#x3D;谁大按照谁展开&#x3D;&#x3D;**</p><p><strong>Characteristics</strong>节的属性</p><p>把4字节的16进制转换成2进制后按照对应的位置来查找相关信息</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E8%8A%82%E8%A1%A8%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt="节表属性表"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Snack.exe（ver.鸿辉）</title>
      <link href="/2024/07/10/snack.exe/"/>
      <url>/2024/07/10/snack.exe/</url>
      
        <content type="html"><![CDATA[<h1 id="snack-exe"><a href="#snack-exe" class="headerlink" title="snack.exe"></a>snack.exe</h1><h3 id="rc4的加解密算法相同！！！"><a href="#rc4的加解密算法相同！！！" class="headerlink" title="rc4的加解密算法相同！！！"></a>rc4的加解密算法相同！！！</h3><p>查壳无壳，用ida查看string发现有字符</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/snack01.png" alt="snack01"></p><p>说明是用python写完打包的程序</p><p>使用pyinstxtractor和uncompyle6进行解包和反编译</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">key</span>):</span><br><span class="line">    key_length = <span class="built_in">len</span>(key)</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key_stream</span>(<span class="params">S, length</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    key_stream = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">        key_stream.append(S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">    <span class="keyword">return</span> key_stream</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    S = initialize(key)</span><br><span class="line">    key_stream = generate_key_stream(S, <span class="built_in">len</span>(data))</span><br><span class="line">    decrypted_data = <span class="literal">None</span>((<span class="keyword">lambda</span> <span class="number">.0</span> = <span class="literal">None</span>: [ i ^ data[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(<span class="built_in">range</span>(<span class="built_in">len</span>(data))))</span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line">pygame.init()</span><br><span class="line">WINDOW_WIDTH = <span class="number">800</span></span><br><span class="line">WINDOW_HEIGHT = <span class="number">600</span></span><br><span class="line">SNAKE_SIZE = <span class="number">20</span></span><br><span class="line">SNAKE_SPEED = <span class="number">20</span></span><br><span class="line">WHITE = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">BLACK = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">RED = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</span><br><span class="line">pygame.display.set_caption(<span class="string">&#x27;贪吃蛇&#x27;</span>)</span><br><span class="line">font = pygame.font.Font(<span class="literal">None</span>, <span class="number">36</span>)</span><br><span class="line">snake = [</span><br><span class="line">    (<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">    (<span class="number">210</span>, <span class="number">200</span>),</span><br><span class="line">    (<span class="number">220</span>, <span class="number">200</span>)]</span><br><span class="line">snake_direction = (SNAKE_SPEED, <span class="number">0</span>)</span><br><span class="line">food = ((random.randint(<span class="number">0</span>, WINDOW_WIDTH - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE, (random.randint(<span class="number">0</span>, WINDOW_HEIGHT - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE)</span><br><span class="line">key_bytes = <span class="built_in">bytes</span>((<span class="keyword">lambda</span> <span class="number">.0</span>: [ <span class="built_in">ord</span>(char) <span class="keyword">for</span> char <span class="keyword">in</span> <span class="number">.0</span> ])(key.xor_key))</span><br><span class="line">data = [</span><br><span class="line">    <span class="number">101</span>,<span class="number">97</span>,<span class="number">39</span>,<span class="number">125</span>,<span class="number">218</span>,</span><br><span class="line">    <span class="number">172</span>,<span class="number">205</span>,<span class="number">3</span>,<span class="number">235</span>,<span class="number">195</span>,</span><br><span class="line">    <span class="number">72</span>,<span class="number">125</span>,<span class="number">89</span>, <span class="number">130</span>,<span class="number">103</span>,</span><br><span class="line">    <span class="number">213</span>,<span class="number">120</span>,<span class="number">227</span>,<span class="number">193</span>,<span class="number">67</span>,</span><br><span class="line">    <span class="number">174</span>,<span class="number">71</span>,<span class="number">162</span>,<span class="number">248</span>,<span class="number">244</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">238</span>,<span class="number">92</span>,<span class="number">160</span>,<span class="number">203</span>,<span class="number">185</span>,<span class="number">155</span>]</span><br><span class="line">decrypted_data = decrypt(<span class="built_in">bytes</span>(data), key_bytes)</span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> running:</span><br><span class="line">    window.fill(BLACK)</span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">            running = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYDOWN <span class="keyword">or</span> event.key == pygame.K_UP:</span><br><span class="line">            snake_direction = (<span class="number">0</span>, -SNAKE_SPEED)</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_DOWN:</span><br><span class="line">            snake_direction = (<span class="number">0</span>, SNAKE_SPEED)</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_LEFT:</span><br><span class="line">            snake_direction = (-SNAKE_SPEED, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_RIGHT:</span><br><span class="line">            snake_direction = (SNAKE_SPEED, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            snake_head = (snake[<span class="number">0</span>][<span class="number">0</span>] + snake_direction[<span class="number">0</span>], snake[<span class="number">0</span>][<span class="number">1</span>] + snake_direction[<span class="number">1</span>])</span><br><span class="line">            snake.insert(<span class="number">0</span>, snake_head)</span><br><span class="line">            snake.pop()</span><br><span class="line">            <span class="keyword">if</span> snake[<span class="number">0</span>] == food:</span><br><span class="line">                food = ((random.randint(<span class="number">0</span>, WINDOW_WIDTH - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE, (random.randint(<span class="number">0</span>, WINDOW_HEIGHT - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE)</span><br><span class="line">                snake.append(snake[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> snake[<span class="number">0</span>][<span class="number">0</span>] &lt; <span class="number">0</span> <span class="keyword">and</span> snake[<span class="number">0</span>][<span class="number">0</span>] &gt;= WINDOW_WIDTH <span class="keyword">and</span> snake[<span class="number">0</span>][<span class="number">1</span>] &lt; <span class="number">0</span> <span class="keyword">and</span> snake[<span class="number">0</span>][<span class="number">1</span>] &gt;= WINDOW_HEIGHT <span class="keyword">or</span> snake[<span class="number">0</span>] <span class="keyword">in</span> snake[<span class="number">1</span>:]:</span><br><span class="line">        running = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> segment <span class="keyword">in</span> snake:</span><br><span class="line">        pygame.draw.rect(window, WHITE, (segment[<span class="number">0</span>], segment[<span class="number">1</span>], SNAKE_SIZE, SNAKE_SIZE))</span><br><span class="line">    pygame.draw.rect(window, RED, (food[<span class="number">0</span>], food[<span class="number">1</span>], SNAKE_SIZE, SNAKE_SIZE))</span><br><span class="line">    score_text = font.render(<span class="string">f&#x27;&#x27;&#x27;Score: <span class="subst">&#123;<span class="built_in">len</span>(snake)&#125;</span>&#x27;&#x27;&#x27;</span>, <span class="literal">True</span>, WHITE)</span><br><span class="line">    speed_text = font.render(<span class="string">f&#x27;&#x27;&#x27;Speed: <span class="subst">&#123;SNAKE_SPEED&#125;</span>&#x27;&#x27;&#x27;</span>, <span class="literal">True</span>, WHITE)</span><br><span class="line">    window.blit(score_text, (<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    window.blit(speed_text, (<span class="number">10</span>, <span class="number">40</span>))</span><br><span class="line">    score = <span class="built_in">len</span>(snake)</span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">9999</span>:</span><br><span class="line">        flag_text = font.render(<span class="string">&#x27;Flag: &#x27;</span> + decrypted_data.decode(), <span class="literal">True</span>, WHITE)</span><br><span class="line">        window.blit(flag_text, (<span class="number">10</span>, <span class="number">70</span>))</span><br><span class="line">    pygame.display.upate()</span><br><span class="line">    pygame.time.Clock().tick(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">pygame.quit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypted_data.decode())</span><br></pre></td></tr></table></figure><p>前三个函数体是rc4加密</p><p>将贪吃蛇相关的代码删掉和将key.pyc逆向</p><p>后为下列代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">xor_key = <span class="string">&#x27;V3rY_v3Ry_Ez&#x27;</span>  <span class="comment">#这是key的内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">key</span>):</span><br><span class="line">    key_length = <span class="built_in">len</span>(key)</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key_stream</span>(<span class="params">S, length</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    key_stream = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        key_stream.append(S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">    <span class="keyword">return</span> key_stream</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    S = initialize(key)</span><br><span class="line">    key_stream = generate_key_stream(S, <span class="built_in">len</span>(data))</span><br><span class="line">    decrypted_data = <span class="built_in">bytes</span>([ i ^ data[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data))])</span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line">key_bytes = <span class="built_in">bytes</span>(<span class="built_in">ord</span>(char) <span class="keyword">for</span> char <span class="keyword">in</span> (xor_key))</span><br><span class="line"><span class="built_in">print</span>(key_bytes)</span><br><span class="line">data = [</span><br><span class="line">    <span class="number">101</span>,<span class="number">97</span>,<span class="number">39</span>,<span class="number">125</span>,<span class="number">218</span>,</span><br><span class="line">    <span class="number">172</span>,<span class="number">205</span>,<span class="number">3</span>,<span class="number">235</span>,<span class="number">195</span>,</span><br><span class="line">    <span class="number">72</span>,<span class="number">125</span>,<span class="number">89</span>, <span class="number">130</span>,<span class="number">103</span>,</span><br><span class="line">    <span class="number">213</span>,<span class="number">120</span>,<span class="number">227</span>,<span class="number">193</span>,<span class="number">67</span>,</span><br><span class="line">    <span class="number">174</span>,<span class="number">71</span>,<span class="number">162</span>,<span class="number">248</span>,<span class="number">244</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">238</span>,<span class="number">92</span>,<span class="number">160</span>,<span class="number">203</span>,<span class="number">185</span>,<span class="number">155</span>]</span><br><span class="line"></span><br><span class="line">decrypted_data = decrypt(<span class="built_in">bytes</span>(data), key_bytes)</span><br><span class="line"><span class="comment"># flag_text = (&#x27;Flag: &#x27; + chr(decrypted_data))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypted_data)</span><br></pre></td></tr></table></figure><p>但是这段反编译代码有问题</p><p>rc4的初始化是将 s[i]与j[i]交换位置</p><p>而反编译出来的代码**S[i] &#x3D; S[j]  S[j] &#x3D; S[i]**是单纯的赋值并没有交换顺序</p><p>所以正确脚本是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">xor_key = <span class="string">&#x27;V3rY_v3Ry_Ez&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">key</span>):</span><br><span class="line">    key_length = <span class="built_in">len</span>(key)</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % <span class="number">256</span></span><br><span class="line">        <span class="comment"># S[i] = S[j]</span></span><br><span class="line">        <span class="comment"># S[j] = S[i]</span></span><br><span class="line">        S[i],S[j] = S[j],S[i]</span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key_stream</span>(<span class="params">S, length</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    key_stream = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        <span class="comment"># S[i] = S[j]</span></span><br><span class="line">        <span class="comment"># S[j] = S[i]</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line">        key_stream.append(S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">    <span class="keyword">return</span> key_stream</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    S = initialize(key)</span><br><span class="line">    key_stream = generate_key_stream(S, <span class="built_in">len</span>(data))</span><br><span class="line">    decrypted_data = <span class="built_in">bytes</span>([ i ^ data[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data))])</span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line">key_bytes = <span class="built_in">bytes</span>(<span class="built_in">ord</span>(char) <span class="keyword">for</span> char <span class="keyword">in</span> (xor_key))</span><br><span class="line"><span class="comment"># key_bytes = [86,51,114,89,95,118,51,82,121,95,69,122]</span></span><br><span class="line"><span class="built_in">print</span>(key_bytes)</span><br><span class="line">data = [</span><br><span class="line">   <span class="number">101</span>,<span class="number">97</span>,<span class="number">39</span>,<span class="number">125</span>,<span class="number">218</span>,</span><br><span class="line">    <span class="number">172</span>,<span class="number">205</span>,<span class="number">3</span>,<span class="number">235</span>,<span class="number">195</span>,</span><br><span class="line">    <span class="number">72</span>,<span class="number">125</span>,<span class="number">89</span>, <span class="number">130</span>,<span class="number">103</span>,</span><br><span class="line">    <span class="number">213</span>,<span class="number">120</span>,<span class="number">227</span>,<span class="number">193</span>,<span class="number">67</span>,</span><br><span class="line">    <span class="number">174</span>,<span class="number">71</span>,<span class="number">162</span>,<span class="number">248</span>,<span class="number">244</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">238</span>,<span class="number">92</span>,<span class="number">160</span>,<span class="number">203</span>,<span class="number">185</span>,<span class="number">155</span>]</span><br><span class="line">decrypted_data = decrypt(<span class="built_in">bytes</span>(data), key_bytes)</span><br><span class="line"><span class="comment"># flag_text = (&#x27;Flag: &#x27; + chr(decrypted_data))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypted_data)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PE结构的总概与文件格式特征</title>
      <link href="/2024/07/09/PE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/09/PE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="PE-结构"><a href="#PE-结构" class="headerlink" title="PE 结构"></a>PE 结构</h1><h4 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h4><p>可执行文件：可以由操作系统进行加载执行的文件。</p><p>格式：Windows：PE Linux：ELF</p><p>领域涉及：</p><p>​ （1）病毒与反病毒</p><p>​ （2）外挂与反外挂</p><p>​ （3）加壳与脱壳</p><p>​ （4）无源码修改功能·软件汉化等等</p><h4 id="PE-文件特征"><a href="#PE-文件特征" class="headerlink" title="PE 文件特征"></a>PE 文件特征</h4><p>​ <strong>PE 指纹（不要光看后缀名！！！）</strong></p><p>​ <strong>先看前两个字节是不是 MZ</strong></p><p>​ <strong>再看 3C 位置的 16 进制地址</strong></p><p>​ <strong>最后看 3C 所指地址处的前两个字节是不是 PE</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%89%B9%E5%BE%81.png" alt="pe文件格式特征"></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E7%BB%93%E6%9E%84%E8%A1%A8.png" alt="pe结构表"></p><h5 id="DOS-部分"><a href="#DOS-部分" class="headerlink" title="DOS 部分"></a>DOS 部分</h5><p>IMAGE_DOS_HEADER 64 字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe03.png" alt="pe03"></p><p>DOS 块 MZ 块末尾与 PE 头中间的部分</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe04.png" alt="pe04"></p><h5 id="PE-文件头部分"><a href="#PE-文件头部分" class="headerlink" title="PE 文件头部分"></a>PE 文件头部分</h5><p>PE 文件头标志+PE 文件表头+PE 文件头可选部分</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E5%A4%B4.png" alt="pe头"></p><h6 id="PE-文件头标志（DWORD-Signature）"><a href="#PE-文件头标志（DWORD-Signature）" class="headerlink" title="PE 文件头标志（DWORD Signature）"></a>PE 文件头标志（DWORD Signature）</h6><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E9%83%A8%E5%88%86-pe%E6%A0%87%E8%AE%B0.png" alt="pe部分-pe标记"></p><h6 id="PE-文件表头（标准-PE-头）-20-字节"><a href="#PE-文件表头（标准-PE-头）-20-字节" class="headerlink" title="PE 文件表头（标准 PE 头） 20 字节"></a>PE 文件表头（标准 PE 头） 20 字节</h6><p>（IMAGE_FILE_HEADER FileHeader)</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E6%A0%87%E5%87%86pe%E5%A4%B4.png" alt="pe标准pe头"></p><p>标准 PE 头的结构体形式</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%A0%87%E5%87%86pe%E5%A4%B4%E7%BB%93%E6%9E%84.png" alt="标准pe头结构"></p><p><strong>SizeOfOptionalHeader</strong>用来标识<strong>扩展 PE 头</strong>的大小</p><p>不修改的情况下是<strong>32 位是 0xE0</strong>，<strong>64 位是 0xF0</strong>.</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%A0%87%E5%87%86pe%E5%A4%B4%E4%B8%AD%E6%A0%87%E8%AF%86%E7%9A%84%E6%89%A9%E5%B1%95pe%E5%A4%B4%E5%A4%A7%E5%B0%8F.png" alt="标准pe头中标识的扩展pe头大小"></p><h6 id="PE-文件头可选部分（扩展-PE-头）-240-224-字节（64-位-32-位）"><a href="#PE-文件头可选部分（扩展-PE-头）-240-224-字节（64-位-32-位）" class="headerlink" title="PE 文件头可选部分（扩展 PE 头） 240&#x2F;224 字节（64 位&#x2F;32 位）"></a>PE 文件头可选部分（扩展 PE 头） 240&#x2F;224 字节（64 位&#x2F;32 位）</h6><p>（IMAGE_OPTIONAL_HEADER32 OptionalHeader)</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%89%A9%E5%B1%95PE%E5%A4%B4.png" alt="扩展PE头"></p><p>扩展 PE 头的结构体中有一个<strong>SizeOfHeaders</strong>（<strong>DOS 头+PE 文件头+节表按照文件对齐的大小</strong> ）和<strong>FileAlignment</strong>（<strong>文件对齐</strong>）</p><p>！！！<strong>SizeOfHeaders</strong>只能是<strong>FileAlignment</strong>的整倍数！！！</p><p>假设<strong>FileAlignment</strong>设为<strong>200</strong>，<strong>SizeOfHeaders</strong>有用数据只有<strong>350</strong>，但<strong>SizeOfHeaders</strong>的值只能是<strong>400</strong>，剩下的 50 可填写其他数据来补全</p><p><strong>文件对齐大小</strong>：</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/PE%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90%E5%80%BC.png" alt="PE文件对齐值"></p><p>图中是 00 20 转换成 16 进制是 0x0200</p><p>所以<strong>FileAlignment</strong>的值是 200</p><p><strong>头大小：</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe_%E5%A4%B4%E5%A4%A7%E5%B0%8F.png" alt="pe_头大小"></p><p>00 06 转换成 16 进制是 0x0600</p><p>所以在 0x600 之后是<strong>节</strong>的数据、</p><p><strong>内存对齐大小</strong>：</p><p><strong>FileAlignment</strong>的前面是<strong>SelectionAlignment</strong>（<strong>内存对齐</strong>）</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%8C%89%E7%85%A7%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png" alt="按照内存对齐"></p><p><strong>红色</strong>部分是之前的<strong>文件对齐大小</strong></p><p>前面的<strong>蓝色</strong>就是<strong>内存对齐大小</strong></p><p>每个节中的数据同，但是对齐方式不同</p><p>多出的内存空间由 0 来补充</p><p>蓝色部分是 0x1000</p><h5 id="节表部分"><a href="#节表部分" class="headerlink" title="节表部分"></a>节表部分</h5><p>IMAGE_SECTION_HEADER 40 字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E8%8A%82%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="节表结构体"></p><p>节表中的数据有很多个，图中就有 10 组，剩下的是编译器插入的数据</p><p>节表中的每个部分都由 36 个字节组成</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E8%8A%82%E8%A1%A8.jpg" alt="节表"></p><h5 id="节部分"><a href="#节部分" class="headerlink" title="节部分"></a>节部分</h5><p>每个节所占的空间也都是<strong>按照文件对齐</strong>和<strong>按照内存对齐</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>buu[ACTF新生赛2020]usualCrypt</title>
      <link href="/2024/06/04/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/"/>
      <url>/2024/06/04/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/</url>
      
        <content type="html"><![CDATA[<h1 id="ACTF新生赛2020-usualCrypt"><a href="#ACTF新生赛2020-usualCrypt" class="headerlink" title="[ACTF新生赛2020]usualCrypt"></a>[ACTF新生赛2020]usualCrypt</h1><p>打开main函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530175759195.png" alt="image-20240530175759195"></p><p>查看sub_401080</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530175917912.png" alt="image-20240530175917912"></p><p>发现是base64加密</p><p>跟进sub_401000</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530175951159.png" alt="image-20240530175951159"></p><p>发现是将base64的序列码改变了</p><p>回到上一级查看sub_401030</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530180043233.png" alt="image-20240530180043233"></p><p>这是一个大小写切换程序</p><p>回到main函数查看aZmxhz3tignxlxj</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530180237393.png" alt="image-20240530180237393"></p><p>这是加密后的字符串</p><p>所以只要将这个字符串的大小写切换并且用魔改的base64解密就得到了flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">string=<span class="string">&#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;</span>.swapcase()<span class="comment">#大小写转换</span></span><br><span class="line">tables64=<span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#原来的base64表</span></span><br><span class="line">newtable=<span class="string">&#x27;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#现在表</span></span><br><span class="line">maketrans=<span class="built_in">str</span>.maketrans(newtable,tables64)<span class="comment">#不会，记住吧，铁子们</span></span><br><span class="line">translate=string.translate(maketrans)</span><br><span class="line">flag=base64.b64decode(string.translate(<span class="built_in">str</span>.maketrans(newtable,tables64)))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>buu[HDCTF]MAZE</title>
      <link href="/2024/06/04/%5BHDCTF2019%5DMaze/"/>
      <url>/2024/06/04/%5BHDCTF2019%5DMaze/</url>
      
        <content type="html"><![CDATA[<h2 id="HDCTF2019-Maze4"><a href="#HDCTF2019-Maze4" class="headerlink" title="[HDCTF2019]Maze4"></a>[HDCTF2019]Maze4</h2><p>这个题主要是学习花指令的去除，迷宫并不难</p><p>不过在使用upx去壳前需要把文件名中的空格去除，否则会脱壳失败</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze01.png" alt="hdmaze01"></p><p>（花指令的有关内容相关请看以下文章）</p><p><a href="https://bbs.kanxue.com/thread-279604.htm">https://bbs.kanxue.com/thread-279604.htm</a></p><p><a href="https://blog.csdn.net/abel_big_xu/article/details/117927674">https://blog.csdn.net/abel_big_xu/article/details/117927674</a></p><p><a href="https://blog.csdn.net/m0_46296905/article/details/117336574">https://blog.csdn.net/m0_46296905/article/details/117336574</a></p><p>然后拖入ida中发现有花指令</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze02.png" alt="hdmaze02"></p><p>摁u转换成二进制</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze03.png" alt="hdmaze03"></p><p>摁c重新分析为代码</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze04.png" alt="hdmaze04"></p><p>选定全部的红色地址摁p进行生成函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze05.png" alt="hdmaze05"></p><p>这时main函数就被解出来了然后进入点击f5</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze06.png" alt="hdmaze06"></p><p>asc_408078和dword_40807c只要放在哪就行,</p><p>但是w（上）s（下）a（左）d（右）考虑的就比较多了</p><p>shift+f12查看字符串表找到迷宫地图</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze07.png" alt="hdmaze07"></p><p>长度是70个字符，可能是7*10或者10*7（建议去一些编程环境内进行排列，有字符自动对齐）</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze08.png" alt="hdmaze08"></p><p>flag就是通关迷宫时键盘的输入</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LitCTF2024逆向wp</title>
      <link href="/2024/06/03/litctf24%EF%BC%88%E9%83%BD%E6%98%AF%E8%80%BB%E8%BE%B1%EF%BC%89/"/>
      <url>/2024/06/03/litctf24%EF%BC%88%E9%83%BD%E6%98%AF%E8%80%BB%E8%BE%B1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="litctf24（都是耻辱）"><a href="#litctf24（都是耻辱）" class="headerlink" title="litctf24（都是耻辱）"></a>litctf24（都是耻辱）</h1><h2 id="RUNMRE"><a href="#RUNMRE" class="headerlink" title="RUNMRE"></a>RUNMRE</h2><p>无壳，拿查看shift+F12</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/runme01.png" alt="runme01"></p><p>第一行是base64加密后的字符串</p><p>第二行是魔改后的base表</p><p>&#x3D;&#x3D;这是原表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#x3D;&#x3D;</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/runme02.png" alt="runme02"></p><h2 id="ezpython（与三个python的环境默认缠斗一上午）"><a href="#ezpython（与三个python的环境默认缠斗一上午）" class="headerlink" title="ezpython（与三个python的环境默认缠斗一上午）"></a>ezpython（与三个python的环境默认缠斗一上午）</h2><p>python打包成的exe我们要用pyinstxtractor.py来进行解包</p><p>解完包我们将ezpy.pyc扔进在线网站中反编译成.py</p><p>（反编译网站<a href="https://www.lddgo.net/string/pyc-compile-decompile%EF%BC%89">https://www.lddgo.net/string/pyc-compile-decompile）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Litctfbase64</span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;flag:&#x27;</span>)</span><br><span class="line">flag = Litctfbase64.b64decode(flag)</span><br><span class="line"><span class="keyword">if</span> flag == <span class="string">&#x27;X=3o4hx=0EZwf=mMv13gX=3o4hx=qje2ZjtgZQmEKXZog4==&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;win&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后我们去解包后产生的文件夹的PYZ-00.pyz_extracted文件夹找到Litctfbase64.pyc</p><p>同上诉步骤进行反编译成.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">BASE64_ALPHABET = <span class="string">&#x27;8kuWYm=1JiUPs7DT4x+X5tcqZKfGvA0gFLB6y3QbV2rNOlRdMwnEohjzSe9/HIa-&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64decode</span>(<span class="params">input_string</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># WARNING: Decompyle incomplete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_base64</span>(<span class="params">base64_string</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># WARNING: Decompyle incomplete</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获得了base64的魔改表</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezpy01.png" alt="ezpy01"></p><h2 id="hello-upx-你是真的逆天"><a href="#hello-upx-你是真的逆天" class="headerlink" title="hello_upx(你是真的逆天)"></a>hello_upx(你是真的逆天)</h2><p>既然是upx就进行脱壳,但是会有报错提示被hacked</p><p>用010打开乍看没有问题,实际上出题人吧**&#x3D;&#x3D;UPX&#x3D;&#x3D;<strong>替换成了小写的</strong>upx**</p><p>于是我们将upx改正为UPX然后再脱壳拖入ida中查看main函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/hello_upx02.png" alt="hello_upx02"></p><p>v4和v5共同组成一个小端序</p><p>当v4[i]&#x3D;v6[i]-i时输出good</p><p>所以脚本为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> =[<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x72</span>,<span class="number">0x40</span>,<span class="number">0x50</span>,<span class="number">0x41</span>,<span class="number">0x75</span>,<span class="number">0x70</span>,<span class="number">0x2B</span>,<span class="number">0x63</span>,<span class="number">0x59</span>,<span class="number">0x25</span>,<span class="number">0x61</span>,<span class="number">0x58</span>,<span class="number">0x51</span>,<span class="number">0x65</span>,<span class="number">0x20</span>,<span class="number">0x4E</span>,<span class="number">0x5A</span>,<span class="number">0x1E</span>,<span class="number">0x60</span>,<span class="number">0x4E</span>,<span class="number">0x5E</span>,<span class="number">0x4F</span>,<span class="number">0x65</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">str</span>[i] + i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="ezRC4"><a href="#ezRC4" class="headerlink" title="ezRC4"></a>ezRC4</h2><p>直接动调会闪退，main0有个反调试程序我们需要在这里打个断点</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc405.png" alt="ezrc405"></p><p>然后在上面调成这样进行单步调试（f7）</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc401.jpg" alt="ezrc401"></p><p>进入调试后在进到这一步时我们需要将ZF的值改成1然后进入到<strong>真</strong>模块否则就会自动退出</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc401.png" alt="ezrc401"></p><p>f7单步进入</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc404.png" alt="ezrc404"></p><p>到这里时发现我们之前在静态函数里发现的key</p><p>第二个块是对key进行解密</p><p>解密后的key为</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc403.png" alt="ezrc403"></p><p>然后根据前面静态的main函数中的buf1</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc402.png" alt="ezrc402"></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/rc406.png" alt="rc406"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2024/05/21/%E6%B1%87%E7%BC%96/"/>
      <url>/2024/05/21/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="第一章基础知识"><a href="#第一章基础知识" class="headerlink" title="第一章基础知识"></a>第一章基础知识</h2><h4 id="汇编语言的组成："><a href="#汇编语言的组成：" class="headerlink" title="汇编语言的组成："></a>汇编语言的组成：</h4><p>&#x3D;&#x3D;1.汇编指令（核心）&#x3D;&#x3D;：机器码的助记符，有对应的机器码。</p><p>2.伪指令：没有对应的机器码，由编译器<em><strong>执行</strong></em>，计算机并不执行。</p><p>3.其他符号：如+、-、*、&#x2F;等，由编译器 <em><strong>识别</strong></em>，没有对应的机器码。。</p><h4 id="储存单元："><a href="#储存单元：" class="headerlink" title="储存单元："></a>储存单元：</h4><p>&#x3D;&#x3D;n位的cpu，<strong>一个字</strong>就有<strong>（n&#x2F;8）个字节</strong>&#x3D;&#x3D;（这应该是第二章的内容，但是我觉得首先要把单位分清楚就放在这里了）</p><p>&#x3D;&#x3D;<strong>Byte</strong>（储存单元&#x2F;字节）简写 <strong>B</strong>&#x3D;&#x3D;</p><p><strong>1KB&#x3D;1024B1MB&#x3D;1024KB1GB&#x3D;1024MB1TB&#x3D;1024GB</strong></p><p><strong>1024 &#x3D; 10^10</strong></p><p>计算机最小单位是<strong>bit（比特）</strong>如果一个计算机有<strong>128</strong>个<strong>储存单元</strong>，<strong>编号从0~127</strong></p><p><img src="/2024/05/21/%E6%B1%87%E7%BC%96/Users\admin\Desktop\微信图片_20231119201725.png" alt="微信图片_20231119201725"></p><h4 id="cpu对储存器都读写"><a href="#cpu对储存器都读写" class="headerlink" title="cpu对储存器都读写"></a>cpu对储存器都读写</h4><p>CPU 要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面 3类信息的交互。<br><strong>1.存储单元的地址(地址信息);</strong><br><strong>2.器件的选择，读或写的命令(控制信息);</strong><br><strong>3.读或写的数据(数据信息)。</strong></p><p>CPU 是通过**&#x3D;&#x3D;总线&#x3D;&#x3D;**将地址、数据和控制信息传到存储器芯片中的</p><p>**&#x3D;&#x3D;总线&#x3D;&#x3D;<strong>是计算机中专门连接CPU 和其他芯片的导线。从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3 类，</strong>&#x3D;&#x3D;地址总线&#x3D;&#x3D;<strong>、&#x3D;&#x3D;<strong>控制总线</strong>&#x3D;&#x3D;和</strong>&#x3D;&#x3D;数据总线&#x3D;&#x3D;**。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120152544401.png" alt="image-20231120152544401"></p><p>(1)CPU 通过地址线将地址信息3 发出。</p><p>(2)CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</p><p>(3)存储器将3号单元中的数据8通过数据线送入CPU。</p><h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p>一个CPU有<strong>N根地址线</strong>，则可以说这个 CPU 的<strong>地址总线的&#x3D;&#x3D;宽度&#x3D;&#x3D;为 N</strong>。这样的 CPU最多可以寻找<strong>2的N 次方</strong>个内存单元。<strong>最小数是0，最大数是(2^n)-1</strong></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120153933375.png" alt="image-20231120153933375"></p><p>图1.4展示了一个具有 1根地址线的CPU向内存发出地址信息11时 10根地址线上传送的二进制信息。</p><h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>CPU 与内存或其他器件之间的<strong>数据传送</strong>是通过<strong>数据总线</strong>来进行的。<em><em>数据总线的&#x3D;&#x3D;宽度&#x3D;&#x3D;<strong>决定了 <em><strong>CPU</strong></em> 和</strong></em>外界的数据</em><strong><strong>&#x3D;&#x3D;传送速度&#x3D;&#x3D;<strong>。</strong>8</strong> 根数据总线一次可传送<strong>一个</strong> <em><strong>&#x3D;&#x3D;字节&#x3D;&#x3D;</strong></em>(字节是8进制数据)。**16</strong> 根数据总线一次可传送<strong>两个字节</strong>。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120154658074.png" alt="image-20231120154658074"></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120154746520.png" alt="image-20231120154746520"></p><h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>CPU 对外部器件的控制是通过<strong>控制总线</strong>来进行的。在这里控制总线是个总称，<strong>控制总线是一些不同控制线的集合</strong>。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，**&#x3D;&#x3D;控制总线的宽度决定了 CPU 对外部器件的控制能力。&#x3D;&#x3D;**<br>前面所讲的内存<strong>读或写</strong>命令是由<strong>几根控制线综合发出</strong>的，其中有一根称为<strong>“读信号输出”</strong>的<strong>控制线</strong>负责<strong>由 CPU 向外传送读信号</strong>，CPU 向该控制线上输出<strong>低电平表示将要读取数据</strong>:有一根称为“<strong>写信号输出”的控制线</strong>则负责<strong>传送写信号</strong>。</p><h4 id="内存地址空间-概述"><a href="#内存地址空间-概述" class="headerlink" title="内存地址空间(概述)"></a>内存地址空间(概述)</h4><p>什么是内存地址空间呢?举例来讲，一个 CPU 的地址总线宽度为 10，那么可以寻址1024 个内存单元，**&#x3D;&#x3D;这 1024 个可寻到的内存单元就构成这个CPU的内存地址空间&#x3D;&#x3D;**。</p><h4 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h4><p>在每一台 PC 机中，都有一个主板，<strong>主板上有核心器件和一些主要器件</strong>，<strong>这些器件通过总线(地址总线、数据总线、控制总线)相连</strong>。这些器件有 <strong>CPU、存储器、外围芯片组、扩展插槽等</strong>。<strong>扩展插槽上一般插有 RAM内存条和各类接口卡</strong>。</p><h4 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h4><p>计算机系统中，所有可用程序控制其工作的设备，必须受到 CPU 的控制。CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。<strong>扩展插槽&#x3D;&#x3D;通过总线&#x3D;&#x3D;和 &#x3D;&#x3D;CPU&#x3D;&#x3D; 相连，所以&#x3D;&#x3D;接卡也通过总线同 CPU&#x3D;&#x3D;相连</strong>。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。*&#x3D;&#x3D;<strong>简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。</strong>&#x3D;&#x3D;*</p><p><strong>各类存储器芯片</strong></p><p>分为<strong>ROM（只读储存器）</strong>与<strong>RAM（随机储存器）</strong></p><p><strong>随机存储器</strong><br>用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM 组成，<strong>装在主板上 RAM 和插在扩展插槽上的RAM。</strong></p><p><strong>装有BIOS(BasicInput&#x2F;Output System，基本输入&#x2F;输出系统)的ROM</strong></p><p>BIOS 是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。</p><p><strong>接口卡上的 RAM</strong><br>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。<strong>最典型的是显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。</strong>换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。<img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121102521329.png" alt="image-20231121102521329"></p><h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121102715622.png" alt="image-20231121102715622"></p><p>在图 1.8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，<strong>每个物理存储器在这个逻辑存储器中占有一个地址段，&#x3D;&#x3D;即一段地址空间&#x3D;&#x3D;<strong>。</strong>&#x3D;&#x3D;CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。&#x3D;&#x3D;</strong></p><h2 id="第二章寄存器-你猜他为什么会有个“寄”（）"><a href="#第二章寄存器-你猜他为什么会有个“寄”（）" class="headerlink" title="第二章寄存器&#x2F;&#x2F;你猜他为什么会有个“寄”（）"></a>第二章寄存器&#x2F;&#x2F;你猜他为什么会有个“寄”（）</h2><p>在cpu中<strong>寄存器进行信息储存</strong></p><p><strong>不同的 CPU，寄存器的个数、结构是不相同的</strong>。8086CPU 有14 个寄存器，每个寄存器有一个名称。这些寄存器是: AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121104928194.png" alt="image-20231121104928194"></p><p><strong>8086CPU的上一代 CPU 中的寄存器都是 8位的</strong>，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在 8086之上，<strong>8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用:</strong></p><p><strong>AX</strong> 可分为<strong>AH</strong>和<strong>AL;</strong><br><strong>BX</strong>可分为<strong>BH</strong>和<strong>BL</strong>;<br><strong>CX</strong>可分为<strong>CH</strong>和<strong>CL</strong>;<br><strong>DX</strong>可分为 <strong>DH</strong>和<strong>DL</strong></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121105907995.png" alt="image-20231121105907995"></p><p>AX的低8位(0位<del>7位)构成了AL寄存器，存器高8位(8位</del>15位)构成了AH寄存器。AH 和AL 寄存器是可以独立使用的 8 位存器。<img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121110012138.png" alt="image-20231121110012138"></p><h4 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="&#x3D;&#x3D;几条汇编指令&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;几条汇编指令&#x3D;&#x3D;</strong></h4><p><em><strong>mov与add</strong></em></p><table><thead><tr><th>汇编指令</th><th>控制CPU完成的操作</th><th>用高级语言的语法描述</th></tr></thead><tbody><tr><td>mov ax,18</td><td><strong>将18送入寄存器AX</strong></td><td>AX&#x3D;18</td></tr><tr><td>mov ah,78</td><td><strong>将78送入寄存器AH</strong></td><td>AH&#x3D;78</td></tr><tr><td>add ax,8</td><td><strong>将寄存器AX中的数值加上8</strong></td><td>AX&#x3D;AX+8</td></tr><tr><td>mov ax,bx</td><td><strong>将寄存器BX中的数据送入寄存器AX</strong></td><td>AX-BX</td></tr><tr><td>add ax,bx</td><td><strong>将AX和BX中的数值相加，结果存在AX中</strong></td><td>AX-AX+BX</td></tr></tbody></table><p><strong>在进行数据传送或运算时，要注意指令的&#x3D;&#x3D;两个操作对象的位数应当是一致的&#x3D;&#x3D;</strong></p><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>CPU 访问内存单元时，要<strong>给出内存单元的地址</strong>。所有的内存单元构成的存储空间是一个一维的线性空间，<strong>每一个内存单元在这个空间中都有唯一的地址</strong>，我们将这个<strong>唯一的地址</strong>称为<strong>物理地址。</strong><br><strong>CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址</strong>。在 CPU 向地址总线上发出物理地址之前，<strong>必须要在内部先形成这个物理地址</strong>。不同的 CPU 可以有不同的形成物理地址的方式。我们现在讨论 8086CPU 是如何在内部形成内存单元的物理地址的。</p><h4 id="16位结构cpu（典型8086）"><a href="#16位结构cpu（典型8086）" class="headerlink" title="16位结构cpu（典型8086）"></a>16位结构cpu（典型8086）</h4><p><strong>概括地讲，16 位结构(<strong>16 位机、字长为 16 位等常见说法，与 16 位结构的含相同)<strong>描述了一个CPU具有下面几方面的结构特性。</strong><br><strong>1.运算器一次最多可以处理 16位的数据</strong><br><strong>2.寄存器的最大宽度为16位;</strong><br><strong>3.寄存器和运算器之间的通路为 16位</strong><br>8086 是 16 位结构的 CPU，</strong>这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。</strong>内存单元的地址在送上地址总线之前，必须在 CPU中处理、传输、暂时存放，<strong>对于 16位 CPU，能一次性处理、传输、暂时存储 16位的地址</strong>。</p><h4 id="8086cpu给出物理地址的方法"><a href="#8086cpu给出物理地址的方法" class="headerlink" title="8086cpu给出物理地址的方法"></a><strong>8086cpu给出物理地址的方法</strong></h4><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为 16 位。<br>8086CPU采用一种在内部用两个 16位地址合成的方法来形成一个20位的物理地址8086CPU相关部件的逻辑结构如图2.6所示。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121202629121.png" alt="image-20231121202629121"></p><p>当8086CPU要读写内存时:<br>1.CPU中的相关部件提供<strong>两个16位的地址</strong>，一个称为<strong>段地址</strong>，另一个称为<strong>偏移地址:</strong></p><p>2.<strong>段地址和偏移地址</strong>通过<strong>内部总线</strong>送入一个称为<strong>地址加法器</strong>的部件;</p><p>3.<strong>地址加法器将两个16位地址</strong>合成为<strong>一个20位的物理地址;</strong></p><p>4**.地址加法器<strong>通过</strong>内部总线<strong>将 <strong>20位物理地址</strong>送入</strong>输入输出控制电路**;</p><p>5.<strong>输入输出控制电路</strong>将 <strong>20位物理地址</strong>送上<strong>地址总线</strong>:</p><p>6.<strong>20位物理地址被地址总线传送到存储器。</strong></p><p>地址加法器采用<strong>物理地址&#x3D;段地址X16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址。例如，8086CPU 要访问地址为 123C8H 的内存单元，此时，地址加法器的工作过程如图 2.7 所示。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231123201756825.png" alt="image-20231123201756825"></p><p><strong>&#x3D;&#x3D;一个数据的十六进制形式左移1位，相当于乘以16:一个数据的十进形式左移1位，相当于乘以10;一个X进制的数据左移1位，相当于乘以X。&#x3D;&#x3D;</strong></p><h4 id="“段地址X16-偏移地址-物理地址”的本质含义"><a href="#“段地址X16-偏移地址-物理地址”的本质含义" class="headerlink" title="“段地址X16+偏移地址&#x3D;物理地址”的本质含义"></a>“段地址X16+偏移地址&#x3D;物理地址”的本质含义</h4><p><strong>“段地址x16+偏移地址&#x3D;物理地址”</strong>的本质含义是:CPU 在访问内存时，用一个**&#x3D;&#x3D;基础地址&#x3D;&#x3D;(段地址X16)<strong>和一个</strong><u>相对于</u>基础地址的&#x3D;&#x3D;偏移地址&#x3D;&#x3D;<strong>相加，</strong>给出内存单元的物理地址<strong>。<br>更一般地说，8086CPU的这种寻址功能是&#x3D;&#x3D;</strong><u>“基础地址+偏移地址&#x3D;物理地址”</u><strong>&#x3D;&#x3D;（</strong>这就是本质，请牢记它**）寻址模式的一种具体实现方案。8086CPU 中，段地址x16 可看作是基础地址。</p><h4 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h4><p>其实，内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用“基础地址(段地址X16)+偏移地址&#x3D;物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。</p><p>以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址X16 定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元。<strong>有两点需要注意:&#x3D;&#x3D;段地址X16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数&#x3D;&#x3D;: &#x3D;&#x3D;偏移地址为16位，16位地址的寻址能力为 64KB，所以一个段的长度最大为 64KB&#x3D;&#x3D;</strong></p><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>什么部件提供段地址。段地址在 8086CPU 的段寄存器中存放。8086CPU 有 <strong>4 个段存器:CS、DS、SS、ES</strong>。当8086CPU 要访问内存时由这4个段寄存器提供内存单元的段地址。</p><h4 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h4><p><strong>CS和IP</strong>是8086CPU中两个最关键的存器，它们指示了CPU 当前要读取指令的地址。<strong>CS 为代码段寄存器，IP为指令指针寄存器</strong>。<br>在8086PC 机中，任意时刻，<strong>设 CS 中的内容为M</strong>，<strong>IP 中的内容为N</strong>，8086CPU 将<strong>从内存Mx16+N单元开始</strong>，读取一条指令并执行。<br>也可以这样表述:8086机中，任意时刻，CPU将CS:IP 指向的内容当作指令执行图2.10展示了8086CPU 读取、执行指令的工作原理（图中只包括了和所要说明的问题<br>密切相关的部件，图中数字都为十六进制)。（没写完，未完待续）</p><p><strong>&#x3D;&#x3D;8086CPU 的工作过程可以简要描述如下&#x3D;&#x3D;</strong><br>&#x3D;&#x3D;<strong>1.从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>2.IP&#x3D;IP+所读取指令的长度，从而指向下一条指令;</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>3.执行指令。转到步骤(1)，重复这个过程。</strong>&#x3D;&#x3D;<br>在 8086CPU加电启动或复位后(即 CPU 刚开始工作时)CS 和IP被设置为CS&#x3D;FFFFH，IP&#x3D;0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFF0H 单元中读取指执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p><h4 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="&#x3D;&#x3D;修改CS、IP的指令&#x3D;&#x3D;"></a>&#x3D;&#x3D;修改CS、IP的指令&#x3D;&#x3D;</h4><p>mov 指令&#x3D;&#x3D;<strong>不能</strong>&#x3D;&#x3D;用于设置 CS、IP 的值</p><p>&#x3D;&#x3D;<strong>jmp 指令</strong>&#x3D;&#x3D;<strong>可以修改CS、IP 的指令</strong></p><p><strong>&#x3D;&#x3D;jmp语法：“jmp 段地址:偏地址”&#x3D;&#x3D;</strong>jmp 2AE3:3，执行后:CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H 处读取指令</p><p>​<strong>&#x3D;&#x3D;jmp ax，在含义上好似:mov IP,ax&#x3D;&#x3D;</strong></p><h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>前面讲过，对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N(N≤64KB)的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，我们可以认为，<strong>这段内存是用来存放代码的，从而定义了一个代码段</strong></p><h4 id="查看cpu和内存，用机器指令和汇编指令编程（dosbox）"><a href="#查看cpu和内存，用机器指令和汇编指令编程（dosbox）" class="headerlink" title="&#x3D;&#x3D;查看cpu和内存，用机器指令和汇编指令编程（dosbox）&#x3D;&#x3D;"></a>&#x3D;&#x3D;查看cpu和内存，用机器指令和汇编指令编程（dosbox）&#x3D;&#x3D;</h4><p>&#x3D;&#x3D;R命令:查看、修改CPU中寄存器的内容&#x3D;&#x3D;<br>&#x3D;&#x3D;D命令:查看内存中的内容&#x3D;&#x3D;<br>&#x3D;&#x3D;E命令:修改内存中的内容(可以写入数据、指令，在内存中，它们实际上没有区别)&#x3D;&#x3D;</p><p>&#x3D;&#x3D;U命令:将内存中的内容解释为机器指令和对应的汇编指令&#x3D;&#x3D;</p><p>&#x3D;&#x3D;T命令:执行CSIP指向的内存单元处的指令&#x3D;&#x3D;</p><p>&#x3D;&#x3D;A命令:以汇编指令的形式向内存中写入指令&#x3D;&#x3D;</p><h2 id="第三章-寄存器-内存访问"><a href="#第三章-寄存器-内存访问" class="headerlink" title="第三章 寄存器(内存访问)"></a>第三章 寄存器(内存访问)</h2><h4 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h4><p><strong>字单元</strong>：即存放一个字型数据**(16 位)<strong>的内存单元，</strong>由两个地址连续的内存单元组成<strong>。</strong>高地址内存单元<strong>中</strong>存放<strong>字型数据的</strong>高位字节<strong>，</strong>低地址内存单元<strong>中</strong>存放<strong>字型数据的</strong>低位字节**。</p><h4 id="DS-和-address"><a href="#DS-和-address" class="headerlink" title="DS 和[address]"></a>DS 和[address]</h4><p><strong>DS 寄存器</strong>，通常用来存放要访问数据的<strong>段地址</strong>。</p><figure class="highlight plaintext"><figcaption><span>Language</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx，1000H</span><br><span class="line">mov ds,bx </span><br><span class="line">mov al,[0]//[0]表示内存单元的偏移地址</span><br></pre></td></tr></table></figure><p>上面的3条指令将10000H(1000:)中的数据读到al中</p><p><strong>8086CPU</strong> &#x3D;&#x3D;不支持&#x3D;&#x3D;将数据直接送入<strong>段寄存器</strong>的操作，<strong>ds 是一个段寄存器</strong>，所以mov ds，1000H这条指是<strong>非法</strong>的。<strong>只好用一个寄存器来进行中转</strong></p><h4 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h4><p>8086CPU是16 位结构，有 16 根数据线，所以，可以一次性传送 16 位的数据，也就是说可以一次性传送一个字。只要在 mov 指令中给出 16 位的存器就可以进行 16 位数据的传送了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,11316//2c34H</span><br><span class="line">mov [0],ax</span><br><span class="line">mov bx，[0]</span><br><span class="line">sub bx，[2]</span><br><span class="line">mov [2],bx</span><br></pre></td></tr></table></figure><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231128190417961.png" alt="image-20231128190417961"></p><h4 id="mov、add、sub-指令"><a href="#mov、add、sub-指令" class="headerlink" title="&#x3D;&#x3D;mov、add、sub 指令&#x3D;&#x3D;"></a>&#x3D;&#x3D;mov、add、sub 指令&#x3D;&#x3D;</h4><p>前面我们用到了mov、add、sub 指令，它们都带有两个操作对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8;mov 寄存器，数据</span><br><span class="line">mov ax,bx;mov 寄存器，寄存器</span><br><span class="line">mov ax,[0];mov 寄存器，内存单元</span><br><span class="line">mov [0],ax;mov 内存单元，寄存器</span><br><span class="line">mov ds,ax;mov 段寄存器，寄存器</span><br><span class="line">mov ax,ds;mov 寄存器，段寄存器</span><br><span class="line">mov [0],cs;mov 内存单元，段寄存器</span><br><span class="line">mov cs,[0];mov 段寄存器，内存单元</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add ax,8;add 寄存器，数据</span><br><span class="line">add ax,bx;add 寄存器，寄存器</span><br><span class="line">add ax,[0];add 寄存器，内存单元</span><br><span class="line">add [O],ax;add 内存单元，寄存器</span><br><span class="line">sub ax,9;sub 寄存器，数据</span><br><span class="line">sub ax,bx;sub 寄存器，寄存器</span><br><span class="line">sub ax,[0];sub 寄存器，内存单元</span><br><span class="line">sub [O],ax;sub 内存导昂版臂元，寄存器</span><br></pre></td></tr></table></figure><h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。<strong>我们可以将一组长度为 N(N&lt;64KB)、地址连续、起始地址为 16的倍数的内存单元当作专门存储数据的内存空间</strong>，从而定义了一个数据段。</p><h4 id="栈"><a href="#栈" class="headerlink" title="&#x3D;&#x3D;栈&#x3D;&#x3D;"></a>&#x3D;&#x3D;栈&#x3D;&#x3D;</h4><p>**&#x3D;&#x3D;栈&#x3D;&#x3D;<strong>是一种具有特殊的访问方式的存储空间。它的特殊性就在于，</strong>&#x3D;&#x3D;最后进入&#x3D;&#x3D;<strong>这个空间的数据，</strong>&#x3D;&#x3D;最先出去&#x3D;&#x3D;**。</p><h4 id="CPU-提供的栈机制"><a href="#CPU-提供的栈机制" class="headerlink" title="&#x3D;&#x3D;CPU 提供的栈机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;CPU 提供的栈机制&#x3D;&#x3D;</h4><p><strong>&#x3D;&#x3D;PUSH&#x3D;&#x3D;(入栈)</strong> push ax 表示将<strong>寄存器 ax 中的数据送入栈中</strong>，</p><p><strong>&#x3D;&#x3D;POP&#x3D;&#x3D;(出栈)</strong>pop ax 表示<strong>从顶取出数据送入 ax</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266H</span><br><span class="line">push bx</span><br><span class="line">mov Cx,1122H</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231129193859165.png" alt="image-20231129193859165"></p><p><strong>&#x3D;&#x3D;段寄存器 SS&#x3D;&#x3D;<strong>：栈顶的</strong>段地址</strong>存放在SS中，相关规则与ds相同 mov ss,1000h非法</p><p><strong>&#x3D;&#x3D;寄存器 SP&#x3D;&#x3D;<strong>：栈顶的</strong>偏移地址</strong>存放在SP中。</p><p><strong>&#x3D;&#x3D;任意时刻，SS:SP 指向栈顶元素。&#x3D;&#x3D;</strong></p><p><strong>入栈时，栈顶从&#x3D;&#x3D;高地址向低地址&#x3D;方向增长。</strong></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231129200014071.png" alt="image-20231129200014071"></p><h4 id="栈顶超界的问题"><a href="#栈顶超界的问题" class="headerlink" title="栈顶超界的问题"></a>栈顶超界的问题</h4><p>push超界</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231130190041473.png" alt="image-20231130190041473"></p><p>pop超界</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231130190145344.png" alt="image-20231130190145344"></p><p>这也就是说，8086CPU <strong>只知道栈顶在何处</strong>(由SS:SP 指示)，而<strong>不知道我们安排的栈空间有多大</strong>。8086CPU 它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条。<br>我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界，执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。</p><h4 id="push、pop-指令"><a href="#push、pop-指令" class="headerlink" title="push、pop 指令"></a>push、pop 指令</h4><p>push 寄存器将一个寄存器中的数据入栈</p><p>pop 寄存器;出栈 用一个寄存器接收出栈的数据</p><p>push 段寄存器将一个段寄存器中的数据入栈</p><p>pop 段寄存器  出栈，用一个段寄存器接收出栈的数据</p><p>push 内存单元将一个内存字单元处的字入栈（注意:栈操作都是以字为单位）</p><p>pop 内存单元  出栈，用一个内存字单元接收出栈的数据</p><h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。<strong>我们可以将长度为 N(N64KB)的一组地址连续、起始地址为 16的倍数的内存单元，当作栈空间来用，&#x3D;&#x3D;从而定义了一个栈段&#x3D;&#x3D;。</strong>比如，我们将10010H~1001FH这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段，段地址为 1001H，大小为 16 字节。</p><h2 id="第四章：第一个程序"><a href="#第四章：第一个程序" class="headerlink" title="第四章：第一个程序"></a>第四章：第一个程序</h2><h4 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程-"></a>一个源程序从写出到执行的过程-</h4><p><strong>第一步:编写汇编源程序</strong><br>使用文本编辑器(如 Edit、记事本等)，用汇编语言编写汇编源程序。<br>这一步工作的结果是产生了一个存储源程序的文本文件。<br><strong>第二步:对源程序进行编译连接。</strong><br>使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件;再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。<br>可执行文件包含<strong>两部分内容</strong><br>1.<strong>程序</strong>(从源程序中的汇编指令翻译过来的机器码)<strong>和数据</strong>(源程序中定义的<br>2.<strong>相关的描述信息</strong>(比如，程序有多大、要占用多少内存空间等)<br><strong>结果</strong>:产生了一个可在操作系统中运行的可执行文件。<br><strong>第三步:执行可执行文件中的程序</strong></p><p>在操作系统中，执行可执行文件中的程序<br>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化(比如设置 CS:IP 指向第一条要执行的指)，然后由 CPU 执行程序。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231217183643810.png" alt="image-20231217183643810"></p><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment//codesg是段名</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在汇编语言<strong>源程序</strong>中，包含两种指令，一种是&#x3D;&#x3D;<strong>汇编指令</strong>&#x3D;&#x3D;，一种是**&#x3D;&#x3D;伪指令&#x3D;&#x3D;**</p><p>**&#x3D;&#x3D;汇编指令&#x3D;&#x3D;<strong>是有对应的机器码的指令，</strong>可以被编译为机器指令,最终为 &#x3D;&#x3D;CPU 所执行&#x3D;&#x3D;**。</p><p><strong>&#x3D;&#x3D;伪指令&#x3D;&#x3D;<strong>没有对应的机器指令，最终</strong>不被 CPU 所执行</strong>，伪指令<strong>是由&#x3D;&#x3D;编译器&#x3D;&#x3D;来执行的指令</strong>，编译器根据伪指令来进行相关的编译工作。</p><h6 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="&#x3D;&#x3D;1.伪指令&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;1.伪指令&#x3D;&#x3D;</strong></h6><p>1.<strong>segment和ends</strong>是一对<strong>成对</strong>使用的伪指令，这是在写可被编译器编译的汇编程序时<strong>必须要用到的一对伪指令</strong>。segment 和ends的<strong>功能是&#x3D;&#x3D;定义一个段&#x3D;&#x3D;<strong>。</strong>segment 说明一个段开始</strong>，<strong>ends 说明一个段结束</strong>。一个段必须有一个名称来标识，使用格式为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">:</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><p>2.<strong>end</strong> 是一个<strong>汇编程序的&#x3D;&#x3D;结束标记&#x3D;&#x3D;<strong>，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。所以，在我们写程序的时候，</strong>如果程序写完了，要在结尾处加上伪指令end</strong>。<strong>否则，编译器在编译程序时，无法知道程序在何处结束。</strong><br>&#x3D;&#x3D;<strong>注意，不要搞混了end和ends</strong>&#x3D;&#x3D;，<strong>ends 是和segment 成对使用的</strong>，<strong>标记一个段的结束ends的含义可理解为“end segment”</strong>。我们这里讲的<strong>end 的作用是标记整个程序的结束。</strong></p><p>3.assume<br>这条伪指令的含义为<strong>“假设”</strong>。<strong>它假设某一段寄存器和程序中的某一个用segment…ends 定义的段相关联</strong>。<strong>通过 assume 说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系</strong>。assume 并不是一条非要深入理解不可的伪指令，以后我们编程时，记着<strong>用 assume 将有特定用途的段和相关的段寄存器关联起来即可。</strong><br>比如，在程序4.1中，我们用 codesg segment … codesg ends 定义了一个名为 <strong>codseg的段</strong>，在<strong>这个段中存放代码</strong>，所以<strong>这个段是一个代码段</strong>。在程序的开头，<strong>用 &#x3D;&#x3D;assume cs:codesg&#x3D;&#x3D;将用作代码段的段 &#x3D;&#x3D;codesg 和CPU中的段存器cs 联系起来&#x3D;&#x3D;。</strong></p><h6 id="2-源代码中的程序"><a href="#2-源代码中的程序" class="headerlink" title="&#x3D;&#x3D;2.源代码中的程序&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;2.源代码中的程序&#x3D;&#x3D;</strong></h6><p><strong>这里所说的程序就是指源程序中最终由计算机执行、处理的指令或数据。</strong><br><strong>&#x3D;&#x3D;注意&#x3D;&#x3D;<strong>，以后可以将</strong>源程序文件中的&#x3D;&#x3D;所有内容称为源程序&#x3D;&#x3D;<strong>，</strong>将源程序中&#x3D;&#x3D;最终由计算机执行、处理的指令或数据，称为程序&#x3D;&#x3D;<strong>。程序</strong>最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。</strong></p><h6 id="3-标号"><a href="#3-标号" class="headerlink" title="&#x3D;&#x3D;3.标号&#x3D;&#x3D;"></a><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231217192918964.png" alt="image-20231217192918964">&#x3D;&#x3D;<strong>3.标号</strong>&#x3D;&#x3D;</h6><p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，<strong>比如“codesg’个标号指代了一个地址</strong>。<strong>比如 codesg 在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</strong></p><h6 id="4-程序的结构"><a href="#4-程序的结构" class="headerlink" title="&#x3D;&#x3D;4.程序的结构&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;4.程序的结构&#x3D;&#x3D;</strong></h6><p>我们现在讨论一下汇编程序的结构。在前3章中，我们都是通过直接在 Debug 中写入汇编指令来写汇编程序，对于十分简短的程序这样做的确方便。可对于大一些的程序，就不能如此了。<strong>我们需要写出能让编译器进行编译的源程序，这样的源程序应该具备起码的结构。</strong><br>源程序是由一些段构成的。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。我们现在来一步步地完成一个小程序，从这个过程中体会一下汇编程序中的基本要素和汇编程序的简单框架。</p><p>任务:编程运算23。源程序应该怎样来写呢?<br>(1)我们要定义一个段，名称为 abc。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">:</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><p>(2) 在这个段中写入汇编指令，来实现我们的任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><p>(3)然后，要指出程序在何处结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>(4) abc 被当作代码段来用，所以，应该将 abc 和 cs 联系起来。(当然，对于这个程序，也不是非这样做不可。)<strong>&#x3D;&#x3D;&#x2F;&#x2F;4.2&#x3D;&#x3D;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"> mov ax,2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h6 id="5-程序返回"><a href="#5-程序返回" class="headerlink" title="&#x3D;&#x3D;5.程序返回&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;5.程序返回&#x3D;&#x3D;</strong></h6><p>我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么，它怎样得到运行呢?<br>下面，我们在 DOS(一个单任务操作系统)的基础上，简单地讨论一下这个问题<br>一个程序 P2在可执行文件中，则必须有一个正在运行的程序 P1，将 P2从可执行文件中加载入内存后，将CPU 的控制权交给 P2，P2才能得以运行。P2开始运行后，P1暂停运行。<br>而当P2 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P1，此后P1继续运行。<br>现在，我们知道，一个程序结束后，将 CPU的控制权交还给使它得以运行的程序，我们称这个过程为:程序返回。那么，如何返回呢?应该在程序的末尾添加返回的程序段。<br>我们回过头来，看一下程序 4.1 中的两条指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax，4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>这两条指令所实现的功能就是程序返回<br>在目前阶段，我们不必去理解 int 21H 指的含义，和为什么要在这条指令的前面加上指令mov ax,4c00H。我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231217200812396.png" alt="image-20231217200812396"></p><h6 id="6-语法错误和逻辑错误"><a href="#6-语法错误和逻辑错误" class="headerlink" title="&#x3D;&#x3D;6.语法错误和逻辑错误&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;6.语法错误和逻辑错误&#x3D;&#x3D;</strong></h6><p>可见，程序 4.2在运行时会引发一些问题，因为程序没有返回。当然，这个错误在编译的时候是不能表现出来的，也就是说，程序 4.2 对于编译器来说是正确的程序。<br>般说来，程序在编译时被编译器发现的错误是语法错误，比如将程序 4.2 写成如下这样就会发生语法错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add aX,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>显然，程序中有编译器不能识别的aume，而且编译器在编译的过程中也无法知道abc段到何处结束。<br>在源程序编译后，在运行时发生的错误是逻辑错误。语法错误容易发现，也容易解决。而逻辑错误通常不容易被发现。不过，程序 4.2 中的错误却显而易见，我们将它改正过来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"></span><br><span class="line"> mov ax,2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line"> </span><br><span class="line"> mov ax,4c00H</span><br><span class="line"> int 21H</span><br><span class="line"> </span><br><span class="line">ac ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="编辑源程序"><a href="#编辑源程序" class="headerlink" title="编辑源程序"></a>编辑源程序</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231218164126311.png" alt="image-20231218164126311"></p><h4 id="编译"><a href="#编译" class="headerlink" title="&#x3D;&#x3D;编译&#x3D;&#x3D;"></a>&#x3D;&#x3D;编译&#x3D;&#x3D;</h4><p>1.dosbox设置虚拟c盘</p><p>2.输入C:\masm</p><p>3.如果已经将d:&#x2F;asm&#x2F;MASM设置为虚拟c盘，要运行其中的.ASM在虚拟化c盘的目录下，我们需要将那个文件夹视为c盘，输入c:1.asm</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227172759096.png" alt="image-20231227172759096"></p><p>4.obj（目标文件）文件的生成</p><p>不输入默认在1.asm的所在文件夹内生成1.obj</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173105489.png" alt="image-20231227173105489"></p><p>5.列表文件的生成</p><p>不输入输出地址即为不生成</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173239069.png" alt="image-20231227173239069"></p><p>6.交叉引用文件的生成</p><p>不输入输出地址即为不生成</p><p>7.编译结束</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173436707.png" alt="image-20231227173436707"></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>1.2.步骤与上同理</p><p>3.输入link.exe</p><p>4.如果是obj文件输入文件名即可，非obj文件需要带上文件后缀</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227174601366.png" alt="image-20231227174601366"></p><p>5.因为已经确定了目标文件名为 1.bj，则程序默认要输出的可执行文件名为1.EXE，所以可以不必再另行指定文件名。直接按 Enter 键，编译程序将在当前的目录下，生成1.EXE文件。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227174757293.png" alt="image-20231227174757293"></p><p>6.忽略映像文件生成，直接【enter】</p><p>7.库文件连接，忽略直接【enter】</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227175112103.png" alt="image-20231227175112103"></p><p>警告为：没有栈段（后文再叙）</p><p>连接的作用：</p><p>(1)当<strong>源程序很大</strong>时，可以将它<strong>分为多个源程序文件</strong>来编译，<strong>每个源程序编译成为目标文件后</strong>，<strong>再用连接程序将它们连接到一起，生成一个可执行文件</strong>;<br>(2)&#x3D;&#x3D;<strong>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件;</strong>&#x3D;&#x3D;<br>(3)一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，<strong>在&#x3D;&#x3D;只有一个源程序文件&#x3D;&#x3D;，而&#x3D;&#x3D;又不需要调用某个库中的子程序&#x3D;&#x3D;的情况下，也&#x3D;&#x3D;必须用&#x3D;&#x3D;连接程序对目标文件进行处理，生成可执行文件。</strong><br>注意，对于连接的过程，<strong>可执行文件是我们要得到的最终结果。</strong></p><h4 id="以简化的方式进行编译和连接"><a href="#以简化的方式进行编译和连接" class="headerlink" title="以简化的方式进行编译和连接"></a>以简化的方式进行编译和连接</h4><p>简化编译<strong>C:\&gt;masm c:\1;</strong></p><p>简化连接<strong>C:\&gt;link 1;</strong></p><p><strong>&#x3D;&#x3D;自动忽略中间文件的生成&#x3D;&#x3D;</strong></p><h4 id="1-exe的执行"><a href="#1-exe的执行" class="headerlink" title="1.exe的执行"></a>1.exe的执行</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227183159432.png" alt="image-20231227183159432"></p><h4 id="程序执行过程的追踪"><a href="#程序执行过程的追踪" class="headerlink" title="程序执行过程的追踪"></a>程序执行过程的追踪</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227193505217.png" alt="image-20231227193505217"></p><h2 id="第五章-BX-和-loop-指令"><a href="#第五章-BX-和-loop-指令" class="headerlink" title="第五章[BX]和 loop 指令"></a>第五章[BX]和 loop 指令</h2><p><strong>1.[bx]和内存单元的描述</strong></p><p>要完整地描述一个内存单元，需要<strong>两种信息</strong>:&#x3D;&#x3D;<strong>1内存单元的地址</strong>&#x3D;&#x3D;;&#x3D;&#x3D;<strong>2内存单元的长度</strong>&#x3D;&#x3D;</p><p>mov ax，[bx]<br>&#x3D;&#x3D;<strong>将一个内存单元的内容送入 ax</strong>&#x3D;&#x3D;<strong>，这个内存单元的长度为 2 字节(字单元)，存放一个字，</strong>&#x3D;&#x3D;<strong>偏移地址在 bx中</strong>&#x3D;&#x3D;，&#x3D;&#x3D;段地址在 ds 中&#x3D;&#x3D;。</p><p><strong>2.我们定的描述性的符号:“()”</strong></p><p>(ax)表示ax中的内容、(al)表示al中的内容</p><p>(20000H)表示内存 20000H 单元的内容（()中的内存单元的地址为物理地址）;</p><p>((ds)*16+(bx))表示:<strong>ds 中的内容为ADR1</strong>，<strong>bx中的内容为 ADR2</strong>，<strong>内存ADR1*16+ADR2单元的内容</strong></p><p>也可以理解为:<strong>ds 中的 ADR1 作为段地址</strong>，<strong>bx 中的 ADR2作为偏移地址</strong>，<strong>内存ADR1:ADR2单元的内容。</strong></p><p>注意，“( )”中的元素可以有 <strong>3 种类型</strong>:&#x3D;&#x3D;<strong>1.寄存器名</strong>&#x3D;&#x3D;;&#x3D;&#x3D;<strong>2.段寄存器名</strong>&#x3D;&#x3D;:&#x3D;&#x3D;<strong>3.内存单元的物理地址</strong>&#x3D;&#x3D;(一个 20位数据)。比如:<br>**(ax)、(ds)、(al)、 (cx)、(20000H)、((ds)*16+(bx))<strong>等是</strong>正确**的用法;</p><p><strong>(2000:0)、((ds):1000H)<strong>等是</strong>不正确</strong>的用法。</p><p>我们看一下(X)的应用，比如，<br>(1)ax中的内容为0010H，可以这样来描述：(ax)&#x3D;0010H;</p><p>(2) 2000:1000 处的内容为 0010H，可以这样来描述：(21000H)&#x3D;0010H;</p><p>(3)对于mov ax,[2]的功能，可以这样来描述：(ax)&#x3D;((ds)<em>16+2);</em></p><p>(4)对于 mov  [2],ax的功能，可以这样来描述：((ds)*16+2)&#x3D;(ax);</p><p>(5)对于add ax,2的功能，可以这样来描述：(ax)&#x3D;(ax)+2;</p><p>(6)对于add ax,bx的功能，可以这样来描述：(ax)&#x3D;(ax)+(bx);</p><p>(7)对于 push ax的功能，可以这样来描述：(sp)&#x3D;(sp)-2((ss)*16+(sp))&#x3D;(ax)</p><p>(8)对于 pop ax的功能，可以这样来描述：(ax)&#x3D;((ss)*16+(sp))(sp)&#x3D;(sp)+2</p><p><strong>“(X)”</strong>所表示的数据有两种类型:<strong>1.字节</strong>;<strong>2.字</strong>。</p><p>(al)、(bI)、(cl)等得到的数据为字节型;</p><p>(ds)、(ax)、(bx)等得到的数据为字型;</p><p>(al)&#x3D;(20000H)，则(20000H)得到的数据为字节型;</p><p>(ax)&#x3D;(20000H)，则(20000H)得到的数据为字型。</p><p><strong>3.约定符号idata 表示常量</strong></p><h4 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1[BX]"></a>5.1[BX]</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br></pre></td></tr></table></figure><p>含义：bx中的内容加1。</p><h4 id="5-2loop指令"><a href="#5-2loop指令" class="headerlink" title="5.2loop指令"></a>5.2loop指令</h4><p>格式</p><p>(1)在 &#x3D;&#x3D;<strong>cx 中存放循环次数</strong>&#x3D;&#x3D;</p><p>(2)<strong>&#x3D;&#x3D;loop  指令中的标号所标识地址要在前面&#x3D;&#x3D;</strong></p><p>(3)<strong>&#x3D;&#x3D;要循环执行的程序段，要写在标号和 loop 指令的中间&#x3D;&#x3D;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax，2</span><br><span class="line"></span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,axs:</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>(1) 标号**&#x3D;&#x3D;s&#x3D;&#x3D;**<br>    在汇编语言中，标号代表一个地址，程序中有一个标号 <strong>&#x3D;&#x3D;s&#x3D;&#x3D;<strong>。它实际上标识了一个地址，这个地址处有一条指令:</strong>&#x3D;&#x3D;add ax,ax&#x3D;&#x3D;<strong>。<br>(2) loop s<br>CPU执行 loops的时候，要进行</strong>两步操作</strong>:<br>&#x3D;&#x3D;<strong>1.(cx)&#x3D;(cx)-1;</strong>&#x3D;&#x3D;<br><strong>&#x3D;&#x3D;2.判断 cx中的值，不为 0则转至标号s所的地址处执行(这里的指是 add ax,ax)如果为零则执行下一条指令(下一条指令是mov ax,4c00h)。&#x3D;&#x3D;</strong><br>(3) 以下3条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cx，11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>执行 <strong>loop s</strong> 时，<strong>首先要将(cx)减 1，然后若(cx)不为0，则向前转至 s 处执行add ax,ax</strong>。所以，<strong>可以利用cx来控制add ax,ax 的执行次数。</strong></p><h4 id="5-3-在Debug-中跟踪用-loop-指令实现的循环程序"><a href="#5-3-在Debug-中跟踪用-loop-指令实现的循环程序" class="headerlink" title="5.3 在Debug 中跟踪用 loop 指令实现的循环程序"></a>5.3 在Debug 中跟踪用 loop 指令实现的循环程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffh//在汇编源程序中，数据不能以字母开头</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx，6</span><br><span class="line"></span><br><span class="line">mov al，[bx]</span><br><span class="line">mov ah,0</span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx，3</span><br><span class="line">s: add dx,ax//第12行</span><br><span class="line">loops</span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>循环程序段从CS:0012开始，我们不想再一步步地跟踪CS:0012前面的指令，从 CS:0012 处开始跟踪。**&#x3D;&#x3D;可以这样来使用g 命令，“g 0012”&#x3D;&#x3D;**</p><p>当然，也可以用g命令来达到目的，<strong>可以用“g 0016”直接执行到 CS:0016 处</strong></p><p>我们希望将循环一次执行完。可以使用 p 命令来达到目的。再次遇到loop 指令时，<strong>使用p命令来执行</strong>，Debug 就会自动重复执行循环中的指令，直到(cx)&#x3D;0为止。</p><h4 id="5-4-Debug-和汇编编译器-masm-对指令的不同处理"><a href="#5-4-Debug-和汇编编译器-masm-对指令的不同处理" class="headerlink" title="5.4 Debug 和汇编编译器 masm 对指令的不同处理"></a>5.4 Debug 和汇编编译器 masm 对指令的不同处理</h4><p>“mov al,[0]”，含义:(al)&#x3D;0，将常量0送入al中(与mov al,0含义相同)</p><p>“mov al,ds:[0]”，含义:(al)&#x3D;((ds)*16+0)，将内存单元中的数据送入al中;</p><p>“mov al,[bx]”，含义:(al)&#x3D;((ds)*16+(bx))，将内存单元中的数据送入al中</p><p>“mov al,ds:[bx]”，含义:与“mov al,[bx]”相同。</p><p>从上面的比较中可以看出:<br>(1)在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用“[…]”来表示内存单元，如果在“[]”里用一个常量 idata 直接给出内存单元的偏移地址，就要<strong>在“[]”的前面</strong>显式地<strong>给出段地址所在的段寄存器。</strong>比如<br><strong>mov al,ds:[0]</strong><br>如果<strong>没有在“[]”的前面</strong>显式地<strong>给出段地址所在的段寄存器</strong>，比如<br><strong>mov al,[0]</strong><br>那么，<strong>编译器masm将把指令中的“[idata]”解释为“idata”</strong><br>(2) 如果在“[]”里用寄存器，<strong>比如 bx，间接给出内存单元的偏移地址</strong>，<strong>则段地址默认在 ds 中</strong>。当然，<strong>也可以显式地给出段地址所在的段寄存器。</strong></p><h4 id="5-5-loop-和-bx-的联合应用"><a href="#5-5-loop-和-bx-的联合应用" class="headerlink" title="5.5 loop 和[bx]的联合应用"></a>5.5 loop 和[bx]的联合应用</h4><p>计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,Offffh</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx，0;初始化ds:bx指向 ffff:0</span><br><span class="line"></span><br><span class="line">mov dx，0;初始化累加寄存器dx，(dx)=0</span><br><span class="line">mov cx，12;初始化循环计数寄存器 cx，(cx)=12</span><br><span class="line"></span><br><span class="line">s:mov al，[bx]</span><br><span class="line">mov ah，0</span><br><span class="line">add dx,ax ;间接向 dx中加上((ds)*16+(bx))单元的数值</span><br><span class="line">inc bx ;ds:bx 指向下一个单元</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>8位字节型数累加结果存入16位字型dx中</p><p>1.将8位字节型数据存入中间暂存16位字型ax中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al，[bx]</span><br><span class="line">mov ah，0</span><br></pre></td></tr></table></figure><p>2.将16位ax中的数据转入到dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add dx,ax</span><br></pre></td></tr></table></figure><p>3.设计循环，可把bx（bx已经初始化为0）当作为中间变量，在循环的末尾加上一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br></pre></td></tr></table></figure><h4 id="5-6段前缀"><a href="#5-6段前缀" class="headerlink" title="5.6段前缀"></a>5.6段前缀</h4><p>用于显式地指明内存单元的段地址的“ds:” “cs:” “ss:” “es:”在汇编语言中称为段前缀</p><p>例如<strong>mov ax,ds:[bx]</strong> 中的ds:</p><h4 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h4><p>(1)我们需要直接向一段内存中写入内容:</p><p>(2)这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误;</p><p>(3) DOS 方式下，一般情况，0:20~0:2ff 空间中没有系统或其他程序的数据或代码;(可以先用debug检查一下)</p><p>(4)以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff这空间</p><h4 id="5-8段前缀的使用"><a href="#5-8段前缀的使用" class="headerlink" title="5.8段前缀的使用"></a>5.8段前缀的使用</h4><p>将内存ffff:0<del>ffff:b单元中的数据复制到0:200</del>0:20b 单元中</p><p>0:200<del>0:20b→0020:0</del>0020:b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffh</span><br><span class="line">mov ds,ax;用 ds 存放源始空间ffff:0~ffff:b 的段地址。</span><br><span class="line"></span><br><span class="line">mov ax,0020h</span><br><span class="line">mov es,ax;用es 存放标空间 0020:00020:b 的段地址</span><br><span class="line"></span><br><span class="line">mov cx,12</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">s:mov dl,[bx]</span><br><span class="line">mov es:[bx],dl;显式地用段前缀“es:”给出单元的段地址，这样就不必在循环中重复设置 ds。</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="第6章包含多个段的程序"><a href="#第6章包含多个段的程序" class="headerlink" title="第6章包含多个段的程序"></a>第6章包含多个段的程序</h2><h4 id="6-1在代码段中使用数据"><a href="#6-1在代码段中使用数据" class="headerlink" title="6.1在代码段中使用数据"></a>6.1在代码段中使用数据</h4><p>我们若要 CPU从何处开始执行程序，<strong>只要在源程序中用“end 标号”指明就可以了。</strong><br>有了这种方法，就可以这样来安排程序的框架:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">数据</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">start:</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">代码</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>考虑这样一个问题，编程计算以下8个数据的和，结果存在ax寄存器中:</p><p>0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,Odefh,0fedh,0cbah,0987h</span><br><span class="line">start:mov bx,0</span><br><span class="line">mov ax，0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>​程序中的“dw”的含义是<strong>定义字型数据</strong>。**dw 即“defineword’’**在这里，使用 dw 定义了 8 个字型数据(数据之间以号分隔)，它们所占的内存空间的大小为16个字节。</p><h4 id="6-2在代码段中使用栈"><a href="#6-2在代码段中使用栈" class="headerlink" title="6.2在代码段中使用栈"></a>6.2在代码段中使用栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,Ofedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0.0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">;用dw定义16个字型数据，在程序加载后，将取得16个字的</span><br><span class="line">;内存空间，存放这16个数据。在后面的程序中将这段</span><br><span class="line">;空间当作栈来使用</span><br><span class="line"></span><br><span class="line">start:mov aX,CS</span><br><span class="line">mov ss，ax</span><br><span class="line">mov sp，30h;将设置栈顶ss:sp指cs:30</span><br><span class="line"></span><br><span class="line">mov bx，0</span><br><span class="line">mov cx，8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;以上将代码段0~15单元中的8个字型数据</span><br><span class="line">;依次入栈</span><br><span class="line"></span><br><span class="line">mov cX，8</span><br><span class="line">mov bx，0</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx，2</span><br><span class="line">loop s0;以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序的入口在start处</span><br></pre></td></tr></table></figure><p>监测点6.1</p><p>cs是代码段寄存器，所以改写程序中的数据就是改写cs:ip的数据所以要mov cs:[bx],ax</p><h4 id="6-3将数据、代码、栈放入不同的段"><a href="#6-3将数据、代码、栈放入不同的段" class="headerlink" title="6.3将数据、代码、栈放入不同的段"></a>6.3将数据、代码、栈放入不同的段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0123h，0456h,0789h,0abch,Odefh,Ofedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h;设置栈顶ss:sp指向 stack:20</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax;ds指向data段</span><br><span class="line"></span><br><span class="line">mov bx,0;ds:bx指向 data段中的第一个单元</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx，0</span><br><span class="line"></span><br><span class="line">mov cx，8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;以上依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>(1)定义多个段的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume 寄存器名:[name]</span><br><span class="line">[name] segment</span><br><span class="line">数据内容</span><br><span class="line">[name] ends</span><br></pre></td></tr></table></figure><p>(2)对段地址的引用</p><p>要把data:6送入bx中</p><p><strong>要用</strong>下面代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure><p>我们<strong>不能</strong>用下面的指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ds,data</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure><p>(3)“代码段”数据段”“栈段”完全是我们的安排</p><p>CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对 CS:IP、SS:SP、DS 等寄存器的设置来决定的。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/transpancy.css"/>
      <url>/css/transpancy.css</url>
      
        <content type="html"><![CDATA[/* 文章页背景 */.layout_post>#post {    /* 以下代表透明度为0.7 可以自行修改*/    background: rgba(255, 255, 255, .7);}/* 所有页面背景 */#aside_content .card-widget,#recent-posts>.recent-post-item,.layout_page>div:first-child:not(.recent-posts),.layout_post>#page,.layout_post>#post,.read-mode .layout_post>#post {    /* 以下代表透明度为0.7 */    background: rgba(255, 255, 255, .7);}/*侧边卡片的透明度 */:root {    --card-bg: rgba(255, 255, 255, .7);}/* 页脚透明 */#footer {    /* 以下代表透明度为0.7 */    background: rgba(255, 255, 255, .0);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>navigate</title>
      <link href="/navigate/index.html"/>
      <url>/navigate/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
