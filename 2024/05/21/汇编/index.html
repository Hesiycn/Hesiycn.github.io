<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>汇编语言 | 哥布林的❤秘密❤洞穴</title><meta name="author" content="来不及了🥵就你了吧❤~"><meta name="copyright" content="来不及了🥵就你了吧❤~"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="汇编语言第一章	基础知识汇编语言的组成：&#x3D;&#x3D;1.汇编指令（核心）&#x3D;&#x3D;：机器码的助记符，有对应的机器码。 2.伪指令：没有对应的机器码，由编译器执行，计算机并不执行。 3.其他符号：如+、-、*、&#x2F;等，由编译器 识别，没有对应的机器码。。 储存单元：&#x3D;&#x3D;n位的cpu，一个字就有（n&#x2F;8）个字节&#x3D;&#x3D;（这">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言">
<meta property="og:url" content="https://hesiy-cnpwn.xyz/2024/05/21/%E6%B1%87%E7%BC%96/index.html">
<meta property="og:site_name" content="哥布林的❤秘密❤洞穴">
<meta property="og:description" content="汇编语言第一章	基础知识汇编语言的组成：&#x3D;&#x3D;1.汇编指令（核心）&#x3D;&#x3D;：机器码的助记符，有对应的机器码。 2.伪指令：没有对应的机器码，由编译器执行，计算机并不执行。 3.其他符号：如+、-、*、&#x2F;等，由编译器 识别，没有对应的机器码。。 储存单元：&#x3D;&#x3D;n位的cpu，一个字就有（n&#x2F;8）个字节&#x3D;&#x3D;（这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://patchwiki.biligame.com/images/blhx/thumb/7/7f/8usj4ct58dnkg6xngs2x0b9f94m3d6e.jpg/350px-%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%E6%8D%A2%E8%A3%85.jpg">
<meta property="article:published_time" content="2024-05-21T08:07:46.755Z">
<meta property="article:modified_time" content="2024-05-21T08:10:47.096Z">
<meta property="article:author" content="来不及了🥵就你了吧❤~">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://patchwiki.biligame.com/images/blhx/thumb/7/7f/8usj4ct58dnkg6xngs2x0b9f94m3d6e.jpg/350px-%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%E6%8D%A2%E8%A3%85.jpg"><link rel="shortcut icon" href="https://patchwiki.biligame.com/images/blhx/thumb/b/ba/ccctp5qxtdb63837kcgpe904zi0216e.jpg/350px-%E9%98%BF%E8%BE%BE%E5%B0%94%E4%BC%AF%E7%89%B9%E4%BA%B2%E7%8E%8B%E6%8D%A2%E8%A3%852.jpg"><link rel="canonical" href="https://hesiy-cnpwn.xyz/2024/05/21/%E6%B1%87%E7%BC%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-21 08:10:47'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://patchwiki.biligame.com/images/blhx/thumb/7/7f/8usj4ct58dnkg6xngs2x0b9f94m3d6e.jpg/350px-%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%E6%8D%A2%E8%A3%85.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://hesiy-md-pic.oss-cn-beijing.aliyuncs.com/images/OIP-C_upscayl_4x_realesrgan-x4plus.png')"><nav id="nav"><span id="blog-info"><a href="/" title="哥布林的❤秘密❤洞穴"><span class="site-name">哥布林的❤秘密❤洞穴</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-21T08:07:46.755Z" title="发表于 2024-05-21 08:07:46">2024-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-21T08:10:47.096Z" title="更新于 2024-05-21 08:10:47">2024-05-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="汇编语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="第一章基础知识"><a href="#第一章基础知识" class="headerlink" title="第一章	基础知识"></a>第一章	基础知识</h2><h4 id="汇编语言的组成："><a href="#汇编语言的组成：" class="headerlink" title="汇编语言的组成："></a>汇编语言的组成：</h4><p>&#x3D;&#x3D;1.汇编指令（核心）&#x3D;&#x3D;：机器码的助记符，有对应的机器码。</p>
<p>2.伪指令：没有对应的机器码，由编译器<em><strong>执行</strong></em>，计算机并不执行。</p>
<p>3.其他符号：如+、-、*、&#x2F;等，由编译器 <em><strong>识别</strong></em>，没有对应的机器码。。</p>
<h4 id="储存单元："><a href="#储存单元：" class="headerlink" title="储存单元："></a>储存单元：</h4><p>&#x3D;&#x3D;n位的cpu，<strong>一个字</strong>就有<strong>（n&#x2F;8）个字节</strong>&#x3D;&#x3D;（这应该是第二章的内容，但是我觉得首先要把单位分清楚就放在这里了）</p>
<p>&#x3D;&#x3D;<strong>Byte</strong>（储存单元&#x2F;字节）简写 <strong>B</strong>&#x3D;&#x3D;</p>
<p><strong>1KB&#x3D;1024B	1MB&#x3D;1024KB	1GB&#x3D;1024MB	1TB&#x3D;1024GB</strong></p>
<p><strong>1024 &#x3D; 10^10</strong></p>
<p>计算机最小单位是<strong>bit（比特）</strong>如果一个计算机有<strong>128</strong>个<strong>储存单元</strong>，<strong>编号从0~127</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/05/21/%E6%B1%87%E7%BC%96/Users\admin\Desktop\微信图片_20231119201725.png" alt="微信图片_20231119201725"></p>
<h4 id="cpu对储存器都读写"><a href="#cpu对储存器都读写" class="headerlink" title="cpu对储存器都读写"></a>cpu对储存器都读写</h4><p>CPU 要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面 3类信息的交互。<br><strong>1.存储单元的地址(地址信息);</strong><br><strong>2.器件的选择，读或写的命令(控制信息);</strong><br><strong>3.读或写的数据(数据信息)。</strong></p>
<p>CPU 是通过**&#x3D;&#x3D;总线&#x3D;&#x3D;**将地址、数据和控制信息传到存储器芯片中的</p>
<p>**&#x3D;&#x3D;总线&#x3D;&#x3D;<strong>是计算机中专门连接CPU 和其他芯片的导线。从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3 类，</strong>&#x3D;&#x3D;地址总线&#x3D;&#x3D;<strong>、&#x3D;&#x3D;<strong>控制总线</strong>&#x3D;&#x3D;和</strong>&#x3D;&#x3D;数据总线&#x3D;&#x3D;**。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231120152544401.png" alt="image-20231120152544401"></p>
<p>(1)CPU 通过地址线将地址信息3 发出。</p>
<p>(2)CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</p>
<p>(3)存储器将3号单元中的数据8通过数据线送入CPU。</p>
<h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p>一个CPU有<strong>N根地址线</strong>，则可以说这个 CPU 的<strong>地址总线的&#x3D;&#x3D;宽度&#x3D;&#x3D;为 N</strong>。这样的 CPU最多可以寻找<strong>2的N 次方</strong>个内存单元。<strong>最小数是0，最大数是(2^n)-1</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231120153933375.png" alt="image-20231120153933375"></p>
<p>图1.4展示了一个具有 1根地址线的CPU向内存发出地址信息11时 10根地址线上传送的二进制信息。</p>
<h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>CPU 与内存或其他器件之间的<strong>数据传送</strong>是通过<strong>数据总线</strong>来进行的。<em><em>数据总线的&#x3D;&#x3D;宽度&#x3D;&#x3D;<strong>决定了 <em><strong>CPU</strong></em> 和</strong></em>外界的数据</em><strong><strong>&#x3D;&#x3D;传送速度&#x3D;&#x3D;<strong>。</strong>8</strong> 根数据总线一次可传送<strong>一个</strong> <em><strong>&#x3D;&#x3D;字节&#x3D;&#x3D;</strong></em>(字节是8进制数据)。**16</strong> 根数据总线一次可传送<strong>两个字节</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231120154658074.png" alt="image-20231120154658074"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231120154746520.png" alt="image-20231120154746520"></p>
<h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>CPU 对外部器件的控制是通过<strong>控制总线</strong>来进行的。在这里控制总线是个总称，<strong>控制总线是一些不同控制线的集合</strong>。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，**&#x3D;&#x3D;控制总线的宽度决定了 CPU 对外部器件的控制能力。&#x3D;&#x3D;**<br>前面所讲的内存<strong>读或写</strong>命令是由<strong>几根控制线综合发出</strong>的，其中有一根称为<strong>“读信号输出”</strong>的<strong>控制线</strong>负责<strong>由 CPU 向外传送读信号</strong>，CPU 向该控制线上输出<strong>低电平表示将要读取数据</strong>:有一根称为“<strong>写信号输出”的控制线</strong>则负责<strong>传送写信号</strong>。</p>
<h4 id="内存地址空间-概述"><a href="#内存地址空间-概述" class="headerlink" title="内存地址空间(概述)"></a>内存地址空间(概述)</h4><p>什么是内存地址空间呢?举例来讲，一个 CPU 的地址总线宽度为 10，那么可以寻址1024 个内存单元，**&#x3D;&#x3D;这 1024 个可寻到的内存单元就构成这个CPU的内存地址空间&#x3D;&#x3D;**。</p>
<h4 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h4><p>在每一台 PC 机中，都有一个主板，<strong>主板上有核心器件和一些主要器件</strong>，<strong>这些器件通过总线(地址总线、数据总线、控制总线)相连</strong>。这些器件有 <strong>CPU、存储器、外围芯片组、扩展插槽等</strong>。<strong>扩展插槽上一般插有 RAM内存条和各类接口卡</strong>。</p>
<h4 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h4><p>计算机系统中，所有可用程序控制其工作的设备，必须受到 CPU 的控制。CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。<strong>扩展插槽&#x3D;&#x3D;通过总线&#x3D;&#x3D;和 &#x3D;&#x3D;CPU&#x3D;&#x3D; 相连，所以&#x3D;&#x3D;接卡也通过总线同 CPU&#x3D;&#x3D;相连</strong>。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。*&#x3D;&#x3D;<strong>简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。</strong>&#x3D;&#x3D;*</p>
<p><strong>各类存储器芯片</strong></p>
<p>分为<strong>ROM（只读储存器）</strong>与<strong>RAM（随机储存器）</strong></p>
<p><strong>随机存储器</strong><br>用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM 组成，<strong>装在主板上 RAM 和插在扩展插槽上的RAM。</strong></p>
<p><strong>装有BIOS(BasicInput&#x2F;Output System，基本输入&#x2F;输出系统)的ROM</strong></p>
<p>BIOS 是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。</p>
<p><strong>接口卡上的 RAM</strong><br>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。<strong>最典型的是显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。</strong>换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231121102521329.png" alt="image-20231121102521329"></p>
<h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231121102715622.png" alt="image-20231121102715622"></p>
<p>在图 1.8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，<strong>每个物理存储器在这个逻辑存储器中占有一个地址段，&#x3D;&#x3D;即一段地址空间&#x3D;&#x3D;<strong>。</strong>&#x3D;&#x3D;CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。&#x3D;&#x3D;</strong></p>
<h2 id="第二章寄存器-你猜他为什么会有个“寄”（）"><a href="#第二章寄存器-你猜他为什么会有个“寄”（）" class="headerlink" title="第二章	寄存器	&#x2F;&#x2F;你猜他为什么会有个“寄”（）"></a>第二章	寄存器	&#x2F;&#x2F;你猜他为什么会有个“寄”（）</h2><p>在cpu中<strong>寄存器进行信息储存</strong></p>
<p><strong>不同的 CPU，寄存器的个数、结构是不相同的</strong>。8086CPU 有14 个寄存器，每个寄存器有一个名称。这些寄存器是: AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231121104928194.png" alt="image-20231121104928194"></p>
<p><strong>8086CPU的上一代 CPU 中的寄存器都是 8位的</strong>，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在 8086之上，<strong>8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用:</strong></p>
<p><strong>AX</strong> 可分为<strong>AH</strong>和<strong>AL;</strong><br><strong>BX</strong>可分为<strong>BH</strong>和<strong>BL</strong>;<br><strong>CX</strong>可分为<strong>CH</strong>和<strong>CL</strong>;<br><strong>DX</strong>可分为 <strong>DH</strong>和<strong>DL</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231121105907995.png" alt="image-20231121105907995"></p>
<p>AX的低8位(0位<del>7位)构成了AL寄存器，存器高8位(8位</del>15位)构成了AH寄存器。AH 和AL 寄存器是可以独立使用的 8 位存器。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231121110012138.png" alt="image-20231121110012138"></p>
<h4 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="&#x3D;&#x3D;几条汇编指令&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;几条汇编指令&#x3D;&#x3D;</strong></h4><p><em><strong>mov与add</strong></em></p>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td><strong>将18送入寄存器AX</strong></td>
<td>AX&#x3D;18</td>
</tr>
<tr>
<td>mov ah,78</td>
<td><strong>将78送入寄存器AH</strong></td>
<td>AH&#x3D;78</td>
</tr>
<tr>
<td>add ax,8</td>
<td><strong>将寄存器AX中的数值加上8</strong></td>
<td>AX&#x3D;AX+8</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td><strong>将寄存器BX中的数据送入寄存器AX</strong></td>
<td>AX-BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td><strong>将AX和BX中的数值相加，结果存在AX中</strong></td>
<td>AX-AX+BX</td>
</tr>
</tbody></table>
<p><strong>在进行数据传送或运算时，要注意指令的&#x3D;&#x3D;两个操作对象的位数应当是一致的&#x3D;&#x3D;</strong></p>
<h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>CPU 访问内存单元时，要<strong>给出内存单元的地址</strong>。所有的内存单元构成的存储空间是一个一维的线性空间，<strong>每一个内存单元在这个空间中都有唯一的地址</strong>，我们将这个<strong>唯一的地址</strong>称为<strong>物理地址。</strong><br><strong>CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址</strong>。在 CPU 向地址总线上发出物理地址之前，<strong>必须要在内部先形成这个物理地址</strong>。不同的 CPU 可以有不同的形成物理地址的方式。我们现在讨论 8086CPU 是如何在内部形成内存单元的物理地址的。</p>
<h4 id="16位结构cpu（典型8086）"><a href="#16位结构cpu（典型8086）" class="headerlink" title="16位结构cpu（典型8086）"></a>16位结构cpu（典型8086）</h4><p><strong>概括地讲，16 位结构(<strong>16 位机、字长为 16 位等常见说法，与 16 位结构的含相同)<strong>描述了一个CPU具有下面几方面的结构特性。</strong><br><strong>1.运算器一次最多可以处理 16位的数据</strong><br><strong>2.寄存器的最大宽度为16位;</strong><br><strong>3.寄存器和运算器之间的通路为 16位</strong><br>8086 是 16 位结构的 CPU，</strong>这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。</strong>内存单元的地址在送上地址总线之前，必须在 CPU中处理、传输、暂时存放，<strong>对于 16位 CPU，能一次性处理、传输、暂时存储 16位的地址</strong>。</p>
<h4 id="8086cpu给出物理地址的方法"><a href="#8086cpu给出物理地址的方法" class="headerlink" title="8086cpu给出物理地址的方法"></a><strong>8086cpu给出物理地址的方法</strong></h4><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为 16 位。<br>8086CPU采用一种在内部用两个 16位地址合成的方法来形成一个20位的物理地址8086CPU相关部件的逻辑结构如图2.6所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231121202629121.png" alt="image-20231121202629121"></p>
<p>当8086CPU要读写内存时:<br>1.CPU中的相关部件提供<strong>两个16位的地址</strong>，一个称为<strong>段地址</strong>，另一个称为<strong>偏移地址:</strong></p>
<p>2.<strong>段地址和偏移地址</strong>通过<strong>内部总线</strong>送入一个称为<strong>地址加法器</strong>的部件;</p>
<p>3.<strong>地址加法器将两个16位地址</strong>合成为<strong>一个20位的物理地址;</strong></p>
<p>4**.地址加法器<strong>通过</strong>内部总线<strong>将 <strong>20位物理地址</strong>送入</strong>输入输出控制电路**;</p>
<p>5.<strong>输入输出控制电路</strong>将 <strong>20位物理地址</strong>送上<strong>地址总线</strong>:</p>
<p>6.<strong>20位物理地址被地址总线传送到存储器。</strong></p>
<p>地址加法器采用<strong>物理地址&#x3D;段地址X16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址。例如，8086CPU 要访问地址为 123C8H 的内存单元，此时，地址加法器的工作过程如图 2.7 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231123201756825.png" alt="image-20231123201756825"></p>
<p><strong>&#x3D;&#x3D;一个数据的十六进制形式左移1位，相当于乘以16:一个数据的十进形式左移1位，相当于乘以10;一个X进制的数据左移1位，相当于乘以X。&#x3D;&#x3D;</strong></p>
<h4 id="“段地址X16-偏移地址-物理地址”的本质含义"><a href="#“段地址X16-偏移地址-物理地址”的本质含义" class="headerlink" title="“段地址X16+偏移地址&#x3D;物理地址”的本质含义"></a>“段地址X16+偏移地址&#x3D;物理地址”的本质含义</h4><p><strong>“段地址x16+偏移地址&#x3D;物理地址”</strong>的本质含义是:CPU 在访问内存时，用一个**&#x3D;&#x3D;基础地址&#x3D;&#x3D;(段地址X16)<strong>和一个</strong><u>相对于</u>基础地址的&#x3D;&#x3D;偏移地址&#x3D;&#x3D;<strong>相加，</strong>给出内存单元的物理地址<strong>。<br>更一般地说，8086CPU的这种寻址功能是&#x3D;&#x3D;</strong><u>“基础地址+偏移地址&#x3D;物理地址”</u><strong>&#x3D;&#x3D;（</strong>这就是本质，请牢记它**）寻址模式的一种具体实现方案。8086CPU 中，段地址x16 可看作是基础地址。</p>
<h4 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h4><p>其实，内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用“基础地址(段地址X16)+偏移地址&#x3D;物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。</p>
<p>以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址X16 定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元。<strong>有两点需要注意:&#x3D;&#x3D;段地址X16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数&#x3D;&#x3D;: &#x3D;&#x3D;偏移地址为16位，16位地址的寻址能力为 64KB，所以一个段的长度最大为 64KB&#x3D;&#x3D;</strong></p>
<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>什么部件提供段地址。段地址在 8086CPU 的段寄存器中存放。8086CPU 有 <strong>4 个段存器:CS、DS、SS、ES</strong>。当8086CPU 要访问内存时由这4个段寄存器提供内存单元的段地址。</p>
<h4 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h4><p><strong>CS和IP</strong>是8086CPU中两个最关键的存器，它们指示了CPU 当前要读取指令的地址。<strong>CS 为代码段寄存器，IP为指令指针寄存器</strong>。<br>在8086PC 机中，任意时刻，<strong>设 CS 中的内容为M</strong>，<strong>IP 中的内容为N</strong>，8086CPU 将<strong>从内存Mx16+N单元开始</strong>，读取一条指令并执行。<br>也可以这样表述:8086机中，任意时刻，CPU将CS:IP 指向的内容当作指令执行图2.10展示了8086CPU 读取、执行指令的工作原理（图中只包括了和所要说明的问题<br>密切相关的部件，图中数字都为十六进制)。（没写完，未完待续）</p>
<p><strong>&#x3D;&#x3D;8086CPU 的工作过程可以简要描述如下&#x3D;&#x3D;</strong><br>&#x3D;&#x3D;<strong>1.从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>2.IP&#x3D;IP+所读取指令的长度，从而指向下一条指令;</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>3.执行指令。转到步骤(1)，重复这个过程。</strong>&#x3D;&#x3D;<br>在 8086CPU加电启动或复位后(即 CPU 刚开始工作时)CS 和IP被设置为CS&#x3D;FFFFH，IP&#x3D;0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFF0H 单元中读取指执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p>
<h4 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="&#x3D;&#x3D;修改CS、IP的指令&#x3D;&#x3D;"></a>&#x3D;&#x3D;修改CS、IP的指令&#x3D;&#x3D;</h4><p>mov 指令&#x3D;&#x3D;<strong>不能</strong>&#x3D;&#x3D;用于设置 CS、IP 的值</p>
<p>&#x3D;&#x3D;<strong>jmp 指令</strong>&#x3D;&#x3D;<strong>可以修改CS、IP 的指令</strong></p>
<p><strong>&#x3D;&#x3D;jmp语法：“jmp 段地址:偏地址”&#x3D;&#x3D;</strong>	jmp 2AE3:3，执行后:CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H 处读取指令</p>
<p>​					<strong>&#x3D;&#x3D;jmp ax，在含义上好似:mov IP,ax&#x3D;&#x3D;</strong></p>
<h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>前面讲过，对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N(N≤64KB)的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，我们可以认为，<strong>这段内存是用来存放代码的，从而定义了一个代码段</strong></p>
<h4 id="查看cpu和内存，用机器指令和汇编指令编程（dosbox）"><a href="#查看cpu和内存，用机器指令和汇编指令编程（dosbox）" class="headerlink" title="&#x3D;&#x3D;查看cpu和内存，用机器指令和汇编指令编程（dosbox）&#x3D;&#x3D;"></a>&#x3D;&#x3D;查看cpu和内存，用机器指令和汇编指令编程（dosbox）&#x3D;&#x3D;</h4><p>&#x3D;&#x3D;R命令:查看、修改CPU中寄存器的内容&#x3D;&#x3D;<br>&#x3D;&#x3D;D命令:查看内存中的内容&#x3D;&#x3D;<br>&#x3D;&#x3D;E命令:修改内存中的内容(可以写入数据、指令，在内存中，它们实际上没有区别)&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;U命令:将内存中的内容解释为机器指令和对应的汇编指令&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;T命令:执行CSIP指向的内存单元处的指令&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;A命令:以汇编指令的形式向内存中写入指令&#x3D;&#x3D;</p>
<h2 id="第三章-寄存器-内存访问"><a href="#第三章-寄存器-内存访问" class="headerlink" title="第三章 寄存器(内存访问)"></a>第三章 寄存器(内存访问)</h2><h4 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h4><p><strong>字单元</strong>：即存放一个字型数据**(16 位)<strong>的内存单元，</strong>由两个地址连续的内存单元组成<strong>。</strong>高地址内存单元<strong>中</strong>存放<strong>字型数据的</strong>高位字节<strong>，</strong>低地址内存单元<strong>中</strong>存放<strong>字型数据的</strong>低位字节**。</p>
<h4 id="DS-和-address"><a href="#DS-和-address" class="headerlink" title="DS 和[address]"></a>DS 和[address]</h4><p><strong>DS 寄存器</strong>，通常用来存放要访问数据的<strong>段地址</strong>。</p>
<figure class="highlight plaintext"><figcaption><span>Language</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx，1000H</span><br><span class="line">mov ds,bx </span><br><span class="line">mov al,[0]//[0]表示内存单元的偏移地址</span><br></pre></td></tr></table></figure>


<p>上面的3条指令将10000H(1000:)中的数据读到al中</p>
<p><strong>8086CPU</strong> &#x3D;&#x3D;不支持&#x3D;&#x3D;将数据直接送入<strong>段寄存器</strong>的操作，<strong>ds 是一个段寄存器</strong>，所以mov ds，1000H这条指是<strong>非法</strong>的。<strong>只好用一个寄存器来进行中转</strong></p>
<h4 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h4><p>8086CPU是16 位结构，有 16 根数据线，所以，可以一次性传送 16 位的数据，也就是说可以一次性传送一个字。只要在 mov 指令中给出 16 位的存器就可以进行 16 位数据的传送了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,11316//2c34H</span><br><span class="line">mov [0],ax</span><br><span class="line">mov bx，[0]</span><br><span class="line">sub bx，[2]</span><br><span class="line">mov [2],bx</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231128190417961.png" alt="image-20231128190417961"></p>
<h4 id="mov、add、sub-指令"><a href="#mov、add、sub-指令" class="headerlink" title="&#x3D;&#x3D;mov、add、sub 指令&#x3D;&#x3D;"></a>&#x3D;&#x3D;mov、add、sub 指令&#x3D;&#x3D;</h4><p>前面我们用到了mov、add、sub 指令，它们都带有两个操作对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8	;mov 寄存器，数据</span><br><span class="line">mov ax,bx	;mov 寄存器，寄存器</span><br><span class="line">mov ax,[0]	;mov 寄存器，内存单元</span><br><span class="line">mov [0],ax	;mov 内存单元，寄存器</span><br><span class="line">mov ds,ax	;mov 段寄存器，寄存器</span><br><span class="line">mov ax,ds	;mov 寄存器，段寄存器</span><br><span class="line">mov [0],cs	;mov 内存单元，段寄存器</span><br><span class="line">mov cs,[0]	;mov 段寄存器，内存单元</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add ax,8	;add 寄存器，数据</span><br><span class="line">add ax,bx	;add 寄存器，寄存器</span><br><span class="line">add ax,[0]	;add 寄存器，内存单元</span><br><span class="line">add [O],ax	;add 内存单元，寄存器</span><br><span class="line">sub ax,9	;sub 寄存器，数据</span><br><span class="line">sub ax,bx	;sub 寄存器，寄存器</span><br><span class="line">sub ax,[0]	;sub 寄存器，内存单元</span><br><span class="line">sub [O],ax	;sub 内存导昂版臂元，寄存器</span><br></pre></td></tr></table></figure>

<h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。<strong>我们可以将一组长度为 N(N&lt;64KB)、地址连续、起始地址为 16的倍数的内存单元当作专门存储数据的内存空间</strong>，从而定义了一个数据段。</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="&#x3D;&#x3D;栈&#x3D;&#x3D;"></a>&#x3D;&#x3D;栈&#x3D;&#x3D;</h4><p>**&#x3D;&#x3D;栈&#x3D;&#x3D;<strong>是一种具有特殊的访问方式的存储空间。它的特殊性就在于，</strong>&#x3D;&#x3D;最后进入&#x3D;&#x3D;<strong>这个空间的数据，</strong>&#x3D;&#x3D;最先出去&#x3D;&#x3D;**。</p>
<h4 id="CPU-提供的栈机制"><a href="#CPU-提供的栈机制" class="headerlink" title="&#x3D;&#x3D;CPU 提供的栈机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;CPU 提供的栈机制&#x3D;&#x3D;</h4><p><strong>&#x3D;&#x3D;PUSH&#x3D;&#x3D;(入栈)</strong>	 push ax 表示将<strong>寄存器 ax 中的数据送入栈中</strong>，</p>
<p><strong>&#x3D;&#x3D;POP&#x3D;&#x3D;(出栈)</strong>		pop ax 表示<strong>从顶取出数据送入 ax</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266H</span><br><span class="line">push bx</span><br><span class="line">mov Cx,1122H</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231129193859165.png" alt="image-20231129193859165"></p>
<p><strong>&#x3D;&#x3D;段寄存器 SS&#x3D;&#x3D;<strong>：栈顶的</strong>段地址</strong>存放在SS中，相关规则与ds相同 mov ss,1000h非法</p>
<p><strong>&#x3D;&#x3D;寄存器 SP&#x3D;&#x3D;<strong>：栈顶的</strong>偏移地址</strong>存放在SP中。</p>
<p><strong>&#x3D;&#x3D;任意时刻，SS:SP 指向栈顶元素。&#x3D;&#x3D;</strong></p>
<p><strong>入栈时，栈顶从&#x3D;&#x3D;高地址向低地址&#x3D;方向增长。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231129200014071.png" alt="image-20231129200014071"></p>
<h4 id="栈顶超界的问题"><a href="#栈顶超界的问题" class="headerlink" title="栈顶超界的问题"></a>栈顶超界的问题</h4><p>push超界</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231130190041473.png" alt="image-20231130190041473"></p>
<p>pop超界</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231130190145344.png" alt="image-20231130190145344"></p>
<p>这也就是说，8086CPU <strong>只知道栈顶在何处</strong>(由SS:SP 指示)，而<strong>不知道我们安排的栈空间有多大</strong>。8086CPU 它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条。<br>我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界，执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。</p>
<h4 id="push、pop-指令"><a href="#push、pop-指令" class="headerlink" title="push、pop 指令"></a>push、pop 指令</h4><p>push 寄存器			将一个寄存器中的数据入栈</p>
<p>pop 寄存器;出栈	 用一个寄存器接收出栈的数据</p>
<p>push 段寄存器		将一个段寄存器中的数据入栈</p>
<p>pop 段寄存器		  出栈，用一个段寄存器接收出栈的数据</p>
<p>push 内存单元		将一个内存字单元处的字入栈（注意:栈操作都是以字为单位）</p>
<p>pop 内存单元		  出栈，用一个内存字单元接收出栈的数据</p>
<h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。<strong>我们可以将长度为 N(N64KB)的一组地址连续、起始地址为 16的倍数的内存单元，当作栈空间来用，&#x3D;&#x3D;从而定义了一个栈段&#x3D;&#x3D;。</strong>比如，我们将10010H~1001FH这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段，段地址为 1001H，大小为 16 字节。</p>
<h2 id="第四章：第一个程序"><a href="#第四章：第一个程序" class="headerlink" title="第四章：第一个程序"></a>第四章：第一个程序</h2><h4 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程-"></a>一个源程序从写出到执行的过程-</h4><p><strong>第一步:编写汇编源程序</strong><br>使用文本编辑器(如 Edit、记事本等)，用汇编语言编写汇编源程序。<br>这一步工作的结果是产生了一个存储源程序的文本文件。<br><strong>第二步:对源程序进行编译连接。</strong><br>使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件;再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。<br>可执行文件包含<strong>两部分内容</strong><br>1.<strong>程序</strong>(从源程序中的汇编指令翻译过来的机器码)<strong>和数据</strong>(源程序中定义的<br>2.<strong>相关的描述信息</strong>(比如，程序有多大、要占用多少内存空间等)<br><strong>结果</strong>:产生了一个可在操作系统中运行的可执行文件。<br><strong>第三步:执行可执行文件中的程序</strong></p>
<p>在操作系统中，执行可执行文件中的程序<br>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化(比如设置 CS:IP 指向第一条要执行的指)，然后由 CPU 执行程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231217183643810.png" alt="image-20231217183643810"></p>
<h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment//codesg是段名</span><br><span class="line">	mov ax,0123H</span><br><span class="line">	mov bx,0456H</span><br><span class="line">	add ax,bx</span><br><span class="line">	add ax,ax</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>在汇编语言<strong>源程序</strong>中，包含两种指令，一种是&#x3D;&#x3D;<strong>汇编指令</strong>&#x3D;&#x3D;，一种是**&#x3D;&#x3D;伪指令&#x3D;&#x3D;**</p>
<p>**&#x3D;&#x3D;汇编指令&#x3D;&#x3D;<strong>是有对应的机器码的指令，</strong>可以被编译为机器指令,最终为 &#x3D;&#x3D;CPU 所执行&#x3D;&#x3D;**。</p>
<p><strong>&#x3D;&#x3D;伪指令&#x3D;&#x3D;<strong>没有对应的机器指令，最终</strong>不被 CPU 所执行</strong>，伪指令<strong>是由&#x3D;&#x3D;编译器&#x3D;&#x3D;来执行的指令</strong>，编译器根据伪指令来进行相关的编译工作。</p>
<h6 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="&#x3D;&#x3D;1.伪指令&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;1.伪指令&#x3D;&#x3D;</strong></h6><p>1.<strong>segment和ends</strong>是一对<strong>成对</strong>使用的伪指令，这是在写可被编译器编译的汇编程序时<strong>必须要用到的一对伪指令</strong>。segment 和ends的<strong>功能是&#x3D;&#x3D;定义一个段&#x3D;&#x3D;<strong>。</strong>segment 说明一个段开始</strong>，<strong>ends 说明一个段结束</strong>。一个段必须有一个名称来标识，使用格式为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">	:</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>

<p>2.<strong>end</strong> 是一个<strong>汇编程序的&#x3D;&#x3D;结束标记&#x3D;&#x3D;<strong>，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。所以，在我们写程序的时候，</strong>如果程序写完了，要在结尾处加上伪指令end</strong>。<strong>否则，编译器在编译程序时，无法知道程序在何处结束。</strong><br>&#x3D;&#x3D;<strong>注意，不要搞混了end和ends</strong>&#x3D;&#x3D;，<strong>ends 是和segment 成对使用的</strong>，<strong>标记一个段的结束ends的含义可理解为“end segment”</strong>。我们这里讲的<strong>end 的作用是标记整个程序的结束。</strong></p>
<p>3.assume<br>这条伪指令的含义为<strong>“假设”</strong>。<strong>它假设某一段寄存器和程序中的某一个用segment…ends 定义的段相关联</strong>。<strong>通过 assume 说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系</strong>。assume 并不是一条非要深入理解不可的伪指令，以后我们编程时，记着<strong>用 assume 将有特定用途的段和相关的段寄存器关联起来即可。</strong><br>比如，在程序4.1中，我们用 codesg segment … codesg ends 定义了一个名为 <strong>codseg的段</strong>，在<strong>这个段中存放代码</strong>，所以<strong>这个段是一个代码段</strong>。在程序的开头，<strong>用 &#x3D;&#x3D;assume cs:codesg&#x3D;&#x3D;将用作代码段的段 &#x3D;&#x3D;codesg 和CPU中的段存器cs 联系起来&#x3D;&#x3D;。</strong></p>
<h6 id="2-源代码中的程序"><a href="#2-源代码中的程序" class="headerlink" title="&#x3D;&#x3D;2.源代码中的程序&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;2.源代码中的程序&#x3D;&#x3D;</strong></h6><p><strong>这里所说的程序就是指源程序中最终由计算机执行、处理的指令或数据。</strong><br><strong>&#x3D;&#x3D;注意&#x3D;&#x3D;<strong>，以后可以将</strong>源程序文件中的&#x3D;&#x3D;所有内容称为源程序&#x3D;&#x3D;<strong>，</strong>将源程序中&#x3D;&#x3D;最终由计算机执行、处理的指令或数据，称为程序&#x3D;&#x3D;<strong>。程序</strong>最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。</strong></p>
<h6 id="3-标号"><a href="#3-标号" class="headerlink" title="&#x3D;&#x3D;3.标号&#x3D;&#x3D;"></a><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231217192918964.png" alt="image-20231217192918964">&#x3D;&#x3D;<strong>3.标号</strong>&#x3D;&#x3D;</h6><p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，<strong>比如“codesg’个标号指代了一个地址</strong>。<strong>比如 codesg 在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</strong></p>
<h6 id="4-程序的结构"><a href="#4-程序的结构" class="headerlink" title="&#x3D;&#x3D;4.程序的结构&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;4.程序的结构&#x3D;&#x3D;</strong></h6><p>我们现在讨论一下汇编程序的结构。在前3章中，我们都是通过直接在 Debug 中写入汇编指令来写汇编程序，对于十分简短的程序这样做的确方便。可对于大一些的程序，就不能如此了。<strong>我们需要写出能让编译器进行编译的源程序，这样的源程序应该具备起码的结构。</strong><br>源程序是由一些段构成的。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。我们现在来一步步地完成一个小程序，从这个过程中体会一下汇编程序中的基本要素和汇编程序的简单框架。</p>
<p>任务:编程运算23。源程序应该怎样来写呢?<br>(1)我们要定义一个段，名称为 abc。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">	:</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure>

<p>(2) 在这个段中写入汇编指令，来实现我们的任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure>

<p>(3)然后，要指出程序在何处结束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>(4) abc 被当作代码段来用，所以，应该将 abc 和 cs 联系起来。(当然，对于这个程序，也不是非这样做不可。)<strong>&#x3D;&#x3D;&#x2F;&#x2F;4.2&#x3D;&#x3D;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"> mov ax,2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h6 id="5-程序返回"><a href="#5-程序返回" class="headerlink" title="&#x3D;&#x3D;5.程序返回&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;5.程序返回&#x3D;&#x3D;</strong></h6><p>我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么，它怎样得到运行呢?<br>下面，我们在 DOS(一个单任务操作系统)的基础上，简单地讨论一下这个问题<br>一个程序 P2在可执行文件中，则必须有一个正在运行的程序 P1，将 P2从可执行文件中加载入内存后，将CPU 的控制权交给 P2，P2才能得以运行。P2开始运行后，P1暂停运行。<br>而当P2 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P1，此后P1继续运行。<br>现在，我们知道，一个程序结束后，将 CPU的控制权交还给使它得以运行的程序，我们称这个过程为:程序返回。那么，如何返回呢?应该在程序的末尾添加返回的程序段。<br>我们回过头来，看一下程序 4.1 中的两条指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax，4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>

<p>这两条指令所实现的功能就是程序返回<br>在目前阶段，我们不必去理解 int 21H 指的含义，和为什么要在这条指令的前面加上指令mov ax,4c00H。我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231217200812396.png" alt="image-20231217200812396"></p>
<h6 id="6-语法错误和逻辑错误"><a href="#6-语法错误和逻辑错误" class="headerlink" title="&#x3D;&#x3D;6.语法错误和逻辑错误&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;6.语法错误和逻辑错误&#x3D;&#x3D;</strong></h6><p>可见，程序 4.2在运行时会引发一些问题，因为程序没有返回。当然，这个错误在编译的时候是不能表现出来的，也就是说，程序 4.2 对于编译器来说是正确的程序。<br>般说来，程序在编译时被编译器发现的错误是语法错误，比如将程序 4.2 写成如下这样就会发生语法错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"> mov ax，2</span><br><span class="line"> add aX,ax</span><br><span class="line"> add ax,ax</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>显然，程序中有编译器不能识别的aume，而且编译器在编译的过程中也无法知道abc段到何处结束。<br>在源程序编译后，在运行时发生的错误是逻辑错误。语法错误容易发现，也容易解决。而逻辑错误通常不容易被发现。不过，程序 4.2 中的错误却显而易见，我们将它改正过来:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line"></span><br><span class="line"> mov ax,2</span><br><span class="line"> add ax,ax</span><br><span class="line"> add ax,ax</span><br><span class="line"> </span><br><span class="line"> mov ax,4c00H</span><br><span class="line"> int 21H</span><br><span class="line"> </span><br><span class="line">ac ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="编辑源程序"><a href="#编辑源程序" class="headerlink" title="编辑源程序"></a>编辑源程序</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231218164126311.png" alt="image-20231218164126311"></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="&#x3D;&#x3D;编译&#x3D;&#x3D;"></a>&#x3D;&#x3D;编译&#x3D;&#x3D;</h4><p>1.dosbox设置虚拟c盘</p>
<p>2.输入C:\masm</p>
<p>3.如果已经将d:&#x2F;asm&#x2F;MASM设置为虚拟c盘，要运行其中的.ASM在虚拟化c盘的目录下，我们需要将那个文件夹视为c盘，输入c:1.asm</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227172759096.png" alt="image-20231227172759096"></p>
<p>4.obj（目标文件）文件的生成</p>
<p>不输入默认在1.asm的所在文件夹内生成1.obj</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173105489.png" alt="image-20231227173105489"></p>
<p>5.列表文件的生成</p>
<p>不输入输出地址即为不生成</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173239069.png" alt="image-20231227173239069"></p>
<p>6.交叉引用文件的生成</p>
<p>不输入输出地址即为不生成</p>
<p>7.编译结束</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227173436707.png" alt="image-20231227173436707"></p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>1.2.步骤与上同理</p>
<p>3.输入link.exe</p>
<p>4.如果是obj文件输入文件名即可，非obj文件需要带上文件后缀</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227174601366.png" alt="image-20231227174601366"></p>
<p>5.因为已经确定了目标文件名为 1.bj，则程序默认要输出的可执行文件名为1.EXE，所以可以不必再另行指定文件名。直接按 Enter 键，编译程序将在当前的目录下，生成1.EXE文件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227174757293.png" alt="image-20231227174757293"></p>
<p>6.忽略映像文件生成，直接【enter】</p>
<p>7.库文件连接，忽略直接【enter】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227175112103.png" alt="image-20231227175112103"></p>
<p>警告为：没有栈段（后文再叙）</p>
<p>连接的作用：</p>
<p>(1)当<strong>源程序很大</strong>时，可以将它<strong>分为多个源程序文件</strong>来编译，<strong>每个源程序编译成为目标文件后</strong>，<strong>再用连接程序将它们连接到一起，生成一个可执行文件</strong>;<br>(2)&#x3D;&#x3D;<strong>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件;</strong>&#x3D;&#x3D;<br>(3)一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，<strong>在&#x3D;&#x3D;只有一个源程序文件&#x3D;&#x3D;，而&#x3D;&#x3D;又不需要调用某个库中的子程序&#x3D;&#x3D;的情况下，也&#x3D;&#x3D;必须用&#x3D;&#x3D;连接程序对目标文件进行处理，生成可执行文件。</strong><br>注意，对于连接的过程，<strong>可执行文件是我们要得到的最终结果。</strong></p>
<h4 id="以简化的方式进行编译和连接"><a href="#以简化的方式进行编译和连接" class="headerlink" title="以简化的方式进行编译和连接"></a>以简化的方式进行编译和连接</h4><p>简化编译	<strong>C:\&gt;masm c:\1;</strong></p>
<p>简化连接	<strong>C:\&gt;link 1;</strong></p>
<p><strong>&#x3D;&#x3D;自动忽略中间文件的生成&#x3D;&#x3D;</strong></p>
<h4 id="1-exe的执行"><a href="#1-exe的执行" class="headerlink" title="1.exe的执行"></a>1.exe的执行</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227183159432.png" alt="image-20231227183159432"></p>
<h4 id="程序执行过程的追踪"><a href="#程序执行过程的追踪" class="headerlink" title="程序执行过程的追踪"></a>程序执行过程的追踪</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../AppData/Roaming/Typora/typora-user-images/image-20231227193505217.png" alt="image-20231227193505217"></p>
<h2 id="第五章-BX-和-loop-指令"><a href="#第五章-BX-和-loop-指令" class="headerlink" title="第五章[BX]和 loop 指令"></a>第五章[BX]和 loop 指令</h2><p><strong>1.[bx]和内存单元的描述</strong></p>
<p>要完整地描述一个内存单元，需要<strong>两种信息</strong>:&#x3D;&#x3D;<strong>1内存单元的地址</strong>&#x3D;&#x3D;;&#x3D;&#x3D;<strong>2内存单元的长度</strong>&#x3D;&#x3D;</p>
<p>mov ax，[bx]<br>&#x3D;&#x3D;<strong>将一个内存单元的内容送入 ax</strong>&#x3D;&#x3D;<strong>，这个内存单元的长度为 2 字节(字单元)，存放一个字，</strong>&#x3D;&#x3D;<strong>偏移地址在 bx中</strong>&#x3D;&#x3D;，&#x3D;&#x3D;段地址在 ds 中&#x3D;&#x3D;。</p>
<p><strong>2.我们定的描述性的符号:“()”</strong></p>
<p>(ax)表示ax中的内容、(al)表示al中的内容</p>
<p>(20000H)表示内存 20000H 单元的内容（()中的内存单元的地址为物理地址）;</p>
<p>((ds)*16+(bx))表示:<strong>ds 中的内容为ADR1</strong>，<strong>bx中的内容为 ADR2</strong>，<strong>内存ADR1*16+ADR2单元的内容</strong></p>
<p>也可以理解为:<strong>ds 中的 ADR1 作为段地址</strong>，<strong>bx 中的 ADR2作为偏移地址</strong>，<strong>内存ADR1:ADR2单元的内容。</strong></p>
<p>注意，“( )”中的元素可以有 <strong>3 种类型</strong>:&#x3D;&#x3D;<strong>1.寄存器名</strong>&#x3D;&#x3D;;&#x3D;&#x3D;<strong>2.段寄存器名</strong>&#x3D;&#x3D;:&#x3D;&#x3D;<strong>3.内存单元的物理地址</strong>&#x3D;&#x3D;(一个 20位数据)。比如:<br>**(ax)、(ds)、(al)、 (cx)、(20000H)、((ds)*16+(bx))<strong>等是</strong>正确**的用法;</p>
<p><strong>(2000:0)、((ds):1000H)<strong>等是</strong>不正确</strong>的用法。</p>
<p>我们看一下(X)的应用，比如，<br>(1)ax中的内容为0010H，可以这样来描述：(ax)&#x3D;0010H;</p>
<p>(2) 2000:1000 处的内容为 0010H，可以这样来描述：(21000H)&#x3D;0010H;</p>
<p>(3)对于mov ax,[2]的功能，可以这样来描述：(ax)&#x3D;((ds)<em>16+2);</em></p>
<p>(4)对于 mov  [2],ax的功能，可以这样来描述：((ds)*16+2)&#x3D;(ax);</p>
<p>(5)对于add ax,2的功能，可以这样来描述：(ax)&#x3D;(ax)+2;</p>
<p>(6)对于add ax,bx的功能，可以这样来描述：(ax)&#x3D;(ax)+(bx);</p>
<p>(7)对于 push ax的功能，可以这样来描述：(sp)&#x3D;(sp)-2	((ss)*16+(sp))&#x3D;(ax)</p>
<p>(8)对于 pop ax的功能，可以这样来描述：(ax)&#x3D;((ss)*16+(sp))	(sp)&#x3D;(sp)+2</p>
<p><strong>“(X)”</strong>所表示的数据有两种类型:<strong>1.字节</strong>;<strong>2.字</strong>。</p>
<p>(al)、(bI)、(cl)等得到的数据为字节型;</p>
<p>(ds)、(ax)、(bx)等得到的数据为字型;</p>
<p>(al)&#x3D;(20000H)，则(20000H)得到的数据为字节型;</p>
<p>(ax)&#x3D;(20000H)，则(20000H)得到的数据为字型。</p>
<p><strong>3.约定符号idata 表示常量</strong></p>
<h4 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1[BX]"></a>5.1[BX]</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br></pre></td></tr></table></figure>

<p>含义：bx中的内容加1。</p>
<h4 id="5-2loop指令"><a href="#5-2loop指令" class="headerlink" title="5.2	loop指令"></a>5.2	loop指令</h4><p>格式</p>
<p>(1)在 &#x3D;&#x3D;<strong>cx 中存放循环次数</strong>&#x3D;&#x3D;</p>
<p>(2)<strong>&#x3D;&#x3D;loop  指令中的标号所标识地址要在前面&#x3D;&#x3D;</strong></p>
<p>(3)<strong>&#x3D;&#x3D;要循环执行的程序段，要写在标号和 loop 指令的中间&#x3D;&#x3D;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">	循环执行的程序段</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax，2</span><br><span class="line">	</span><br><span class="line">	mov cx,11</span><br><span class="line">s:	add ax,axs:</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax，4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>(1) 标号**&#x3D;&#x3D;s&#x3D;&#x3D;**<br>    在汇编语言中，标号代表一个地址，程序中有一个标号 <strong>&#x3D;&#x3D;s&#x3D;&#x3D;<strong>。它实际上标识了一个地址，这个地址处有一条指令:</strong>&#x3D;&#x3D;add ax,ax&#x3D;&#x3D;<strong>。<br>(2) loop s<br>CPU执行 loops的时候，要进行</strong>两步操作</strong>:<br>&#x3D;&#x3D;<strong>1.(cx)&#x3D;(cx)-1;</strong>&#x3D;&#x3D;<br><strong>&#x3D;&#x3D;2.判断 cx中的值，不为 0则转至标号s所的地址处执行(这里的指是 add ax,ax)如果为零则执行下一条指令(下一条指令是mov ax,4c00h)。&#x3D;&#x3D;</strong><br>(3) 以下3条指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	mov cx，11</span><br><span class="line">s:	add ax,ax</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>

<p>执行 <strong>loop s</strong> 时，<strong>首先要将(cx)减 1，然后若(cx)不为0，则向前转至 s 处执行add ax,ax</strong>。所以，<strong>可以利用cx来控制add ax,ax 的执行次数。</strong></p>
<h4 id="5-3-在Debug-中跟踪用-loop-指令实现的循环程序"><a href="#5-3-在Debug-中跟踪用-loop-指令实现的循环程序" class="headerlink" title="5.3 在Debug 中跟踪用 loop 指令实现的循环程序"></a>5.3 在Debug 中跟踪用 loop 指令实现的循环程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh//在汇编源程序中，数据不能以字母开头</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx，6</span><br><span class="line">	</span><br><span class="line">	mov al，[bx]</span><br><span class="line">	mov ah,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	</span><br><span class="line">	mov cx，3</span><br><span class="line">s: 	add dx,ax//第12行</span><br><span class="line">	loops</span><br><span class="line">	mov ax，4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>循环程序段从CS:0012开始，我们不想再一步步地跟踪CS:0012前面的指令，从 CS:0012 处开始跟踪。**&#x3D;&#x3D;可以这样来使用g 命令，“g 0012”&#x3D;&#x3D;**</p>
<p>当然，也可以用g命令来达到目的，<strong>可以用“g 0016”直接执行到 CS:0016 处</strong></p>
<p>我们希望将循环一次执行完。可以使用 p 命令来达到目的。再次遇到loop 指令时，<strong>使用p命令来执行</strong>，Debug 就会自动重复执行循环中的指令，直到(cx)&#x3D;0为止。</p>
<h4 id="5-4-Debug-和汇编编译器-masm-对指令的不同处理"><a href="#5-4-Debug-和汇编编译器-masm-对指令的不同处理" class="headerlink" title="5.4 Debug 和汇编编译器 masm 对指令的不同处理"></a>5.4 Debug 和汇编编译器 masm 对指令的不同处理</h4><p>“mov al,[0]”，含义:(al)&#x3D;0，将常量0送入al中(与mov al,0含义相同)</p>
<p>“mov al,ds:[0]”，含义:(al)&#x3D;((ds)*16+0)，将内存单元中的数据送入al中;</p>
<p>“mov al,[bx]”，含义:(al)&#x3D;((ds)*16+(bx))，将内存单元中的数据送入al中</p>
<p>“mov al,ds:[bx]”，含义:与“mov al,[bx]”相同。</p>
<p>从上面的比较中可以看出:<br>(1)在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用“[…]”来表示内存单元，如果在“[]”里用一个常量 idata 直接给出内存单元的偏移地址，就要<strong>在“[]”的前面</strong>显式地<strong>给出段地址所在的段寄存器。</strong>比如<br><strong>mov al,ds:[0]</strong><br>如果<strong>没有在“[]”的前面</strong>显式地<strong>给出段地址所在的段寄存器</strong>，比如<br><strong>mov al,[0]</strong><br>那么，<strong>编译器masm将把指令中的“[idata]”解释为“idata”</strong><br>(2) 如果在“[]”里用寄存器，<strong>比如 bx，间接给出内存单元的偏移地址</strong>，<strong>则段地址默认在 ds 中</strong>。当然，<strong>也可以显式地给出段地址所在的段寄存器。</strong></p>
<h4 id="5-5-loop-和-bx-的联合应用"><a href="#5-5-loop-和-bx-的联合应用" class="headerlink" title="5.5 loop 和[bx]的联合应用"></a>5.5 loop 和[bx]的联合应用</h4><p>计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,Offffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx，0				;初始化ds:bx指向 ffff:0</span><br><span class="line"></span><br><span class="line">	mov dx，0				;初始化累加寄存器dx，(dx)=0</span><br><span class="line">	mov cx，12				;初始化循环计数寄存器 cx，(cx)=12</span><br><span class="line"></span><br><span class="line">s:	mov al，[bx]</span><br><span class="line">	mov ah，0</span><br><span class="line">	add dx,ax				 ;间接向 dx中加上((ds)*16+(bx))单元的数值</span><br><span class="line">	inc bx					 ;ds:bx 指向下一个单元</span><br><span class="line">	loop s</span><br><span class="line"></span><br><span class="line">	mov ax，4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>8位字节型数累加结果存入16位字型dx中</p>
<p>1.将8位字节型数据存入中间暂存16位字型ax中，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al，[bx]</span><br><span class="line">mov ah，0</span><br></pre></td></tr></table></figure>

<p>2.将16位ax中的数据转入到dx中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add dx,ax	</span><br></pre></td></tr></table></figure>

<p>3.设计循环，可把bx（bx已经初始化为0）当作为中间变量，在循环的末尾加上一句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br></pre></td></tr></table></figure>

<h4 id="5-6段前缀"><a href="#5-6段前缀" class="headerlink" title="5.6段前缀"></a>5.6段前缀</h4><p>用于显式地指明内存单元的段地址的“ds:” “cs:” “ss:” “es:”在汇编语言中称为段前缀</p>
<p>例如<strong>mov ax,ds:[bx]</strong> 中的ds:</p>
<h4 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h4><p>(1)我们需要直接向一段内存中写入内容:</p>
<p>(2)这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误;</p>
<p>(3) DOS 方式下，一般情况，0:20~0:2ff 空间中没有系统或其他程序的数据或代码;(可以先用debug检查一下)</p>
<p>(4)以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff这空间</p>
<h4 id="5-8段前缀的使用"><a href="#5-8段前缀的使用" class="headerlink" title="5.8段前缀的使用"></a>5.8段前缀的使用</h4><p>将内存ffff:0<del>ffff:b单元中的数据复制到0:200</del>0:20b 单元中</p>
<p>0:200<del>0:20b→0020:0</del>0020:b</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax			;用 ds 存放源始空间ffff:0~ffff:b 的段地址。</span><br><span class="line">	</span><br><span class="line">	mov ax,0020h</span><br><span class="line">	mov es,ax			;用es 存放标空间 0020:00020:b 的段地址</span><br><span class="line">	</span><br><span class="line">	mov cx,12</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">s:	mov dl,[bx]</span><br><span class="line">	mov es:[bx],dl		;显式地用段前缀“es:”给出单元的段地址，这样就不必在循环中重复设置 ds。</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="第6章包含多个段的程序"><a href="#第6章包含多个段的程序" class="headerlink" title="第6章包含多个段的程序"></a>第6章包含多个段的程序</h2><h4 id="6-1在代码段中使用数据"><a href="#6-1在代码段中使用数据" class="headerlink" title="6.1在代码段中使用数据"></a>6.1在代码段中使用数据</h4><p>我们若要 CPU从何处开始执行程序，<strong>只要在源程序中用“end 标号”指明就可以了。</strong><br>有了这种方法，就可以这样来安排程序的框架:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">		:</span><br><span class="line">		:</span><br><span class="line">		数据</span><br><span class="line">		:</span><br><span class="line">		:</span><br><span class="line">start:</span><br><span class="line">		:</span><br><span class="line">		:</span><br><span class="line">		代码</span><br><span class="line">		:</span><br><span class="line">		:</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>考虑这样一个问题，编程计算以下8个数据的和，结果存在ax寄存器中:</p>
<p>0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,Odefh,0fedh,0cbah,0987h</span><br><span class="line">	start:	mov bx,0</span><br><span class="line">			mov ax，0</span><br><span class="line">			</span><br><span class="line">			mov cx,8</span><br><span class="line">		s:	add ax,cs:[bx]</span><br><span class="line">			add bx,2</span><br><span class="line">			loop s</span><br><span class="line"></span><br><span class="line">			mov ax，4c00h</span><br><span class="line">			int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>​	程序中的“dw”的含义是<strong>定义字型数据</strong>。**dw 即“defineword’’**在这里，使用 dw 定义了 8 个字型数据(数据之间以号分隔)，它们所占的内存空间的大小为16个字节。</p>
<h4 id="6-2在代码段中使用栈"><a href="#6-2在代码段中使用栈" class="headerlink" title="6.2在代码段中使用栈"></a>6.2在代码段中使用栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,Ofedh,0cbah,0987h</span><br><span class="line">	dw 0,0,0,0,0.0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">				;用dw定义16个字型数据，在程序加载后，将取得16个字的</span><br><span class="line">				;内存空间，存放这16个数据。在后面的程序中将这段</span><br><span class="line">				;空间当作栈来使用</span><br><span class="line">	</span><br><span class="line">	start:	mov aX,CS</span><br><span class="line">			mov ss，ax</span><br><span class="line">			mov sp，30h		;将设置栈顶ss:sp指cs:30</span><br><span class="line">			</span><br><span class="line">			mov bx，0</span><br><span class="line">			mov cx，8</span><br><span class="line">	s:		push cs:[bx]</span><br><span class="line">			add bx,2</span><br><span class="line">			loop s			;以上将代码段0~15单元中的8个字型数据</span><br><span class="line">							;依次入栈</span><br><span class="line"></span><br><span class="line">			mov cX，8</span><br><span class="line">			mov bx，0</span><br><span class="line">	s0:		pop cs:[bx]</span><br><span class="line">			add bx，2</span><br><span class="line">			loop s0			;以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line">			</span><br><span class="line">			mov ax，4c00h</span><br><span class="line">			int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start					;指明程序的入口在start处</span><br></pre></td></tr></table></figure>

<p>监测点6.1</p>
<p>cs是代码段寄存器，所以改写程序中的数据就是改写cs:ip的数据所以要mov cs:[bx],ax</p>
<h4 id="6-3将数据、代码、栈放入不同的段"><a href="#6-3将数据、代码、栈放入不同的段" class="headerlink" title="6.3将数据、代码、栈放入不同的段"></a>6.3将数据、代码、栈放入不同的段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 0123h，0456h,0789h,0abch,Odefh,Ofedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line">	</span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line">	</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,20h		;设置栈顶ss:sp指向 stack:20</span><br><span class="line">		</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax		;ds指向data段</span><br><span class="line">		</span><br><span class="line">		mov bx,0		;ds:bx指向 data段中的第一个单元</span><br><span class="line">		</span><br><span class="line">		mov cx,8</span><br><span class="line">s:		push [bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s			;以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line">		</span><br><span class="line">		mov bx，0</span><br><span class="line">		</span><br><span class="line">		mov cx，8</span><br><span class="line">s0:		pop [bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s0			;以上依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line">		</span><br><span class="line">		mov ax，4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>(1)定义多个段的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume 寄存器名:[name]</span><br><span class="line">[name] segment</span><br><span class="line">	数据内容</span><br><span class="line">[name] ends</span><br></pre></td></tr></table></figure>

<p>(2)对段地址的引用</p>
<p>要把data:6送入bx中</p>
<p><strong>要用</strong>下面代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure>

<p>我们<strong>不能</strong>用下面的指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ds,data</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure>

<p>(3)“代码段”数据段”“栈段”完全是我们的安排</p>
<p>CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对 CS:IP、SS:SP、DS 等寄存器的设置来决定的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hesiy-cnpwn.xyz">来不及了🥵就你了吧❤~</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hesiy-cnpwn.xyz/2024/05/21/%E6%B1%87%E7%BC%96/">https://hesiy-cnpwn.xyz/2024/05/21/%E6%B1%87%E7%BC%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hesiy-cnpwn.xyz" target="_blank">哥布林的❤秘密❤洞穴</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://patchwiki.biligame.com/images/blhx/thumb/7/7f/8usj4ct58dnkg6xngs2x0b9f94m3d6e.jpg/350px-%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%E6%8D%A2%E8%A3%85.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/06/03/litctf24%EF%BC%88%E9%83%BD%E6%98%AF%E8%80%BB%E8%BE%B1%EF%BC%89/" title="LitCTF2024逆向wp"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LitCTF2024逆向wp</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://patchwiki.biligame.com/images/blhx/thumb/7/7f/8usj4ct58dnkg6xngs2x0b9f94m3d6e.jpg/350px-%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%E6%8D%A2%E8%A3%85.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">来不及了🥵就你了吧❤~</div><div class="author-info__description">👉你来了就别想跑了👌</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Hesiycn"><i class="fab fa-github"></i><span>❤哥布林的爱巢❤</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hesiycn" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1014588798@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">👑这是哥布林的皇宫👑</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-text">汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">第一章	基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-text">汇编语言的组成：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%82%A8%E5%AD%98%E5%8D%95%E5%85%83%EF%BC%9A"><span class="toc-text">储存单元：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu%E5%AF%B9%E5%82%A8%E5%AD%98%E5%99%A8%E9%83%BD%E8%AF%BB%E5%86%99"><span class="toc-text">cpu对储存器都读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF"><span class="toc-text">地址总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF"><span class="toc-text">数据总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF"><span class="toc-text">控制总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-%E6%A6%82%E8%BF%B0"><span class="toc-text">内存地址空间(概述)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9D%BF"><span class="toc-text">主板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8D%A1"><span class="toc-text">接口卡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">内存地址空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AF%84%E5%AD%98%E5%99%A8-%E4%BD%A0%E7%8C%9C%E4%BB%96%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E4%B8%AA%E2%80%9C%E5%AF%84%E2%80%9D%EF%BC%88%EF%BC%89"><span class="toc-text">第二章	寄存器	&#x2F;&#x2F;你猜他为什么会有个“寄”（）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-text">&#x3D;&#x3D;几条汇编指令&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E4%BD%8D%E7%BB%93%E6%9E%84cpu%EF%BC%88%E5%85%B8%E5%9E%8B8086%EF%BC%89"><span class="toc-text">16位结构cpu（典型8086）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8086cpu%E7%BB%99%E5%87%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">8086cpu给出物理地址的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E6%AE%B5%E5%9C%B0%E5%9D%80X16-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E2%80%9D%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89"><span class="toc-text">“段地址X16+偏移地址&#x3D;物理地址”的本质含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">段的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CS%E5%92%8CIP"><span class="toc-text">CS和IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9CS%E3%80%81IP%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">&#x3D;&#x3D;修改CS、IP的指令&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-text">代码段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bcpu%E5%92%8C%E5%86%85%E5%AD%98%EF%BC%8C%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B%EF%BC%88dosbox%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;查看cpu和内存，用机器指令和汇编指令编程（dosbox）&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-text">第三章 寄存器(内存访问)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%97%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">内存中字的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DS-%E5%92%8C-address"><span class="toc-text">DS 和[address]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%9A%84%E4%BC%A0%E9%80%81"><span class="toc-text">字的传送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mov%E3%80%81add%E3%80%81sub-%E6%8C%87%E4%BB%A4"><span class="toc-text">&#x3D;&#x3D;mov、add、sub 指令&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">&#x3D;&#x3D;栈&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6"><span class="toc-text">&#x3D;&#x3D;CPU 提供的栈机制&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E8%B6%85%E7%95%8C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">栈顶超界的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push%E3%80%81pop-%E6%8C%87%E4%BB%A4"><span class="toc-text">push、pop 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%AE%B5"><span class="toc-text">栈段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-text">第四章：第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%86%99%E5%87%BA%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">一个源程序从写出到执行的过程-</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">&#x3D;&#x3D;1.伪指令&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-text">&#x3D;&#x3D;2.源代码中的程序&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%A0%87%E5%8F%B7"><span class="toc-text">&#x3D;&#x3D;3.标号&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">&#x3D;&#x3D;4.程序的结构&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="toc-text">&#x3D;&#x3D;5.程序返回&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E5%92%8C%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF"><span class="toc-text">&#x3D;&#x3D;6.语法错误和逻辑错误&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">编辑源程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-text">&#x3D;&#x3D;编译&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-text">连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%AE%80%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%9E%E6%8E%A5"><span class="toc-text">以简化的方式进行编译和连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-exe%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text">1.exe的执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E8%BF%BD%E8%B8%AA"><span class="toc-text">程序执行过程的追踪</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-BX-%E5%92%8C-loop-%E6%8C%87%E4%BB%A4"><span class="toc-text">第五章[BX]和 loop 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-BX"><span class="toc-text">5.1[BX]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2loop%E6%8C%87%E4%BB%A4"><span class="toc-text">5.2	loop指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%9C%A8Debug-%E4%B8%AD%E8%B7%9F%E8%B8%AA%E7%94%A8-loop-%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%A8%8B%E5%BA%8F"><span class="toc-text">5.3 在Debug 中跟踪用 loop 指令实现的循环程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-Debug-%E5%92%8C%E6%B1%87%E7%BC%96%E7%BC%96%E8%AF%91%E5%99%A8-masm-%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86"><span class="toc-text">5.4 Debug 和汇编编译器 masm 对指令的不同处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-loop-%E5%92%8C-bx-%E7%9A%84%E8%81%94%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-text">5.5 loop 和[bx]的联合应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="toc-text">5.6段前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E4%B8%80%E6%AE%B5%E5%AE%89%E5%85%A8%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-text">5.7 一段安全的空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5.8段前缀的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-text">第6章包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-text">6.1在代码段中使用数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-text">6.2在代码段中使用栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="toc-text">6.3将数据、代码、栈放入不同的段</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 来不及了🥵就你了吧❤~</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="25" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>